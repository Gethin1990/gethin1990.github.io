[{"categories":[],"content":"摘要 什么是云原生？ 什么是12要素 云原生应该关注什么？ 微服务架构 敏捷基础设施及公共基础服务 分布式架构设计 云原生程度的评判标准是什么？ 云服务现在如何，未来怎么走？ ","date":"2021-10-20","objectID":"https://blog.gethin.online/cloud-software-architect/:0:0","tags":[],"title":"云上软件架构","uri":"https://blog.gethin.online/cloud-software-architect/"},{"categories":[],"content":"什么是云原生 云原生的概念最早开始于 2010 年，在当时 Paul Fremantle 的一篇博客中被提及，他一直想用一个词表达一种架构，这种架构能描述应用程序和中间件在云环境中的良好运行状态。因此他抽象出了 Cloud Native 必须包含的属性，只有满足了这些属性才能保证良好的运行状态。当时提出云原生是为了能构建一种符合云计算特性的标准来指导云计算应用的编写。 后来到 2013 年 Matt Stine 在推特上迅速推广云原生概念，并在 2015 年《迁移到云原生架构》一书中定义了符合云原生架构的特征：12 因素、微服务、自服务、基于 API 协作、扛脆弱性。而由于这本书的推广畅销，这也成了很多人对云原生的早期印象，同时云原生也被 12 要素变成了一个抽象的概念。Matt Stine 认为在单体架构向 Cloud Native 迁移的过程中，需要文化、组织、技术共同变革。 ","date":"2021-10-20","objectID":"https://blog.gethin.online/cloud-software-architect/:1:0","tags":[],"title":"云上软件架构","uri":"https://blog.gethin.online/cloud-software-architect/"},{"categories":[],"content":"12要素 2012 年，Heroku 创始人 Adam Wiggins 发布十二要素应用宣言。它为构建一个优雅的互联网应用，定义了需要遵循的一些基本原则和方法论，也广泛影响了众多的微服务应用架构。十二要素重点关注：应用程序的健康成长，开发者之间的有效的协作，以及避免软件架构腐化的影响。 基准代码：一份基准代码，多份部署，使用 GIT 或者 SVN 管理代码，并且有明确的版本信息。 依赖：显示声明依赖。 配置：环境中存储配置。 后端服务：把后端服务当作附加资源。后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（MySQL、CouchDB）、消息/队列系统（RabbitMQ、Beanstalkd）、SMTP 邮件发送服务（Postfix），以及缓存系统（Memcached）。 构建、发布、运行：严格分离构建和运行。 进程：以一个或多个无状态进程运行应用，如果存在状态，应该将状态外置到后端服务中，例如数据库、缓存等。 端口绑定：通过端口绑定提供服务，应用通过端口绑定来提供服务，并监听发送至该端口的请求。 并发：通过进程模型进行扩展，扩展方式有进程和线程两种。进程的方式使扩展性更好，架构更简单，隔离性更好。线程扩展使编程更复杂，但是更节省资源。 易处理：快速启动和优雅终止可最大化健壮性，只有满足快速启动和优雅终止，才能使服务更健壮。 开发环境与线上环境等价：尽可能保持开发、预发布、线上环境相同。 日志：把日志当作事件流，微服务架构中服务数量的爆发需要具备调用链分析能力，快速定位故障。 管理进程：把后台管理任务当作一次性进程运行，一些工具类在生产环境上的操作可能是一次性的，因此最好把它们放在生产环境中执行，而不是本地。 12 要素应用为我们提供了很好的架构指导，帮助我们： 构建水平伸缩的弹性应用架构，更好支撑互联网规模应用。 提升研发流程的标准化、自动化水平，提升研发效率。 减少开发环境和生产环境的差异，并使用持续交付实施敏捷开发。 提升应用的可移植性，适合云化部署，降低资源成本和管理复杂性。 ","date":"2021-10-20","objectID":"https://blog.gethin.online/cloud-software-architect/:1:1","tags":[],"title":"云上软件架构","uri":"https://blog.gethin.online/cloud-software-architect/"},{"categories":[],"content":"云原生应该关注什么 ","date":"2021-10-20","objectID":"https://blog.gethin.online/cloud-software-architect/:2:0","tags":[],"title":"云上软件架构","uri":"https://blog.gethin.online/cloud-software-architect/"},{"categories":[],"content":"微服务架构 Martin Fowler 与 James Lewis 共同提出了微服务的概念，定义了微服务架构是以开发一组小型服务的方式来开发一个独立的应用系统，每个服务都以一个独立进程的方式运行，每个服务与其他服务使用轻量级（通常是 HTTP API）通信机制。这些服务是围绕业务功能构建的，可以通过全自动部署机制独立部署，同时服务会使用最小规模的集中管理（例如 Docker）能力，也可以采用不同的编程语言和数据库。 Multi-Runtime（多运行时）软件架构中提出将把现代分布式应用的需求分为四种类型（生命周期，网络，状态，绑定） Lifecycle(生命周期) [主要是弹性伸缩和异常快速恢复的诉求]： Packaging(打包) HealthCheck(健康检查) Deployment(部署) Scaling(缩放) Configuration(配置) Networking(网络) [可靠的网络、可靠的路由的需求] Service discovery（服务发现） A/B testing（AB测试）, canary rollouts（金丝雀发布） Retry（重试）,timeout（超时）,circuit breaker（断路器） Point-to-point（点对点）,pub/sub（订阅/发布） security（安全）,observability（可观测的） State(状态) [可靠的网络、可靠的路由的需求] Workflow management（工作流管理） Idempotency（幂等） Temporal scheduling（临时调度（cron作业）） Caching（缓存） Application state（程序状态） Binding(绑定) [与外部系统、中间件的通讯的需求] Connectors（连接器） Protocol conversion（协议转换） Message transformation（消息转换） Message routing（消息路由） Transactionality（事务性） 其中有一些需求可以使用基础架构来实现，有一些则需要软件架构级别来实现，那么哪些部分在现阶段的云原生架构中可以实现？ ","date":"2021-10-20","objectID":"https://blog.gethin.online/cloud-software-architect/:2:1","tags":[],"title":"云上软件架构","uri":"https://blog.gethin.online/cloud-software-architect/"},{"categories":[],"content":"敏捷基础设施及公共基础服务 敏捷基础设施的目标 标准化：所有的基础设施最好都是标准的。 可替换：任意节点都能够被轻易地创建、销毁、替换。 自动化：所有的操作都通过工具自动化完成，无须人工干预。 可视化：当前环境要做到可控，就需要对当前的环境状况可视。 可追溯：所有的配置统一作为代码进行版本化管理，所有的操作都可以追溯。 快速：资源申请及释放要求秒级完成，以适应弹性伸缩和故障切换的要求。 基于公共基础服务的平台化 平台化是指利用公共基础服务提升整体架构能力。 公共基础服务是指与业务无关的、通用的服务，包括监控服务、缓存服务、消息服务、数据库服务、负载均衡、分布式协调、分布式任务调度等。 常见的平台服务 监控告警服务 分布式消息中间件服务 分布式缓存服务 分布式任务调度服务 在我的博客云上基础架构提到，基础架构关注点如下： 服务注册 服务发现 监控 限流 路由 负载均衡 超时重试 熔断 服务降级 故障迁移 博客里同样也提到了，基础架构目前市面上主流3.0架构方案是以Istio为代表的Service Mesh方案。 Istio 具有的强大特性提供了一种统一的、更有效的方式来保护、连接和监视服务。Istio 只需要进行简单的配置就可实现服务的负载均衡、服务到服务的身份验证等分布式功能。Isito的控制平面非常强大，它可以对Istio进行配置和管理，包括： 使用 TLS 加密、强身份认证和授权的集群内服务到服务的安全通信 自动负载均衡的 HTTP、gRPC、WebSocket和 TCP 流量 通过丰富的路由规则、重试、故障转移和故障注入对流量行为进行细粒度控制 一个可插入的策略层和配置 API，支持访问控制、速率限制和配额 对集群内的所有流量(包括集群入口和出口)进行自动度量、日志和跟踪 istio 完整功能如下，看来istio已经基本满足上述所有的基础架构关注点 流量管理 请求路由 - A/B测试、金丝雀发布等，包括对集群出入口、及集群内部的流量的控制。比如某应用新版本发布，可以配置为5%的流量流向新版本，95%的给旧版本 流量转移 - 与上一条请求路由类似，可以平滑的将流量从旧版本转移到新版本上 负载均衡 - 目前支持3种方式，轮询、随机和带权重的最少请求 服务发现 - 带心跳的健康检查，失败率超标的Pod移出负载均衡池 故障处理 - 超时、重发、熔断、上游并发请求或下游连接数限制等 微调 - 支持用特殊的请求头参数，覆盖默认的超时、重发值 故障注入 - 由Enovy在正常的集群中人为注入故障，比如TCP包损坏或延迟、HTTP错误码等，支持按百分比注入，比如给10%的流向服务A的请求包增加5秒延迟 多重匹配 - 上述规则的配置，支持按多种条件匹配，且支持and或or的方式匹配多条规则 Gateway - 接管集群入口的流量，替代了Ingress，从而对入口流量执行其他规则 Service Entry - 接管集群内部访问外部服务的流量，从而对出口流量执行一些规则 镜像 - 支持将特定的流量镜像到服务路径之外，而不影响主服务路径的正常执行 安全 命名空间访问控制 - 支持配置某命名空间的所有或个别服务可以被其他命名空间访问 服务级别访问控制 - 允许或禁止访问某个服务 双向TLS - HTTPS加密传输 其他安全策略 策略 速率限制 - 比如限制每秒的请求次数 黑白名单 - 支持基于IP或属性的黑名单、白名单 遥测 日志收集 - 支持将Prometheus、Jaeger等系统插入Mixer，从而完成数据的采集 指标采集 分布式追踪 ","date":"2021-10-20","objectID":"https://blog.gethin.online/cloud-software-architect/:2:2","tags":[],"title":"云上软件架构","uri":"https://blog.gethin.online/cloud-software-architect/"},{"categories":[],"content":"分布式架构设计 可用性设计 什么降低了可用性 发布 故障 压力 外部依赖 设计阶段考虑如下几个比较重要的方法 20/10/5，设计系统的时候，以实际流量的 20 倍来设计；开发系统的时候，以实际流量的 10 倍来开发系统；发布系统的时候，以实际流量的 5 倍来部署。这只是一个通用的原则，可以根据实际情况来确定，不需要严格按照倍数来执行。 Design for failure，预测可能发生的问题，做好预案。 容错设计 消除单点 特性开关 服务分级 降级设计 超时重试 隔离策略 线程池隔离 进程隔离 集群隔离 用户隔离 租户隔离 逻辑隔离 物理隔离 混合隔离 熔断器 熔断器模式（Circuit Breaker Patten）的原理类似于家里的电路熔断器的原理。当发生短路或者超负荷时，熔断器能够主动熔断电路，以避免灾难发生。 流控设计 限流算法。限流也就是调节数据流的平均速率，通过限制速率保护自己，常见的算法有： 固定窗口算法（fixed window）。 漏桶算法（Leaky Bucket）：漏桶算法主要目的是控制数据注入网络的速率，平滑网络上的突发流量。 令牌桶算法（token bucket）：令牌桶控制的是一个时间窗口内通过的数据量，通常我们会以 QPS、TPS 来衡量。 流控策略 请求入口处。 业务服务入口处。 公共基础服务处。 基于 Guava 限流：Guava 是 Google 提供的 Java 扩展类库，其中的限流工具类 RateLimiter 采用的就是令牌桶算法，使用起来非常简单。 基于 Nginx 限流。 容量预估 互联网公司普遍采用全链路压测的方式，来进一步预估容量。 故障演练 随机关闭生产环境中的实例。 让某台机器的请求或返回变慢，观察系统的表现，可以用来测试上游服务是否有服务降级能力，当然如果响应时间特别长，也就相当于服务不可用。 模拟 AZ 故障，中断一个机房，验证是否跨可用区部署，业务容灾和恢复的能力。 查找不符合最佳实践的实例，并将其关闭 数据迁移 逻辑分离，物理不分离。 物理分离。 可扩展设计 水平扩展，指用更多的节点支撑更大量的请求。 横向扩展通常是为了提升吞吐量，响应时间一般要求不受吞吐量影响即可。 如何扩展数据库 X 轴扩展——主从复制集群 Y 轴扩展——分库、垂直分表 Z 轴扩展——分片（sharding） 性能设计 性能指标 响应时间（Latency），就是发送请求和返回结果的耗时。 吞吐量（Throughput），就是单位时间内的响应次数。 负载敏感度，是指响应时间随时间变化的程度。例如，当用户增加时，系统响应时间的衰减速度。 可伸缩性，是指向系统增加资源对性能的影响。例如，要使吞吐量增加一倍，需要增加多少服务器。 如何树立目标 响应时间、 吞吐量、系统数据量、数据增长速度、资源限制 通过缓存提升读性能。 通过消息中间件提升写性能。 一致性设计 事务的四大特征 原子性（Atomicity）。 一致性（Consistency）是指通过事务保证数据从一种状态变化到另一种状态。 隔离性（Isolation）是指事务内的操作不受其他操作影响，当多个事务同时处理同一个数据的时候，多个事务之间是互不影响的。 持久性（Durability）是指事务被提交后，应该持久化，永久保存下来。 CAP定理 一致性（Consistence） 可用性（Availability） 分区容错性（Partition tolerance） BASE 理论 BA:Basically Available，基本可用。 S:Soft state，软状态。 E:Eventually consistent，最终一致。 Quorum 机制（NWR 模型） 如果多个服务分别向三个节点写数据，为了保证强一致，就必须要求三个节点全部写成功才返回；同步写三个节点的性能较低，如果换一个思路，一致性并不一定要在写数据的时候完成，可以在读的阶段再决策，只要每次能读到最新版本即可。Quorum 机制就是要满足公式 W+R\u003eN，式中 N 代表备份个数，W 代表要写入至少 W 份才认为成功，R 表示至少读取 R 个备份。 租约机制（Lease） 如果现在我们有三个节点，为了实现一致性，要确保有且只有一个是 Leader，另外两个为 Follower，只有 Leader 是可写的，Follower 只能读。管理节点 M 通过心跳判断各个节点的状态，用 M 去指定 Leader，一旦 Leader 死掉，就可以重新指定一个 Leader。 脑裂问题 一种是采用投票机制（Paxos 算法）。 一种是采用租约机制——Lease，租约机制的核心就是在一定时间内将权力下放。 分布式系统的一致性分类 建立多个副本。可以把副本放到不同的物理机、机架、机房、地域，当一个副本失效时，可以让请求转到其他副本。 对数据进行分区。复制多个副本解决了读的性能问题，但是无法解决写的性能问题。 以数据为中心的一致性模型 严格一致性（Strict Consistency） 顺序一致性（Sequential Consistency） 因果一致性（Causal Consistency） 以用户为中心的一致性模型 单调读一致性（Monotonic-read Consistency） 单调写一致性（Monotonic-write Consistency） 写后读一致性（Read-your-writes Consistency） 读后写一致性（Writes-follow-reads Consistency） 业界常用的一致性模型 弱一致性：写入一个数据 a 成功后，在数据副本上可能读出来，也可能读不出来。不能保证每个副本的数据一定是一致的。 最终一致性（Eventual Consistency）：写入一个数据 a 成功后，在其他副本有可能读不到 a 的最新值，但在某个时间窗口之后保证最终能读到。 强一致性（Strong Consistency）：数据 a 一旦写入成功，在任意副本任意时刻都能读到 a 的最新值。 如何实现强一致性 两阶段提交 三阶段提交（3PC） 如何实现最终一致性 重试机制：超时时间，重试的次数，重试的间隔时间，重试间隔时间的衰减度。 本地记录日志。 可靠事件模式。 Saga 事务模型：又叫 Long-running-transaction，核心思想是把一个长事务拆分为多个本地事务来实现，由一个 Process manager 统一协调。 TCC 事务模型：两阶段提交是依赖于数据库提供的事务机制，再配合外部的资源协调器来实现分布式事务。TCC（Try Confirm Cancel）事务模型的思想和两阶段提交虽然类似，但是却把相关的操作从数据库提到业务中，以此降低数据库的压力，并且不需要加锁，性能也得到了提升。 ","date":"2021-10-20","objectID":"https://blog.gethin.online/cloud-software-architect/:2:3","tags":[],"title":"云上软件架构","uri":"https://blog.gethin.online/cloud-software-architect/"},{"categories":[],"content":"云原生程度的评判标准是什么 ","date":"2021-10-20","objectID":"https://blog.gethin.online/cloud-software-architect/:3:0","tags":[],"title":"云上软件架构","uri":"https://blog.gethin.online/cloud-software-architect/"},{"categories":[],"content":"云服务现在如何，未来怎么走 Dapr：下一代Service Mesh的发展方向 Dapr（Distributed Application Runtime，分布式运行时），是微软内部团队的一个开源项目。Dapr同样使用Sidecar架构，以独立进程的形式与应用程序同时运行，同时兼具Service Mesh中Sidecar/proxy的优点和高度可扩展的特性。 虽然Dapr 和Service Mesh在架构上都是使用的Sidecar模式，并且在功能上也存在一些重叠部分，但是不能将 Dapr 简单的定义为Service Mesh。 而在Dapr中，实现的能力主要有： 状态管理 （支持长时间运行有状态服务的上下文信息。） 服务调用 （使用平台不可知的协议和众所周知的终结点调用直接、安全的服务到服务调用。） 订阅发布（在服务之间实现安全的可缩放发布/订阅消息传送。） 绑定 （通过与双向通信的外部资源引发的事件触发代码。） 可观察性 （监视和度量跨网络服务的消息调用。） 机密 （安全访问外部密钥存储。） 执行组件 （在可重用的执行组件对象中封装逻辑和数据。） Service Mesh主要以基础设施为中心： Service Mesh更加聚焦于网络问题的处理，通过拦截网络流量，可以使应用程序无感知的部署在包含Service Mesh的环境中。 并且Service Mesh主要由系统操作员进行管理和部署，使Service Mesh更像是一种特殊的“基础设施”。开发人员无需考虑一些其他的细节，因为Service Mesh已经将网络概念扁平化。 Service Mesh通过按照原协议转发的方式来进行流量拦截，可以给业务系统带来零侵入的体验。 而Dapr是以开发人员为中心： 当开发人员在代码中需要使某种分布式能力时，开发人员需要明确调用Dapr API。Dapr为开发者提供了标准的分布式API，这种API带来了多语言的、面向能力的、统一的编程体验。 Dapr提供了应用级别的构建块（Building Block）和70多种分布式能力的抽象集成，使得开发人员更容易将应用程序构建为弹性的微服务。 Dapr通过采用多语言SDK+标准API+各种分布式能力的方式为应用程序提供服务。 参考文献 快速了解云原生架构 我对云原生软件架构的观察与思考 Dapr：我不是Service Mesh！我只是长得很像 ","date":"2021-10-20","objectID":"https://blog.gethin.online/cloud-software-architect/:4:0","tags":[],"title":"云上软件架构","uri":"https://blog.gethin.online/cloud-software-architect/"},{"categories":["软件工程"],"content":"测试方法 ","date":"2021-09-30","objectID":"https://blog.gethin.online/test-and-review-methodologies/:1:0","tags":["测试评审","系统架构师"],"title":"测试评审方法","uri":"https://blog.gethin.online/test-and-review-methodologies/"},{"categories":["软件工程"],"content":"软件测试阶段 单元测试 重点：模块接口，局部数据结构，重要的执行通路，出错处理通路，边界条件 集成测试 非渐增式，渐增式 系统测试 确认测试（需求说明书检查，软件配置复查），验收测试（alpha，beta） ","date":"2021-09-30","objectID":"https://blog.gethin.online/test-and-review-methodologies/:1:1","tags":["测试评审","系统架构师"],"title":"测试评审方法","uri":"https://blog.gethin.online/test-and-review-methodologies/"},{"categories":["软件工程"],"content":"白盒测试和黑盒测试 白盒测试 语句覆盖，判定覆盖，条件覆盖，判定/条件覆盖，条件组合覆盖，路径覆盖 黑盒测试 等价类划分，边值分析，错误推测，因果图 缺陷的分类和级别 分类：输入/输出错误，逻辑错误，计算错误，接口错误，数据错误 级别：轻微，中等，使人不悦，影响使用，严重，非常严重，极为严重，无法容忍，灾难性，传染性 调试 排错策略：原始类，回溯类，排除类 ","date":"2021-09-30","objectID":"https://blog.gethin.online/test-and-review-methodologies/:1:2","tags":["测试评审","系统架构师"],"title":"测试评审方法","uri":"https://blog.gethin.online/test-and-review-methodologies/"},{"categories":["软件工程"],"content":"评审方法 软件需求评审，概要设计评审，详细设计评审，软件验证和确认评审，功能检查，物理检查，综合检查，管理评审 注意：不应以测试代替评审，评审人员应关注产品而不应评论开发人员，评审人员应关注实质性问题，评审会议不应变为问题解决方案讨论会，评审应被安排进入项目计划，评审参与者应了解整个评审过程，评审人员事先应对评审材料充分了解，应重视评审的组织工作 ","date":"2021-09-30","objectID":"https://blog.gethin.online/test-and-review-methodologies/:1:3","tags":["测试评审","系统架构师"],"title":"测试评审方法","uri":"https://blog.gethin.online/test-and-review-methodologies/"},{"categories":["软件工程"],"content":"验证与确认 验证：合同验证，过程验证，需求验证，设计验证，编码验证，集成验证，文档验证 确认 ","date":"2021-09-30","objectID":"https://blog.gethin.online/test-and-review-methodologies/:1:4","tags":["测试评审","系统架构师"],"title":"测试评审方法","uri":"https://blog.gethin.online/test-and-review-methodologies/"},{"categories":["软件工程"],"content":"测试自动化 测试用例生成，测试执行控制，测试结果对比，测试结果分析，总测试状况的统计与报表产生 ","date":"2021-09-30","objectID":"https://blog.gethin.online/test-and-review-methodologies/:1:5","tags":["测试评审","系统架构师"],"title":"测试评审方法","uri":"https://blog.gethin.online/test-and-review-methodologies/"},{"categories":["软件工程"],"content":"面向对象测试 OOA测试，OOD测试，OOP测试，单元测试，集成测试，系统测试 ","date":"2021-09-30","objectID":"https://blog.gethin.online/test-and-review-methodologies/:1:6","tags":["测试评审","系统架构师"],"title":"测试评审方法","uri":"https://blog.gethin.online/test-and-review-methodologies/"},{"categories":[],"content":"独享数据库（Database per Microservice） 当一家公司将大型单体系统替换成一组微服务，首先要面临的最重要决策是关于数据库。单体架构会使用大型中央数据库。即使转移到微服务架构许多架构师仍倾向于保持数据库不变。虽然有一些短期收益，但它却是反模式的，特别是在大规模系统中，微服务将在数据库层严重耦合，整个迁移到微服务的目标都将面临失败（例如，团队授权、独立开发等问题）。 更好的方法是为每个微服务提供自己的数据存储，这样服务之间在数据库层就不存在强耦合。这里我使用数据库这一术语来表示逻辑上的数据隔离，也就是说微服务可以共享物理数据库，但应该使用分开的数据结构、集合或者表，这还将有助于确保微服务是按照领域驱动设计的方法正确拆分的。 优点 数据由服务完全所有。 服务的开发团队之间耦合度降低。 缺点 服务间的数据共享变得更有挑战性。 在应用范围的保证 ACID 事务变得困难许多。 细心设计如何拆分单体数据库是一项极具挑战的任务。 何时使用独享数据库 在大型企业应用程序中。 当团队需要完全把控微服务以实现开发规模扩展和速度提升。 何时不宜使用独享数据库 在小规模应用中。 如果是单个团队开发所有微服务。 可用技术示例 所有 SQL、 NoSQL 数据库都提供数据的逻辑分离（例如，单独的表、集合、结构、数据库）。 延伸阅读 微服务模式：独享数据库 https://microservices.io/patterns/data/database-per-service.html 分布式数据存储 https://docs.microsoft.com/en-us/dotnet/architecture/cloud-native/distributed-data ","date":"2021-09-27","objectID":"https://blog.gethin.online/microservice-patterns/:1:0","tags":[],"title":"[转载]微服务架构的设计模式","uri":"https://blog.gethin.online/microservice-patterns/"},{"categories":[],"content":"事件源（Event Sourcing） 在微服务架构中，特别使用独享数据库时，微服务之间需要进行数据交换。对于弹性高可伸缩的和可容错的系统，它们应该通过交换事件进行异步通信。在这种情况，您可能希望进行类似更新数据库并发送消息这样的原子操作，如果在大数据量的分布式场景使用关系数据库，您将无法使用两阶段锁协议（2PL），因为它无法伸缩。而 NoSQL 数据库因为大多不支持两阶段锁协议甚至无法实现分布式事务。 在这些场景，可以基于事件的架构使用事件源模式。在传统数据库中，直接存储的是业务实体的当前“状态”，而在事件源中任何“状态”更新事件或其他重要事件都会被存储起来，而不是直接存储实体本身。这意味着业务实体的所有更改将被保存为一系列不可变的事件。因为数据是作为一系列事件存储的，而非直接更新存储，所以各项服务可以通过重放事件存储中的事件来计算出所需的数据状态。 优点 为高可伸缩系统提供原子性操作。 自动记录实体变更历史，包括时序回溯功能。 松耦合和事件驱动的微服务。 缺点 从事件存储中读取实体成为新的挑战，通常需要额外的数据存储（CQRS 模式）。 系统整体复杂性增加了，通常需要领域驱动设计。 系统需要处理事件重复（幂等）或丢失。 变更事件结构成为新的挑战。 何时使用事件源 使用关系数据库的、高可伸缩的事务型系统。 使用 NoSQL 数据库的事务型系统。 弹性高可伸缩微服务架构。 典型的消息驱动或事件驱动系统（电子商务、预订和预约系统）。 何时不宜使用事件源 使用 SQL 数据库的低可伸缩性事务型系统 在服务可以同步交换数据（例如，通过 API）的简单微服务架构中。 可用技术示例 事件存储：EventStoreDB， Apache Kafka， Confluent Cloud， AWS Kinesis， Azure Event Hub， GCP Pub/Sub， Azure Cosmos DB， MongoDB， Cassandra. Amazon DynamoDB 框架： Lagom， Akka， Spring， akkatecture， Axon，Eventuate 延伸阅读 事件驱动 https://martinfowler.com/eaaDev/EventSourcing.html 事件驱动模式-云设计模式 https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing 微服务模式：事件驱动 https://microservices.io/patterns/data/event-sourcing.html ","date":"2021-09-27","objectID":"https://blog.gethin.online/microservice-patterns/:2:0","tags":[],"title":"[转载]微服务架构的设计模式","uri":"https://blog.gethin.online/microservice-patterns/"},{"categories":[],"content":"命令和查询职责分离（CQRS） 如果我们使用事件源，那么从事件存储中读取数据就变得困难了。要从数据存储中获取实体，我们需要处理所有的实体事件。有时我们对读写操作还会有不同的一致性和吞吐量要求。 这种情况，我们可以使用 CQRS 模式。在该模式中，系统的数据修改部分（命令）与数据读取部分（查询）是分离的。而 CQRS 模式有两种容易令人混淆的模式，分别是简单的和高级的。 在其简单形式中，不同实体或 ORM 模型被用于读写操作，如下所示： 它有助于强化单一职责原则和分离关注点，从而实现更简洁的设计。 在其高级形式中，会有不同的数据存储用于读写操作。高级的 CQRS 通常结合事件源模式。根据不同情况，会使用不同类型的写数据存储和读数据存储。写数据存储是“记录的系统”，也就是整个系统的核心源头。 对于读频繁的应用程序或微服务架构，OLTP 数据库（任何提供 ACID 事务保证的关系或非关系数据库）或分布式消息系统都可以被用作写存储。对于写频繁的应用程序（写操作高可伸缩性和大吞吐量），需要使用写可水平伸缩的数据库（如全球托管的公共云数据库）。标准化的数据则保存在写数据存储中。 对搜索（例如 Apache Solr、Elasticsearch）或读操作（KV 数据库、文档数据库）进行优化的非关系数据库常被用作读存储。许多情况会在需要 SQL 查询的地方使用读可伸缩的关系数据库。非标准化和特殊优化过的数据则保存在读存储中。 数据是从写存储异步复制到读存储中的，所以读存储和写存储之间会有延迟，但最终是一致的。 优点 在事件驱动的微服务中数据读取速度更快。 数据的高可用性。 读写系统可独立扩展。 缺点 读数据存储是弱一致性的（最终一致性）。 整个系统的复杂性增加了，混乱的 CQRS 会显着危害整个项目。 何时使用 CQRS 在高可扩展的微服务架构中使用事件源。 在复杂领域模型中，读操作需要同时查询多个数据存储。 在读写操作负载差异明显的系统中。 何时不宜使用 CQRS 在没有必要存储大量事件的微服务架构中，用事件存储快照来计算实体状态是一个更好的选择。 在读写操作负载相近的系统中。 可用技术示例 写存储：EventStoreDB， Apache Kafka， Confluent Cloud， AWS Kinesis， Azure Event Hub， GCP Pub/Sub， Azure Cosmos DB， MongoDB， Cassandra. Amazon DynamoDB 读存储： Elastic Search， Solr， Cloud Spanner， Amazon Aurora， Azure Cosmos DB， Neo4j 框架： Lagom， Akka， Spring， akkatecture， Axon， Eventuate 延伸阅读 bliki：CQRS https://martinfowler.com/bliki/CQRS.html CQRS模式 - Azure 架构中心 https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs 微服务模式：命令和查询职责分离（CQRS） https://microservices.io/patterns/data/cqrs.html ","date":"2021-09-27","objectID":"https://blog.gethin.online/microservice-patterns/:3:0","tags":[],"title":"[转载]微服务架构的设计模式","uri":"https://blog.gethin.online/microservice-patterns/"},{"categories":[],"content":"Saga 如果微服务使用独享数据库，那么通过分布式事务管理一致性是一个巨大的挑战。你无法使用传统的两阶段提交协议，因为它要么不可伸缩（关系数据库），要么不被支持（多数非关系数据库）。 但您还是可以在微服务架构中使用 Saga 模式实现分布式事务。Saga 是 1987 年开发的一种古老模式，是关系数据库中关于大事务的一个替代概念。但这种模式的一种现代变种对分布式事务也非常有效。Saga 模式是一个本地事务序列，其每个事务在一个单独的微服务内更新数据存储并发布一个事件或消息。Saga 中的首个事务是由外部请求（事件或动作）初始化的，一旦本地事务完成（数据已保存在数据存储且消息或事件已发布），那么发布的消息或事件则会触发 Saga 中的下一个本地事务。 如果本地事务失败，Saga 将执行一系列补偿事务来回滚前面本地事务的更改。 Saga 事务协调管理主要有两种形式： 事件编排 Choreography：分散协调，每个微服务生产并监听其他微服务的事件或消息然后决定是否执行某个动作。 命令编排 Orchestration：集中协调，由一个协调器告诉参与的微服务哪个本地事务需要执行。 优点 为高可伸缩或松耦合的、事件驱动的微服务架构提供一致性事务。 为使用了不支持 2PC 的非关系数据库的微服务架构提供一致性事务。 缺点 需要处理瞬时故障，并且提供等幂性。 难以调试，而且复杂性随着微服务数量增加而增加。 何时使用 Saga 在使用了事件源的高可伸缩、松耦合的微服务中。 在使用了分布式非关系数据库的系统中。 何时不宜使用 Saga 使用关系数据库的低可伸缩性事务型系统。 在服务间存在循环依赖的系统中。 可用技术示例 Axon， Eventuate， Narayana 延伸阅读 Saga分布式事务-Azure设计模式 https://docs.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga 微服务模式：Sagas https://microservices.io/patterns/data/saga.html Saga 模式：微服务中的应用程序事务 https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/ ","date":"2021-09-27","objectID":"https://blog.gethin.online/microservice-patterns/:4:0","tags":[],"title":"[转载]微服务架构的设计模式","uri":"https://blog.gethin.online/microservice-patterns/"},{"categories":[],"content":"面向前端的后端 （BFF） 在现代商业应用开发，特别是微服务架构中，前后端应用是分离和独立的服务，它们通过 API 或 GraphQL 连接。如果应用程序还有移动 App 客户端，那么 Web 端和移动客户端使用相同的后端微服务就会出现问题。因为移动客户端和 Web 客户端有不同的屏幕尺寸、显示屏、性能、能耗和网络带宽，它们的 API 需求不同。 面向前端的后端模式适用于需要为特殊 UI 定制单独后端的场景。它还提供了其他优势，比如作为下游微服务的封装，从而减少 UI 和下游微服务之间的频繁通信。此外，在高安全要求的场景中，BFF 为部署在 DMZ 网络中的下游微服务提供了更高的安全性。 优点 分离 BFF 之间的关注点，使得我们可以为具体的 UI 优化他们。 提供更高的安全性。 减少 UI 和下游微服务之间频繁的通信。 缺点 BFF 之间代码重复。 大量的 BFF 用于其他用户界面（例如，智能电视，Web，移动端，PC 桌面版）。 需要仔细的设计和实现，BFF 不应该包含任何业务逻辑，而应只包含特定客户端逻辑和行为。 何时使用 BFF 如果应用程序有多个含不同 API 需求的 UI。 出于安全需要，UI 和下游微服务之间需要额外的层。 如果在 UI 开发中使用微前端。 何时不宜使用 BFF 如果应用程序虽有多个 UI，但使用的 API 相同。 如果核心微服务不是部署在 DMZ 网络中。 可用技术示例 任何后端框架（Node.js，Spring，Django，Laravel，Flask，Play，…）都能支持。 延伸阅读 Sam Newman - 面向前端的后端 https://samnewman.io/patterns/architectural/bff/ 面向前端的后端模式 - 云设计模式 https://docs.microsoft.com/en-us/azure/architecture/patterns/backends-for-frontends 微服务模式：API 网关模式 https://microservices.io/patterns/apigateway.html ","date":"2021-09-27","objectID":"https://blog.gethin.online/microservice-patterns/:5:0","tags":[],"title":"[转载]微服务架构的设计模式","uri":"https://blog.gethin.online/microservice-patterns/"},{"categories":[],"content":"API 网关 在微服务架构中，UI 通常连接多个微服务。如果微服务是细粒度的（FaaS） ，那么客户端可能需要连接非常多的微服务，这将变得繁杂和具有挑战性。此外，这些服务包括它们的 API 还将不断进化。大型企业还希望能有其他横切关注点（SSL 终止、身份验证、授权、节流、日志记录等）。 一个解决这些问题的可行方法是使用 API 网关。API 网关位于客户端 APP 和后端微服务之间充当 facade，它可以是反向代理，将客户端请求路由到适当的后端微服务。它还支持将客户端请求扇出到多个微服务，然后将响应聚合后返回给客户端。它还支持必要的横切关注点。 优点 在前端和后端服务之间提供松耦合。 减少客户端和微服务之间的调用次数。 通过 SSL 终端、身份验证和授权实现高安全性。 集中管理的横切关注点，例如，日志记录和监视、节流、负载平衡。 缺点 可能导致微服务架构中的单点故障。 额外的网络调用带来的延迟增加。 如果不进行扩展，它们很容易成为整个企业应用的瓶颈。 额外的维护和开发费用。 何时使用 API 网关 在复杂的微服务架构中，它几乎是必须的。 在大型企业中，API 网关是中心化安全性和横切关注点的必要工具。 何时不宜使用 API 网关 在安全和集中管理不是最优先要素的私人项目或小公司中。 如果微服务的数量相当少。 可用技术示例 Amazon API 网关， Azure API 管理， Apigee， Kong， WSO2 API 管理器 延伸阅读 微服务模式：API 网关模式 https://microservices.io/patterns/apigateway.html API 网关-Azure 架构中心 https://docs.microsoft.com/en-us/azure/architecture/microservices/design/gateway ","date":"2021-09-27","objectID":"https://blog.gethin.online/microservice-patterns/:6:0","tags":[],"title":"[转载]微服务架构的设计模式","uri":"https://blog.gethin.online/microservice-patterns/"},{"categories":[],"content":"Strangler 如果想在运行中的项目中使用微服务架构，我们需要将遗留的或现有的单体应用迁移到微服务。将现有的大型在线单体应用程序迁移到微服务是相当有挑战性的，因为这可能破坏应用程序的可用性。 一个解决方案是使用 Strangler 模式。Strangler 模式意味着通过使用新的微服务逐步替换特定功能，将单体应用程序增量地迁移到微服务架构。此外，新功能只在微服务中添加，而不再添加到遗留的单体应用中。然后配置一个 Facade （API 网关）来路由遗留单体应用和微服务间的请求。当某个功能从单体应用迁移到微服务，Facade 就会拦截客户端请求并路由到新的微服务。一旦迁移了所有的功能，遗留单体应用程序就会被“扼杀（Strangler）”，即退役。 *Md Kamaruzzaman *的 Strangler 优点 安全的迁移单体应用程序到微服务。 可以并行地迁移已有功能和开发新功能。 迁移过程可以更好把控节奏。 缺点 在现有的单体应用服务和新的微服务之间共享数据存储变得具有挑战性。 添加 Facade （API 网关）将增加系统延迟。 端到端测试变得困难。 何时使用 Strangler 将大型后端单体应用程序的增量迁移到微服务。 何时不宜使用 Strangler 如果后端单体应用很小，那么全量替换会更好。 如果无法拦截客户端对遗留的单体应用程序的请求。 可用技术示例 API 网关后端应用框架。 延伸阅读 bliki：StranglerFig 应用程序 https://martinfowler.com/bliki/StranglerFigApplication.html Strangler 模式 - 云设计模式 https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler-fig 微服务模式：Strangler 应用程序 https://microservices.io/patterns/refactoring/strangler-application.html ","date":"2021-09-27","objectID":"https://blog.gethin.online/microservice-patterns/:7:0","tags":[],"title":"[转载]微服务架构的设计模式","uri":"https://blog.gethin.online/microservice-patterns/"},{"categories":[],"content":"断路器 在微服务架构中，微服务通过同步调用其他服务来满足业务需求。服务调用会由于瞬时故障（网络连接缓慢、超时或暂时不可用） 导致失败，这种情况重试可以解决问题。然而，如果出现了严重问题（微服务完全失败），那么微服务将长时间不可用，这时重试没有意义且浪费宝贵的资源（线程被阻塞，CPU 周期被浪费）。此外，一个服务的故障还会引发整个应用系统的级联故障。这时快速失败是一种更好的方法。 在这种情况，可以使用断路器模式挽救。一个微服务通过代理请求另一个微服务，其工作原理类似于电气断路器，代理通过统计最近发生的故障数量，并使用它来决定是继续请求还是简单的直接返回异常。 *Md Kamaruzzaman *的断路器 断路器可以有以下三种状态： 关闭：断路器将请求路由到微服务，并统计给定时段内的故障数量，如果超过阈值，它就会触发并进入打开状态。 打开：来自微服务的请求会快速失败并返回异常。在超时后，断路器进入半开启状态。 半开：只有有限数量的微服务请求被允许通过并进行调用。如果这些请求成功，断路器将进入闭合状态。如果任何请求失败，断路器则会进入开启状态。 优点 提高微服务架构的容错性和弹性。 阻止引发其他微服务的级联故障。 缺点 需要复杂的异常处理。 日志和监控。 应该支持人工复位。 何时使用断路器 在微服务间使用同步通信的紧耦合的微服务架构中。 如果微服务依赖多个其他微服务。 何时不宜使用断路器 松耦合、事件驱动的微服务架构。 如果微服务不依赖于其他微服务。 可用技术示例 API 网关，服务网格，各种断路器库（Hystrix， Reselience4J， Polly）。 延伸阅读 bliki：断路器 https://martinfowler.com/bliki/CircuitBreaker.html 断路器模式 - 云设计模式 https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker 微型服务模式：断路器 https://microservices.io/patterns/reliability/circuit-breaker.html ","date":"2021-09-27","objectID":"https://blog.gethin.online/microservice-patterns/:8:0","tags":[],"title":"[转载]微服务架构的设计模式","uri":"https://blog.gethin.online/microservice-patterns/"},{"categories":[],"content":"外部化配置 每个业务应用都有许多用于各种基础设施的配置参数（例如，数据库、网络、连接的服务地址、凭据、证书路径）。此外在企业应用程序通常部署在各种运行环境（Local、 Dev、 Prod）中，实现这些的一个方法是通过内部配置。这是一个致命糟糕实践，它会导致严重的安全风险，因为生产凭证很容易遭到破坏。此外，配置参数的任何更改都需要重新构建应用程序，这在在微服务架构中会更加严峻，因为我们可能拥有数百个服务。 更好的方法是将所有配置外部化，使得构建过程与运行环境分离，生产的配置文件只在运行时或通过环境变量使用，从而最小化了安全风险。 优点 生产配置不属于代码库，因而最小化了安全漏洞。 修改配置参数不需要重新构建应用程序。 缺点 我们需要选择一个支持外部化配置的框架。 何时使用外部化配置 任何重要的生产应用程序都必须使用外部化配置。 何时不宜使用外部化配置 在验证概念的开发中。 可用技术示例 几乎所有企业级的现代框架都支持外部化配置。 延伸阅读 微服务模式：外部化配置 https://microservices.io/patterns/externalized-configuration.html 一次构建，到处运行：外部化你的配置 https://reflectoring.io/externalize-configuration/ ","date":"2021-09-27","objectID":"https://blog.gethin.online/microservice-patterns/:9:0","tags":[],"title":"[转载]微服务架构的设计模式","uri":"https://blog.gethin.online/microservice-patterns/"},{"categories":[],"content":"消费端驱动的契约测试 在微服务架构中，通常有许多有不同团队开发的微服务。这些微型服务协同工作来满足业务需求（例如，客户请求），并相互进行同步或异步通信。消费端微服务的集成测试具有挑战性，通常用 TestDouble 以获得更快、更低成本的测试运行。但是 TestDouble 通常并不能代表真正的微服务提供者，而且如果微服务提供者更改了它的 API 或 消息，那么 TestDouble 将无法确认这些。另一种选择是进行端到端测试，尽管它在生产之前是强制性的，但却是脆弱的、缓慢的、昂贵的且不能替代集成测试（Test Pyramid）。 在这方面消费端驱动的契约测试可以帮助我们。在这里，负责消费端微服务的团队针对特定的服务端微服务，编写一套包含了其请求和预期响应（同步）或消息（异步）的测试套件，这些测试套件称为显式的约定。对于微服务服务端，将其消费端所有约定的测试套件都添加到其自动化测试中。当特定服务端微服务的自动化测试执行时，它将一起运行自己的测试和约定的测试并进行验证。通过这种方式，契约测试可以自动的帮助维护微服务通信的完整性。 优点 如果提供程序意外更改 API 或消息，可以被快速的自动发现。 更少意外、更健壮，特别是包含大量微服务的企业应用程序。 改善团队自主性。 缺点 需要额外的工作来开发和集成微服务服务端的契约测试，因为他们可能使用完全不同的测试工具。 如果契约测试与真实服务情况不匹配，将可能导致生产故障。 何时使用需求驱动的契约测试 在大型企业业务应用程序中，通常由不同的团队开发不同服务。 何时不宜使用消费端驱动的契约测试 所有微服务由同一团队负责开发的小型简单的应用程序。 如果服务端微服务是相对稳定的，并且不处在活跃的开发状态。 可用技术示例 Pact， Postman， Spring Cloud Contract 延伸阅读 需求驱动契约：一种服务演进模式 https://martinfowler.com/articles/consumerDrivenContracts.html 微服务模式：服务集成契约测试 https://microservices.io/patterns/testing/service-integration-contract-test.html 什么是消费端驱动的契约测试？ https://pactflow.io/what-is-consumer-driven-contract-testing/ ","date":"2021-09-27","objectID":"https://blog.gethin.online/microservice-patterns/:10:0","tags":[],"title":"[转载]微服务架构的设计模式","uri":"https://blog.gethin.online/microservice-patterns/"},{"categories":[],"content":"总结 在现代大规模企业软件开发中，微服务架构能够帮助开发扩展规模并带来很多长期收益。但是微服务架构并不是随处可用的银弹，如果应用在错误的应用程序类型，微服务架构将弊大于利。希望采用微服务架构的开发团队应该遵循最佳实践，并使用一系列可重用的、久经锤炼的设计模式。 微服务架构中至关重要的设计模式是独享数据库。实现这种设计模式具有挑战性，需要其他几种密切相关的设计模式（事件驱动、 CQRS、 Saga）来支持。在具有多个客户端（Web、 Mobile、 Desktop、 Smart Devices）的典型业务应用程序中，客户端和微服务之间的通信量可能是很大的，并且需要统一的安全控制，在这种情况面向前端的后端和 API 网关的设计非常有用。此外，断路器模式可以大大地帮助应对这类应用程序的错误处理场景。迁移遗留的单体应用到微服务是极具挑战性的，而 Strangler 模式可以帮助做到这点。消费端驱动的契约测试是微服务集成测试的基础模式。另外外部化配置是任何现代化应用程序开发中的一种必备模式。 这个系列并不全面，在实际情况中您可能需要其他的设计模式，但这个系列能为您提供一个关于微服务架构设计模式的极好介绍。 本文转自 https://www.jianshu.com/p/ccc4cad717b5，如有侵权，请联系删除。 ","date":"2021-09-27","objectID":"https://blog.gethin.online/microservice-patterns/:11:0","tags":[],"title":"[转载]微服务架构的设计模式","uri":"https://blog.gethin.online/microservice-patterns/"},{"categories":["软件工程"],"content":"项目的范围、时间与成本 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:1:0","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"项目范围管理 项目启动 范围计划编制 范围定义 范围核实 范围变更 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:1:1","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"项目成本管理 资源计划编制 成本估算 成本预算 成本控制 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:1:2","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"项目时间管理 活动定义 活动排序 活动历时估算 进度计划编制 进度控制 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:1:3","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"配置管理与文档管理 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:2:0","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"软件配置管理概念 配置标识 版本控制 状态统计 审计与审查 生产 过程管理 小组协作 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:2:1","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"软件配置管理的解决方案 各种版本控制工具 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:2:2","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"软件文档管理 软件文档的作用 管理依据 任务之间联系的凭证 质量保证 培训与参考 软件维护支持 历史档案 销售可能 文档的归类 开发文档 产品文档 管理文档 文档编制计划 列出应编制文档的目录 提示编制文档应参考的标准 指定文档管理员 提供编制文档所需要的条件 明确保证文档质量的方法 绘制进度表 对文档质量的要求 针对性 准确性 清晰性 完整性 灵活性 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:2:3","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"软件需求管理 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:3:0","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"需求变更 项目启动阶段的变更预防 项目实施阶段的需求变更 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:3:1","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"需求跟踪 确定需求变更控制过程 进行需求变更影响分析 建立需求基准版本和需求控制版本文档 维护需求变更的历史纪录 跟踪每项需求的状态 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:3:2","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"软件开发的质量与风险 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:4:0","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"软件质量管理 软件质量计划 软件质量保证 软件质量控制 软件评审 测试 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:4:1","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"项目风险管理 项目风险管理的概念 内部技术风险 内部非技术风险 公司战略变化、管理人员水平、没有在预算内完成进度 外部法律风险 外部非法律风险 经济环境变化、组织雇佣关系变化 风险管理的过程 风险管理规划 项目风险识别 定性风险分析 定量风险分析 风险应对计划 风险监督与控制 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:4:2","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"人力资源管理 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:5:0","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"组织规划 垂直团队组织 水平团队组织 混合团队组织 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:5:1","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"人员招募 领导能力 沟通技巧 人际交往能力 应付压力能力 培养员工能力 时间管理能力 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:5:2","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"团队建设 形成阶段 震荡阶段 正规阶段 表现阶段 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:5:3","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"软件的运行与评价 软件的稳定性与可靠性评价 软件是否满足了用户的需求 软件实施给用户带来的好处 ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:6:0","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"软件过程改进 CMM CMMI ISO 9000 ITIL ","date":"2021-09-14","objectID":"https://blog.gethin.online/development-management/:7:0","tags":["软件工程","系统架构师"],"title":"开发管理","uri":"https://blog.gethin.online/development-management/"},{"categories":["软件工程"],"content":"项目的提出与选择 ","date":"2021-09-14","objectID":"https://blog.gethin.online/system-plan/:1:0","tags":["软件工程","系统架构师"],"title":"系统计划","uri":"https://blog.gethin.online/system-plan/"},{"categories":["软件工程"],"content":"项目的立项目标和动机 进行基础研究并获取技术 进行应用研发并获得产品 提供技术服务 信息技术产品的使用者 ","date":"2021-09-14","objectID":"https://blog.gethin.online/system-plan/:1:1","tags":["软件工程","系统架构师"],"title":"系统计划","uri":"https://blog.gethin.online/system-plan/"},{"categories":["软件工程"],"content":"项目的选择和确定 选择有核心价值的产品/项目或开发方向 评估项目风险、收益和代价 评估项目的多种实施方式 平衡的选择合适的方案 ","date":"2021-09-14","objectID":"https://blog.gethin.online/system-plan/:1:2","tags":["软件工程","系统架构师"],"title":"系统计划","uri":"https://blog.gethin.online/system-plan/"},{"categories":["软件工程"],"content":"项目的提出和选择结果 项目的提出和选择的结果，最终会以“产品/项目建议书”的方式来体现。 ","date":"2021-09-14","objectID":"https://blog.gethin.online/system-plan/:1:3","tags":["软件工程","系统架构师"],"title":"系统计划","uri":"https://blog.gethin.online/system-plan/"},{"categories":["软件工程"],"content":"可行性研究与效益分析 ","date":"2021-09-14","objectID":"https://blog.gethin.online/system-plan/:2:0","tags":["软件工程","系统架构师"],"title":"系统计划","uri":"https://blog.gethin.online/system-plan/"},{"categories":["软件工程"],"content":"可行性研究和内容 经济可行性 技术可行性 技术 资源 目标 法律可行性 执行可行性 方案的选择 ","date":"2021-09-14","objectID":"https://blog.gethin.online/system-plan/:2:1","tags":["软件工程","系统架构师"],"title":"系统计划","uri":"https://blog.gethin.online/system-plan/"},{"categories":["软件工程"],"content":"成本效益分析 项目可能涉及的成本 基础建设支出 一次性支出 运行维护费用 项目可能涉及的收益 一次性收益 非一次性收益 不可定量的收益 效益分析的若干指标和进一步的分析 收益/投资比 投资回收周期 敏感性分析 ","date":"2021-09-14","objectID":"https://blog.gethin.online/system-plan/:2:2","tags":["软件工程","系统架构师"],"title":"系统计划","uri":"https://blog.gethin.online/system-plan/"},{"categories":["软件工程"],"content":"可行性分析报告 项目背景 管理概要和建议 候选方案 系统描述 经济可行性 技术可行性 法律可行性 用户使用可行性 其他与项目有关的问题 ","date":"2021-09-14","objectID":"https://blog.gethin.online/system-plan/:2:3","tags":["软件工程","系统架构师"],"title":"系统计划","uri":"https://blog.gethin.online/system-plan/"},{"categories":["软件工程"],"content":"方案的制订和改进 确定软件架构 确定实现的各种关键性要素和实现手段 归结目标到最适合的计算体系 ","date":"2021-09-14","objectID":"https://blog.gethin.online/system-plan/:3:0","tags":["软件工程","系统架构师"],"title":"系统计划","uri":"https://blog.gethin.online/system-plan/"},{"categories":["软件工程"],"content":"新旧系统的分析和对比 ","date":"2021-09-14","objectID":"https://blog.gethin.online/system-plan/:4:0","tags":["软件工程","系统架构师"],"title":"系统计划","uri":"https://blog.gethin.online/system-plan/"},{"categories":["软件工程"],"content":"遗留系统的评价方法 启动评价 遗留系统是否至关重要 企业的商业目标是什么 演化需求是什么 所期望的系统寿命多长 系统使用期限多久 系统技术状态如何 企业是否愿意改变 企业是否有能力承受演化 商业价值评价 咨询 评价问卷 进行评价 外部环境评价 硬件 支撑软件 企业基础设施 应用软件评价 系统级 部件级 分析评价结果 ","date":"2021-09-14","objectID":"https://blog.gethin.online/system-plan/:4:1","tags":["软件工程","系统架构师"],"title":"系统计划","uri":"https://blog.gethin.online/system-plan/"},{"categories":["软件工程"],"content":"遗留系统的演化策略 淘汰策略 继承策略 改造策略 集成策略 ","date":"2021-09-14","objectID":"https://blog.gethin.online/system-plan/:4:2","tags":["软件工程","系统架构师"],"title":"系统计划","uri":"https://blog.gethin.online/system-plan/"},{"categories":["数据与算法"],"content":" https://github.com/Gethin1990/leetcode_101 算法思想 分治 贪心算法 理论基础 简单题目 序列问题 股票 两个维度权衡问题 区间问题 其他问题 动态规划 基础题目 背包问题 01背包 完全背包 多重背包 打家劫舍 股票问题 子序列问题 不连续子序列 连续子序列 编辑距离 回文 回溯算法 组合 分割 子集 排列 棋盘问题 其他 深度优先 分支界限法 广度优先 二分查找 排序 冒泡排序 选择排序 插入排序 归并排序 堆排序 双指针 数学问题 位运算 算法思想 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:0:0","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"分治 为运算表达式设计优先级|241| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:1:0","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"贪心算法 分发饼干|455| 分发糖果|135| 五重叠区间|435| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:2:0","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"理论基础 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:2:1","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"简单题目 分发饼干|455| K次取反后最大化的数组和|1005| 柠檬水找零|860| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:2:2","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"序列问题 摆动序列|376| 单调递增的数字|738| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:2:3","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"股票 买卖股票的最佳时机|122| 买卖股票的最佳时机含手续费|714| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:2:4","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"两个维度权衡问题 分发糖果|135| 根据身高重建队列|406| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:2:5","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"区间问题 跳跃游戏|55| 跳跃游戏2|45| 用最少数量的箭引爆气球|452| 五重叠区间|435| 划分字母区间|763| 合并区间|56| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:2:6","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"其他问题 最大子序和|53| 加油站|134| 监控二叉树|968| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:2:7","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"动态规划 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:3:0","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"基础题目 斐波那契数|509| 爬楼梯|70| 适用最小花费爬楼梯|746| 不同路径|62| 不同路径2|63| 整数拆分|343| 不同的二叉搜索树|96| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:3:1","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"背包问题 01背包 分割等和子集|416| 最后一块石头的重量2|1049 目标和|494| 一和零|474| 完全背包 零钱兑换2|518| 组合总和5|377| 爬楼梯|70| 零钱兑换|322| 完全平方数|279| 单词拆分|139| 多重背包 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:3:2","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"打家劫舍 打家劫舍|198| 打家劫舍2|213| 打家劫舍3|337| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:3:3","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"股票问题 买卖股票的最佳时机|121| 买卖股票的最佳时机|122| 买卖股票的最佳时机|123| 买卖股票的最佳时机|188| 最佳买卖股票时机含冷冻期|309 最佳买卖股票时机含手续费|714| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:3:4","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"子序列问题 不连续子序列 最长上升子序列|300| 最长公共子序列|1143| 不相交的线|1035| 连续子序列 最长连续递增序列|674| 最长重复子数组|718| 最大子序和|53| 编辑距离 判断子序列|392| 不同子序列|115| 两个字符串的删除操作|583| 编辑距离|72| 回文 回文字串|647| 最长回文子序列|516| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:3:5","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"回溯算法 全排列|46| 组合|77| 单词搜索|79| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:4:0","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"组合 组合|77| 电话号码的字母组合|17| 组合总和|39| 组合总和2|40| 组合总和3|216| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:4:1","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"分割 分割回文串|131| 复原IP地址|93| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:4:2","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"子集 子集|78| 子集2|90| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:4:3","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"排列 全排列|46| 全排列2|47| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:4:4","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"棋盘问题 N皇后|51| 解数独|37| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:4:5","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"其他 递增子序列|491| 重新安排行程|332| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:4:6","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"深度优先 岛屿的最大面积|695| 省份数量|547| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:4:7","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"分支界限法 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:5:0","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"广度优先 最短的桥|934| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:5:1","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"二分查找 Sqrt(x)|69| Find First and Last Position of Element in Sorted Array|34| Search in Rotated Sorted Array II|81| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:6:0","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"排序 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:7:0","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"冒泡排序 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:7:1","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"选择排序 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:7:2","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"插入排序 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:7:3","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"归并排序 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:7:4","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"堆排序 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:7:5","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"双指针 Two Sum II - Input array is sorted|167| Merge Sorted Array |88| Linked List Cycle II|142| MinimumWindow Substring|76| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:8:0","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"数学问题 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:9:0","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":"位运算 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-thinking/:10:0","tags":["算法"],"title":"算法-思想","uri":"https://blog.gethin.online/algorithm-thinking/"},{"categories":["数据与算法"],"content":" https://github.com/Gethin1990/leetcode_101 数据结构 数组 二分查找 双指针 滑动窗口 链表 链表的理论 链表的种类 链表的存储方式 链表操作 数组和链表在不同场景下的性能分析 链表的经典题目 虚拟头节点(哨兵节点) 链表的基本操作 反转链表 环形链表 哈希表 哈希表介绍 哈希函数 哈希碰撞 常见的三种哈希结构 数组作为哈希表 set作为哈希表 map作为哈希表 字符串 什么是字符串 要不要使用库函数 双指针法、反转系列 KMP 栈和队列 栈与队列的理论基础 栈经典题目 栈在系统中的应用 括号匹配问题 字符串去重问题 逆波兰表达式问题 队列的经典题目 滑动窗口最大值问题 求前 K 个高频元素 二叉树 二叉树的遍历方式 二叉树的属性 二叉树的修改与构造 求二叉搜索树的属性 二叉树公共祖先问题 二叉搜索树的修改和构造 图 数据结构 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:0:0","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"数组 找到所有数组中消失的数字|448| 旋转图像|48| 搜索二维矩阵 II|240| 最多能完成排序的块|769| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:1:0","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"二分查找 搜索插入位置|35| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:1:1","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"双指针 移除元素|27| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:1:2","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"滑动窗口 长度最小的子数组|209| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:1:3","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"链表 反转链表|206| 合并两个有序链表|21| 两两交换链表中的节点|24| 相交链表|160| 回文链表|234| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:2:0","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"链表的理论 链表的种类 单链表、双链表、循环链表 链表的存储方式 数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 链表操作 添加、删除、查询 数组和链表在不同场景下的性能分析 插入删除的时间复杂度是O(1),查询的时间复杂度是O(n) ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:2:1","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"链表的经典题目 虚拟头节点(哨兵节点) 移除链表元素|203| 链表的基本操作 设计链表|707| 反转链表 反转链表|206| 环形链表 环形链表II|142| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:2:2","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"哈希表 哈希表 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:3:0","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"哈希表介绍 哈希表是根据关键码的值而直接进行访问的数据结构。 哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:3:1","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"哈希函数 通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把value映射为哈希表上的索引数字了。 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:3:2","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"哈希碰撞 拉链法、线性探测法。 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:3:3","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"常见的三种哈希结构 数组、set（集合）、map（映射） 数组作为哈希表 有效的字母异位词|242| 赎金信|383| set作为哈希表 两个数组的交集|349| map作为哈希表 两数之和|1| 三数之和|15| 四数之和|18| 四数相加II|454| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:3:4","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"字符串 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:4:0","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"什么是字符串 字符串是若干字符组成的有限序列，也可以理解为是一个字符数组 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:4:1","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"要不要使用库函数 反转字符串|344| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:4:2","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"双指针法、反转系列 反转字符串II|541| 剑指Offer 05.替换空格 翻转字符串里的单词|151| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:4:3","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"KMP 实现 strStr()|28| 重复的子字符串|459| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:4:4","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"栈和队列 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:5:0","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"栈与队列的理论基础 队列是先进先出，栈是先进后出 ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:5:1","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"栈经典题目 栈在系统中的应用 简化路径|71| 括号匹配问题 有效的括号|20| 字符串去重问题 删除字符串中的所有相邻重复项|1047| 逆波兰表达式问题 逆波兰表达式求值|150| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:5:2","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"队列的经典题目 滑动窗口最大值问题 滑动窗口最大值|239| 求前 K 个高频元素 前 K 个高频元素|347| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:5:3","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"二叉树 平衡二叉树|110| 二叉树的直径|543| 路径总和 III|437| 对称二叉树|101| 删点成林|1110| 二叉树的层平均值|637| 从前序与中序遍历序列构造二叉树|105| 二叉树的前序遍历|114| 恢复二叉搜索树|99| 修剪二叉搜索树|669| 实现 Trie (前缀树)|208| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:6:0","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"二叉树的遍历方式 前序遍历|144| 中序遍历|145| 后序遍历|94| 层级遍历|102| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:6:1","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"二叉树的属性 对称二叉树|101| 二叉树最大深度|104| 二叉树最小深度|111| 完全二叉树的节点个数|222| 平衡二叉树|110| 二叉树的所有路径|157| 左叶子之和|404| 找树左下角的值|513| 路径总和|112| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:6:2","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"二叉树的修改与构造 翻转二叉树|226| 从中序与后续遍历序列构造二叉树|106| 最大二叉树|654| 合并二叉树|617| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:6:3","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"求二叉搜索树的属性 二叉搜索树中的搜索|700| 验证二叉搜索树|98| 二叉搜索树的最小绝对差|530| 二叉搜索树中的众数|501| 把二叉搜索树转换为累加树|538| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:6:4","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"二叉树公共祖先问题 二叉树的最近公共祖先|236| 二叉搜索树的最近公共祖先|235| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:6:5","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"二叉搜索树的修改和构造 二叉搜索树的插入操作|701| 删除二叉搜索树的节点|450| 修剪二叉搜索树|669| 将有序数组转换为二叉搜索树|108| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:6:6","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["数据与算法"],"content":"图 判断二分图|785| 课程表 II|210| ","date":"2021-09-10","objectID":"https://blog.gethin.online/algorithm-data-structure/:7:0","tags":["算法"],"title":"算法-数据结构","uri":"https://blog.gethin.online/algorithm-data-structure/"},{"categories":["语言与平台"],"content":"business office job hunting recruitment applicant admission personnel information recruitment treatment specialty recommendation graduate administrative resume advertisement vacancy credential attachment education interview experience candidate strength achievement hire trade agriculture forestry fishery manufacturing communication occupation boss businessman lawyer designer editor position appointment qualification accountant interpersonal competent self-introduction nationality region major height health reasons for application prospect responsibility experience position objective corporate information establish asset reputation system outlook work experience field interpret well-trained negotiation accomplish salary annually bonus payroll contribution insurance temper character personality extroverted introverted attitude development technology direction explore analogy innovate ","date":"2021-09-03","objectID":"https://blog.gethin.online/office-english-words/:1:0","tags":["english"],"title":"职场英语词汇","uri":"https://blog.gethin.online/office-english-words/"},{"categories":["语言与平台"],"content":"business affairs report for work report newcomer introduce procedure assign office clerk team task accomplish rule induction training intensive orientation take part in improvement course business attire image impression professional ceremony garment network security firewall network server broadband password website webpage webmaster advertisement login pop up work like a horse workaholic embark initiative schedule arrange office hours absence shift punch commute overtime office table desktop keyboard calculator folder desk calendar computer configuration computer memory video card system driver version computer operation crash shutdown software administrator install filling document alphabetically methodically classify index relevant document actions rename compress download copy delete fax dial transmission confirmation scanner format E-mail receive attach compose material expand the market target survey demand develop promote sales strategy effective advantage strategy display potential financial budget budget expenditure balance accurate amend departmental meeting negotiation proposal teleconference host discuss office meeting presentation slide notice multimedia auditorium ","date":"2021-09-03","objectID":"https://blog.gethin.online/office-english-words/:2:0","tags":["english"],"title":"职场英语词汇","uri":"https://blog.gethin.online/office-english-words/"},{"categories":["语言与平台"],"content":"workplace management income invest account consume charge report speech subject start encourage commend job performance rival compliment project arrange fulfillment labour contract valid signature clause responsibility terminate transferring jobs promotion resign opportunity expiry headhunter being late attendance traffic punctual excuse oversleep work overtime workload initiative urgent substitute shorten promotion deserve demand gross increase approach compete contend compare conflict estimate confront layoff downsize compensation economic dismiss redundant pressure stress sleepless concern relieve rest vacation approve coordinate maternity leave marriage leave casual leave job morale mood pressure complaint futureless environment relation respect correlate compatible desire discriminate business trip reservation hotel expense attend restaurant travel expense reimbursement receipt expense reimburse itinerary policy year-end bonus motivate evaluate cohesion amount performance establish a business venture finance profit investor willpower ","date":"2021-09-03","objectID":"https://blog.gethin.online/office-english-words/:3:0","tags":["english"],"title":"职场英语词汇","uri":"https://blog.gethin.online/office-english-words/"},{"categories":["语言与平台"],"content":"interpersonal relationship organization headquarters committee league meeting president law legislation agreement rob jail release greet congratulation console condition visit comprehend office culture gossip competitor supervisor promotion office romance company position shareholder secretary salesman assistant manager business negotiation negotiate contract cooperate commission bargain telephone introduce fax dial message familiar office supplies notebook stapler file document cabinet computer communicating with colleagues communicate fussy obstacle debate fireball working clearance coffee relax chitchat tearoom snack drinking room microwave lunchbox refrigerator water dispenser instant coffee coworker gathering atmosphere champagne invitation entertain gown dining invite treat generous cook kitchen gym exercise weight training sport strength ","date":"2021-09-03","objectID":"https://blog.gethin.online/office-english-words/:4:0","tags":["english"],"title":"职场英语词汇","uri":"https://blog.gethin.online/office-english-words/"},{"categories":["语言与平台"],"content":"考研词汇800句 - Part 1 ","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-1/:1:0","tags":["english"],"title":"考研词汇800句-1","uri":"https://blog.gethin.online/postgraduate-words-1/"},{"categories":["语言与平台"],"content":"800 句（第一天） With my own ears I clearly heard the heart beat of the nuclear bomb. 我亲耳清楚地听到原子弹的心脏的跳动。 Next year the bearded bear will bear a dear baby in the rear. 明年 长胡子的熊将在后方产一头可爱的小崽 Early I searched through the earth for earthenware so as to research in earthquake. 早先我在泥土中搜寻陶器以研究地震 I learn that learned earnest men earn much by learning. 我得知有学问而认真的人 学问挣很多钱 She swears to wear the pearls that appear to be pears. 她发誓要戴那些看起来像梨子的珍珠。 I nearly fear to tear the tearful girl’s test paper. 我几乎害怕撕那个泪流满面的女孩的试卷 The bold folk fold up the gold and hold it in hand. 大胆的人们将黄金折叠起来拿在手里。 The customers are accustomed to the disgusting custom. 顾客们习惯了令人讨厌的风俗 The dust in the industrial zone frustrated the industrious man. 工业区里的灰尘 使勤勉的人灰心 The just budget judge just justifies the adjustment of justice. 公正的预算法官只不过为司法调整辩护而已。 I used to abuse the unusual usage, but now I’m not used to doing so. 我过去常滥用这个不寻常的用法 但我现在不习惯这样做。 The lace placed in the palace is replaced first, and displaced later. 放在皇宫的带子先被替换，后来被转移。 I paced in the peaceful spacecraft. 我在宁静的宇宙飞船里踱步 Sir, your bird stirred my girlfriend’s birthday party. 先生 你的鸟搅了我女友的生日聚会。 The waterproof material is suitable for the aerial used near the waterfall. 这种耐水材料适合用在瀑布附近的天线 I hint that the faint saint painted the printer with a pint of paint. 我暗示说虚弱的圣徒用了一品脱油漆涂印刷机 At any rate, the separation ratio is accurate. 无论如何 这个分离比是精确的 The boundary around the round ground separates us from the surroundings. 围绕着圆形场地的边界将我们同四周隔开 The blunder made the underground instrument undergo an undermining of the thunderbolt. 这个失策让地下仪器经受了一次雷电的破坏。 The tilted salt filters halt alternately for altering. 倾斜的盐过滤器交替地停下以便改造 The wandering band abandoned d her bandaged husband on Swan Island. 流浪的乐队把她那位打着绷带的丈夫遗弃在天鹅岛上 The manly Roman woman manager by the banner had man’s manner. 军旗旁那位有男子气概的古罗马女经理具有男子风度 In the lane the planer saw a planet airplane under the crane. 在巷道里 刨工看见了起重机下的行星飞机 The wet pet in the net has not got on the jet plane yet. 网中的湿宠物还没有登上喷气飞机 After maintenance the main remains and remainders are left on the domain. 维修之后 主要遗骸和剩余物留在了领地上 The grandson branded the brandy randomly. 孙子给白兰地随机地打上烙印。 The landlord’s land on the highland of the mainland expanded a lot. 地主在大陆高原上的土地扩张了很多 Utilize the fertilizer to keep the land fertile. 利用化肥保持土地肥沃 The grand commander demands thousands of sandy sandwiches. 大司令官要成千个沙色三明治。 I infer that he is indifferent to differentiating the offers in different conferences. 我推断他对区分不同会谈中的报价漠不关心 The maximum plus or minus the minimum makes minute difference. 最大值加上或者减去最小值只产生极小的差异 The witty witness withdraws his words within minutes without any reason. 诙谐的证人在几分钟之 内无故地收回了他说的话 The cake maker shakes a naked snake with the quaking rake without sake. 蛋糕制造者无缘无故地用抖动的耙子摇一条赤裸的蛇 By the crook, the cook looked through a cookbook before making hooked cookies. 在溪边，厨子在做钩形饼干之前查阅了一本食谱。 The writer writes the white book quite quietly in quilt. 作家在被子里十分平静地写白皮书。 On the chilly hillside, he is unwilling to write his will on the ten shilling bill. 在寒冷的山坡上 他不愿意将遗嘱写在十先令的账单上 The weaver will leave for the heavy heaven. 那位纺织工将要到阴沉的天国里去 The handy lefty left a handsome handkerchief on the handle of the handbag. 手巧的左撇子把一方漂亮手帕留在手提包的提手上。 The thief chief achieved the theft of a handkerchief for mischief. 贼首领完成了偷手帕的恶作剧 I believe my brief words will relieve her grief. 我相信我简短的话会减轻她的悲痛 At the dock I’m shocked to see the pocket rocket made of a block of rock. 在码头看到一块岩石做的小巧火箭 我感到震惊 Standing under the outstanding rock I misunderstood his standard standpoint. 站在突出的岩石下 我误解了他的标准立场。 The substantial part of the constitution about the institution of institutes is substituted. 宪法中有关设立协会的实质性部分被替换 Spell smell! Very well, the well being for human being will swell. 拼写气味 一词 很好 人类的福利将会膨胀 Once none of you is here, the man in throne will live alone in the lonely zone. 一旦你们没有人在此 王位上的 人就要孤独地生活在这个孤寂的地带。 Nowadays the once unknown snowy hill is well known for snowstorm. 如今那座曾经不出名的多雪小山因暴风雪而出名 For instance, I can instantly know the constant distance. 例如 我可以即刻知道该恒定距离。 The man beyond the bo","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-1/:1:1","tags":["english"],"title":"考研词汇800句-1","uri":"https://blog.gethin.online/postgraduate-words-1/"},{"categories":["语言与平台"],"content":"800 句（第二天） He repeatedly repeats, “Eat meat.\" 他再三重复说 吃肉 Having canceled X ray scan, the cancerous candidate on the canvas ate the idle candles in the candy can. 取消 X 线扫描后，帆布上的癌症候选人吃了糖果罐里的闲置蜡烛。 Th e dominant candidate is nominally nominated for president. 占优势的候选人名义上被任命为总统 The extravagant savage made the interior and exterior criteria of deterioration. 奢侈的野蛮人制定了腐败的内外标准 No, nobody’s body is noble, nor is his. 不 没有任何人的躯体是高贵的 他的也不是 Axe the tax on taxis. Wax may relax the body. 削减出租车的税费。蜂蜡可以使身体放松 The man in mask asked me for a task; I let him put the basket on the desk in the dusk. 戴面具的人向我要任务 我让他在黄昏时把篮子放到桌子上 The lump jumped off the pump and bumped on the trumpet in the dump. 傻大个跳下水泵撞到垃圾堆里的喇叭上。 On my request the conqueror questioned the man who jumped the queue. 根据我的请求 征服者质问了插队者 They are arguing about the document of the monumental instrument. 他们在辩论关于那件不朽乐器的文献 However, Lever never fevers; nevertheless, he is clever forever. 无论如何 杠杆从未发烧 尽管如此 他始终机灵。 I never mind your unkind reminding that my grindstone hinders your cylinder. 我决不介意你不友善的提醒说我的磨刀石妨碍了你的汽缸。 I feed the food to the bleeding man in the flood. 我把食品喂给洪水中的那个流血的人 It’s a treason terror of the seasonal oversea seafood is reasonable. 认为季节性的海外海鲜的价格是合理的就是背叛。 The veteran in velvet found that the diameter of the thermometer was one meter. 穿天鹅绒的老兵发现温度计的直径为一米 The cube in the tubular cup occupies one cubic meter. 筒状杯中的立方体占有一个立方米 的 体积 Put the spotless potatoes, tomatoes and tobacco atoms into the hot pot. 把无斑点的土豆、番茄和烟草微粒放进热锅里。 The preacher preached to the teacher’s teacup. 传教士对着老师的茶杯说教 “My behavior is on behalf of half zebras,” the algebra teacher said. 我的行为代表了一 半斑马的利益 代数老师说 Unlike my uncle, I likely like that bike (bicycle). 我不象叔叔 我很可能喜欢那辆自行车 She likes nothing but things of clothing and cloth. 除了衣物和布料之类的东西外 她什么也不喜欢 The doctor’s doctrine undid one dollar and a dozen of collars. 博士的学说毁掉了一美元和一打 衣领。 On the bus the busy businessman did a business with the buyer. 在公共汽车上 忙碌的商人与买主做了一笔生意 Vegetables and tablets on the stably established table show no instability. 放在稳定设置的桌子上的蔬菜和药片没有显示不稳定性。 Primarily, the prime criminal’s crime has nothing to do with lime and overtime. 首犯的犯罪基本上与石灰和加班无关 The ring on the spring string rings during springtime. 弹簧弦上的环在春天鸣响。 Shut in the hut, I’m puzzled how to cut down the output of nuts. 关在茅棚里 我为削减坚果的产量犯难。 It’s better to put letters at the inlet and outlet. 最好在进口和出口处标上字母 During this serious period, the superiors asked the inferiors a series of questions about the supermarket. 在这段严肃时间内 上级问了下级一连串有关超级市场的问题。 I tuned the tone of the stone phone with a bone. 我用骨头调整了石质耳机的音调 On Revenue avenue, the grave traveler jumped the gravestone bravely. 在税收大道上 严肃的旅行者勇敢地跳过墓碑 The slave safely saved the sharp shavers in a cave nearby the cafeteria. 奴隶将锋利的剃刀安全地保存在自助餐厅附近的洞穴里 Most hosts are hostile to the foremost ghost hostage almost to the utmost. 大多数主人对 最前面的幽灵人质的敌对态度几乎到了极顶 The mapper trapped in the gap tapped the tap wrapper with strap. 陷在缝中的制图者用皮带轻击塞子套 The scout with shoulder straps shouted on the outermost route as a routine. 戴肩章的侦察员照例在最外围的路线上叫喊 The reproached coach unloaded the loaves to the approachable roadside. 遭到责备的教练把面包卸到可接近的路旁 The news about the broadened breadth is broadcast abroad. 宽度加宽的消息被广播到国外 The motive of the emotional movie is to move the removed men. 那部情感电影的动机在于感动被开除的人。 Otherwise, mother will go to another movie together with brother. 不然 妈妈就和弟弟一起去看另一场电影。 Furthermore, we gathered leather and feather for the future colder weather. 而且 我们收集了皮革和羽毛以应付将来更冷的天气。 Before the premier, the old soldier scolds the cold weather. 老兵当着首相的面咒骂寒冷的天气。 Whether the weather is good or bad, neither father nor I am going to the gathering. 无论天气是好是坏 父亲和我都不去参加那个聚会。 The Particle party’s partner participated in the particular Parliament. 粒子党的合伙人参与了特别议会 For convenience of intensive study, he has an intense intention of making friend with me. 为便于强化学习，他有和我交朋友的强烈意向。 The virtueless girl’s duty is to wash the dirty shirts and skirts in the outskirts. 无美德女孩的职责就是在郊区洗脏衬衣和裙子 I glimpsed the dancer balancing herself on the","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-1/:1:2","tags":["english"],"title":"考研词汇800句-1","uri":"https://blog.gethin.online/postgraduate-words-1/"},{"categories":["语言与平台"],"content":"800 句（第三天） The tall man installed a small wallet on the wall. 高个男子把一小钱包安放到墙上 Except dishonest ones, anyone who is honest can get honey, everyone thinks so. 除了不诚实的人外 任何诚实的人都能得到蜂蜜 人人都这么想。 The exhausted man and the trustful guy thrust a knife into the rusty crust. 精疲力竭的男子和深信不疑的家伙将一把刀子刺向生锈的外壳。 I finally find that the financial findings are binding. 我终于发现财经调查结果具有约束力。 At the windy window, the widow finds a blind snake winding. 在当风的窗口 寡妇发现有条瞎眼蛇在游动。 I refuse to accuse Fuse of diffusing confusion. 我拒绝控告导火索散播混乱。 He had an amusing excuse for executing the executive. 对于处 决决策人 他有一个可笑的理由 At the dawn on the lawn the yawning drowned man began to frown. 拂晓时在草坪上，打呵欠的溺水者开始皱眉头 Mr. Brown owns the brown towels in the downtown tower. 布朗先生拥有闹市区塔里的棕色毛巾。 Lots of pilots plot to dot the rotten robot. 大批领航员策划给腐烂的机器人打点 In the hot hotel the devoted voter did not notice the noticeable notebook. 在炎热的旅馆里 热心的投票者没有注意到显而易见的笔记本。 The notorious man’s noted notation denotes a notable secret. 那个臭名昭著的男子的著名符号代表一个值得关注的秘密 Yes, yesterday was the my pay day; I pay you the payment today. 是的 昨天是我的发薪日 我今天付给你报酬 Lay a layer of clay on the displayed layout before the relay race. 接力赛之前在展示的陈设上铺一层黏土 “The gay mayor maybe lay in the hay by the Baby bay,” he says in dismay. 他沮丧地说 快活的市长大概躺在婴儿湾边上的干草中。 The delayed player delegation stay on the playground. 被耽搁的运动员代表团停留在操场上。 The X rayed prayer preyed a gray tray. 照过 X 光的祈祷者捕获了一个灰色盘子。 Anyway, the prayer swayed by me always goes away by subway. 不管怎样 受我支配的祈祷者总是从地铁走向远方。 The chocolates on the plate stimulated my son to calculate. 盘子里的巧克力鼓励了儿子进行计算 One of my relatives, a late translator, translated a book relating to public relations. 我的一位亲戚 一个已故翻译 翻译了一本有关公共关系的书。 He relates that he is isolated from his relatives. 他叙述说他与亲戚们隔离开了 The educator located the local location allocated to him. 教育家定出了分配给他的局部的位置 Comply with the compatible rule of complement when using compliments. 使用问候语时遵守补语的相容规则 The complicated indicator is dedicated to the delicate delicious machine. 这个复 杂的指示器被奉献给精密而美妙的机器 Likewise, my bike gave a striking strike to the two men alike. 同样 我的自行车给那两个相象的人惊人的打击 The smoke choked the joking stroker at one stroke. 烟一下呛住了开玩笑的抚摩者 Somewhere somebody sometimes does something good. 在某处某人有时做某些好事。 Wherever I go, nowhere I like; I dislike everywhere. 无论我到哪里 没有哪里为我喜欢 我讨厌每一个地方 Therefore, the atmosphere is merely a sphere. 因此大气层只不过是一个球体。 The funny cunning runner uses his gum gun before sunrise or after sunset. 滑稽乖巧的赛跑者在日出之前或日落之后使用胶 皮枪。 The applause paused because of the cause caused by a cautious plausible clause. 掌声停了是因为一条谨慎的似乎有理的条款引起的原因。 The county councilor encountered the accountant at the counter of a countryside shop. 县委委员在一乡村商店的柜台边碰到了会计师。 I mounted the mountain and found a fountain with large amount of water. 我登上那座山发现一个水量很大的喷泉。 Step by step, the sleepy creeper crawled into my sleeve to sleep. 昏昏欲睡的爬虫一步一步爬进我的袖子里睡觉 After a deep sleep, the weeping sweeper keeps on peeping the sheep on the steep. 酣睡之后 哭泣的清扫者继续窥视峭壁上的羊。 The vice adviser advised the reviser to devise a device for getting rid of vice. 代理顾问建议校订者想出一个根除恶习的计策 The wise man used his wisdom in the vertical advertisement device. 聪明人把智慧用在垂直的 广告装置上。 With rhythm, the arithmetic teacher put the artist’s artificial articles on the vehicle. 算术老师把艺术家的人造物品有节奏地放到运载工具里 The smart star starts to make cart chart for the commencement. 精明的明星开始制作授学位典礼用的马车图表。 The lady is glad to give the salad to the sad lad on the ladder. 女士乐意把色拉送给梯子上的那位悲哀的小伙子 You mad madam, my dad does not like the bad badminton pad. 你这个疯太太 我爸爸不喜欢这种坏羽毛球垫 The one legged beggar begins to beg eggs illegally. 独腿乞丐开始非法讨蛋。 The promoter promptly made a quotation for the remote control motors. 发起人立刻制了一份遥控马达的报价单。 Each pea and peach on the beach can be reached by the peacock. 海滩上的每一颗豌豆和桃子孔雀都能触及 Although the plan was thorough, it was not carried through. 尽管计划很周详，但是没有得到贯彻。 Thoughtful men ought not to be thoughtless about the drought. 体贴的人不应该对干旱考虑不周。 “Rough cough is tough enough,” Bough said while touching the torch. “剧烈咳嗽是够难以对付的 ,,”大树枝在触摸手电筒时说道 The football team","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-1/:1:3","tags":["english"],"title":"考研词汇800句-1","uri":"https://blog.gethin.online/postgraduate-words-1/"},{"categories":["语言与平台"],"content":"800 句（第四天） The spy is shy of taking shelter on the shelf of the shell like shed. 间谍怕在壳子一样的棚里的架子上栖身。 The optional helicopter is adopted to help the optimistic helpless in the hell. 可选用的直升飞机被用来帮助地狱里那些乐观的无助者 The cell seller seldom sees the bell belt melt. 小单间的卖主很少见到铃铛带子融化。 The costly post was postponed because of the frost. 那件昂贵的邮件由于霜的缘故而延搁。 Strain brain on the train is restrained. 在列车上过度用脑受到约束 The gained grain drained away with the rain, all the pains were in vain again. 收获的谷物随雨水流失了 所有辛劳又白费 Cousin saw a group of couples in cloaks soak their souls in the soapy soup. 表哥看见一群穿着斗篷的夫妇在肥皂汤里浸泡灵魂 The wounded founder bought a pound of compound. 受伤的奠基人买了一磅化合物 It’s easy and feasible to control the disease after cease fire. 停火之后控制这种病很容易也可行。 After a decrease, the price of the grease increases increasingly. 下跌过一次之后，润滑脂的价格日益上涨。 Please re lease that pleasant peasant teaser who brings us plenty of pleasure. 请释放那个带给我们巨大快乐的友好的农民逗趣者。 In the canal, the Canadian analyzed the bananas. 在运河里 那个加拿大人化验了香蕉 I pointed out the joint on the coin at the disappointing appointment. 在令人失望的约会上 我 指出了硬币上的接头 His parents apparently stare at the transparent cigarettes. 他父母显然凝视着透明香烟 The careful man is scarcely scared by the scarce parcel. 细心男子勉强被罕见的包裹吓了一下 I’m rarely aware that the square area is bare. 我很少觉察到那个正方形区域是光秃秃的 “Beware the software in the warehouse during the warfare,” hare said glaring at me. 兔子怒视着我说：“战争期间当心仓库里的软件。” I dare not declare that the shares are my spare fare and welfare on the farewell party. 在告别会上 我不敢宣称这些股票是我的备用车费和福利。 The external and intern al interference interrupts my interpretation at short intervals. 内部和外部干涉以很短的间隔打扰我翻译 The form of the former formula is formally formulated. 前一个分子式的形式得到正式表述 The performer reformed the performance of the transferred transformer. 表演者改良了转让的变压器的 性能 Normally, enormous deformation is abnormal. 通常，巨大的变形是不正常的。 The bookworm in uniform is informed of the storm. 穿制服的书呆子得到暴风雨的消息。 The story about the six storeyed dormitory tells a glorious history. 关于六层楼宿舍的故事讲述一段光荣历史。 The perfume consumer presumably assumes that the volume is resumed. 香水消费者假定地设想音量已恢复 The voluntary revolutionaries revolted like the outbreak of volcano. 志愿革命者们象火山爆发一样起义了 It’s resolved by resolution that the solution will be used to solve the involved problem. 决议决定用这个办法解决那个复杂的问题。 The generous general’s genuine genius is in making generators. 那位慷慨将军的真正天才在于制造发电机 Several severe federal generals drank the mineral water on the miner’s funeral. 好几个严厉的联邦将军在矿工的葬礼上喝了矿泉水。 The lean man leans on the clean bean plant to read a leaf leaflet. 瘦人斜 在干净的豆科植物上读叶片传单 I mean he used mean means in the meantime on the ocean. 我的意思是其间在海洋上他用了卑鄙手法 The honour-able journalist spent an hour on the journey of tour. 可敬的新闻记者在观光旅程上花了一个小时 The s our vapour pours into the flourishing flour factory. It’s the source of resources. 酸蒸汽涌进兴旺的面粉厂 这是资源的源泉 Of course the man’s courage encouraged the discouraged tourists in the courtyard. 自然那个勇敢男子的勇气鼓舞了院子里泄气的游客们。 The zealous dealer has an ideal idea of dealing with the meal. 热心的商人有一个处理膳食的理想主意 He conceals the fact that he is jealous of my seal and wants to steal it. 他隐瞒了他嫉妒我的印章并想偷的事实 I really realized that a realm came into reality. 我真地认识到一个王国已变成现实 The healer reveals an ap pealing fact that health is great wealth to the commonwealth. 医治者揭示一个吸引人的事实 健康是联邦的巨大财富。 The absent minded student consents to the sentence in the presence of me. 心不在焉的学生在我面前同意这份判决 Presently the present is presented to the representative. 现在 这份礼物已呈现在代表面前。 Not for a moment has the comment on commercial phenomenon been mentioned. 那个关于商业现象的评论从未被提及过。 The mental patient thinks the cement is the elementary element of the ornament. 精神病人认为水泥是装饰品的基本成分 As an exception I accept all h is concepts and conceptions except one. 作为例外 我接受他所有的概念和构想 只有一个除外。 I perceived that the veil clung on the ceiling of the clinic was deceit. 我觉察到粘附在诊所天花板上的幔子是个骗局 The receptionist received a receipt from the receiver. 接待员收到一份来自接收者的收据。 Th e reaper leaped over a heap of cheap weapons. 收割者跃过一堆廉价的武器。 The newly imprisoned prisoners pois","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-1/:1:4","tags":["english"],"title":"考研词汇800句-1","uri":"https://blog.gethin.online/postgraduate-words-1/"},{"categories":["语言与平台"],"content":"考研词汇800句 - Part 2 ","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-2/:1:0","tags":["english"],"title":"考研词汇800句-2","uri":"https://blog.gethin.online/postgraduate-words-2/"},{"categories":["语言与平台"],"content":"800 句（第五天） The loser closely enclosed himself in the closet. 失败者将自己严密 地装入壁橱（储藏间）中。 The composer was proposed to decompose his composition into components. 大家建议作曲家（作家）将自己的作品分解为多个部分 Suppose you were exposed in the opposite position by your opponent, … 假设你的对手把你暴露于对立（对等 相反）的位置上 The depositor positively positioned the preposition in that position on purpose. 存款人断然地将介词故意放置到那个位置上 In church the nurse cursed the people pursuing the purple purse. 在教堂内，护士诅咒大家追赶（追踪 追求）那个紫色钱包 The faculty for agricultural culture isn’t difficult to cultivate. 农业文化的能力（才能 ）不难培养 The reservoir in the reserved preserve is an obstacle to the obstinate observer. 在保留的保护区（禁区）内的水库对那个顽固的观察员来说是个障碍。 The desert deserves the nervous servants to observe. 这个沙漠值得那个不安的仆人观察（观测）。 The bulk of the ruby rubbish on the pebble bubbles when stirred by bulbed rubber club. 当用一个球状的橡皮棍（棒）搅动时，在小鹅卵石上的红宝石垃圾的体积会起泡。 The adjective injected new meaning into the objected objective object. 这个形容词为相反的客观物体（目标）注入了新的含义。 The projector is subject to rejection and may be ejected from the project. 设计者（还有放映机之意）招到了拒绝而且还有可能被驱逐出这个计划。 A day goes through daybreak, morning, noon, afternoon, evening and midnight. 一天经过了黎明、早晨、中午、下午、晚上和午夜。 His affection for the defects is affected by the infectious perfect effect. 他对这个缺点的感情受到了那个有感染力的完 美的结果的影响。 The critic’s criticism is critical to the crisis. 批评家的批评对这个危机来说非常危急。 The director’s indirect direction led to the incorrect erection of the rectifier. 主任（导演）的间接的指导导致了校正者的不正确的安装。 The prospective inspector prospected his prospect with his own perspective. 预期的检查员根据自己的看法寻找他的前途（期望）。 Two suspicious aspects are suspected respectively. 两个外貌可疑（的人）分别受到怀疑。 This section about insects is written by a respectable specialist. 关于昆虫的这一章是由一个德高望重的专家写的。 I assure the injured jury that a sure insurance is ensured. 我对受伤的陪审团担保他们保证可以得到一张可 的保险单。 My durable endurance made me endure the injury during insurance. 我持久的忍耐力使我可以忍受保险期间的伤害。 I can’t endure the leisured man’s measures for the treasures in the treasury. 我不能忍受那个从容不迫（ 悠闲）的人对国库内的拆产进行估量。 In the exchange the oranges are arranged into strange ranges. 在这次交易中，桔子被安排到了奇怪的范围之内。 The ashtray, splashed with ash, crashed with a clash in a flash while being washed. 烟灰缸，溅满了灰，在洗它的时候咣的一声在一瞬间坠落了。 He dashed to smash the fashionable ashtray with cash. 他飞跑着去用现金打碎了那个时髦的烟灰缸。 I feel a bit of bitterness for his ambitious exhibition. 对于他的野心勃勃的展示品我感到有一点苦涩。 On the orbit, the rabbits habitually inherited the merits of the inhabitants. 在轨道上，兔子们习惯地遗传（继承）了居民们的优点。 Her rejoicing voice is void of something 她欣喜的声音对于可避免的事情是无用的。 I prefer the preferable preference you referred to in the reference books. 我更喜欢你在参考书中提到的更优越的偏爱（优先选择）。 The specialist specifically specified a special pacific means especially. 专家明确地特别指出了一个特殊的和平方法。 The speculator specifically specified the specification of this species specimen. 投机者明确地将这种标本的规格（说明书）列入清单。 I’m to be punished for publishing his bad reputation to the public of the republic. 我将会因把他的坏名声发布给共和国的公众而受 到惩罚。 The drug trafficker is concerned about the condition of the traditional concert. 这个药品商人很关心传统音乐会的条件。 It’s a fable that the cable enables the disabled man to be able to walk. 电缆能使残疾人走路是一个寓言（神话）。 The problem is that those who are out of jobs probably rob. 问题是那些失去工作的人可能会抢劫。 His wicked trick is to get the kids to kick bricks and lick the cricket ticket. 他的邪恶的诡计是让那些小孩踢砖头和舔板球票。 The thin sick chicken picks the thick sticky stick quickly. 这个又瘦又病的小鸡飞快地挑选又稠又粘的棍子。 The anima ls unanimously vanished from the mammal’s room furnished with Spanish furniture. 动物们毫无疑义地从那个由西班牙家具装备（装饰）的房间消失了。 The loosened goose chooses the cheese to eat. 被松开的鹅选择奶酪吃。 By policy, the police impolitely sliced the politician’s politics books. 根据政策，警察无礼地将政治家的政治书籍切成薄片。 At the neck of the wrecked deck, the reckoner checked the opaque cheque. 在拆毁的甲板的颈部，计算员检查了不透明的支票。 The scholar foolishly took the school cooling pool for swimming pool. 学者愚蠢地将学校的冷却池当成了游泳池。 Having played golf, the wolf in wool rested on the tool stool in the zoo. 打完高尔夫球之后，批着羊皮的狼在动物园的工具凳子上休息。 Citizens in the city’s civil buildings are all ","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-2/:1:1","tags":["english"],"title":"考研词汇800句-2","uri":"https://blog.gethin.online/postgraduate-words-2/"},{"categories":["语言与平台"],"content":"800 句（第六天） The accessory successor never made concessions to difficulties, so he succeeded in accessing successive successes. 附属继承人从未向困难妥协，因此在走向连续的成功之路上 成功了 I exceed the excellent student who has excessive excellence. 我胜过那个有过多优点的优秀学生 During the procession, the microprocessor finished the processing procedure. 在队伍行进时 微处理器完成了加工过程 The chess professor confessed his professional blessing in the confession. 象棋教授在供状中承认了其职业福气 The progressive congressman dressed in black stressed his distress. 穿着黑色衣服的进步国会议员强调了他的不幸 The man depressed by the pressure from the press expressed the impression on him. 那个受到来自新闻界压力压抑的人表达了他的印象 Initially I kept silent to the essential essay. 起初我对这个重要的短评保持沉默。 The enforced law reinforced that forced divorce is forbidden. 实施的法律强化了禁止强迫离婚 In the cork workshop, the workers fork the pork. 在软木车间 工人们用 子 猪肉 That person personally persuaded the personnel with persuasive words. 那个人用有说服力的话亲自说服了人事部门。 The dull bull fully fulfilled pulling the bulletproof bulletin board. 迟钝的公牛充分履行了拖防弹公告牌 的职责 。 The lucky duck tucked in truck suddenly sucked the gas from the bucket. 塞在卡车里的幸运鸭子突然从 桶里吸汽油 Boil the oil soiled by the coil in the toilet lest it spoil. 把被盥洗室里的线圈弄脏的油煮开 免得它变质 The selfish man put himself on the shelf. 那个自私的人把自己束之高阁。 In this climate, the climber climbed up the cliff with his stiff limbs. 在这种气候下 攀登者用僵硬的四 肢爬上悬崖 The puffy staff’s stuffy chests are stuffed with sufficient suffering. 喘气的职员们闷热的胸中填满了足够的痛苦 The member of good memory remembers to commemorate his friend with memorials. 那位记性好的成员记得用纪念品纪念他的朋友。 The room is lumbered with numerous cucumbers. 房间里乱堆着大量黄瓜。 The poet’s toes get out of his shoes. Here heroes are zeros. 诗人的脚趾露出了鞋子。在这里英雄无足轻重。 In the library, arbitrary the librarian wrote the auxiliary diary about military literature. 在图书馆 武断的图书管理员写下了有关军事文学的辅助日记。 The royal destroyer employs lots of loyal employees. 皇家驱逐舰雇佣了很多忠心的雇员 On the voyage, the enjoyable toy brought me joy and annoyance. 在航行中 使人愉快的玩具给我带来快乐和烦恼 Her boyfriend fed a box of oxygen and hydrogen to the ox and fox. 她男朋友给牛和狐狸喂了一盒子氧和氢 The instructor struggled to say, “The structure of the construction led to the destruction.\" 教师挣扎着说 建筑物的构造导致这场毁灭 I debated that the debtor was doubtless in double troubles. 我争论说债务人很可能处在双重困境中。 With a dim triumph, she trims the swimming suit rim at the swimming pool brim. 她带着暗淡的喜悦在泳池边整理泳装的边缘 Twice the twin king wins the winter swinging under the wing of the plane. 孪生国王两次赢得冬季机翼下的荡秋千赛。 Having piled miles of files, the compiler smiled a while at the profile. 堆了几英里长的文件之后 编辑对着侧面笑了一会 By the spoon you’ll soon see the smooth tooth of the moon above the booth. 借助勺子你可以立刻看到电话亭上方月亮的光滑牙齿 She met me in the Fleet Street and greeted me with a sweet smile. 她在舰队街上遇见我 并对我致以甜甜的一笑 The conductor is reluctant to reduce the conductivity of the semiconductor. 导演不情愿降低半导体的导电率 The producer introduced a productive technological product into production. 制造者把一项多产的技术成果引进到生产中 The anxious man is unconscious of my anxiety. 那个不安的人没有觉察到我的忧虑 Previously he was obviously envious of my success. 先前他明显地嫉妒我的成功 I highly appreciate the preceding man’s precious precise exercise. 我高度欣赏前面那个人可贵的精确演练 The miracle mirrors a horrible error made by the terrorists in the terrible territory. 这件奇事反映了恐怖分子在这一可怕地区犯的可怕错误 I hurt my tongue when I hurried to eat cherry and strawberry merrily. 我匆忙快活地吃樱桃和草莓时伤了舌头 The man proclaimed in exclamation that he aimed to reclaim the aimless claim. 那个人呼喊着声明说他打算索回无目标的索赔 In no circumstances can the bicycle in the circle of th e circus be a focus. 马戏表演圈子中的自行车决不会成为焦点 I’m busy unless I’m blessed with less lesson. 我很忙 除非我很幸运只有少量功课 How to pronounce the noun “ounce” in the announcement? 布告中的名词 盎司 怎样发音 It’s incredible that the editor’s editorial in this edition is edible. 本版中的编辑社论可以食用让人难以置信。 The whistler whispered, “Which is rich?\" 鸣笛者低语道 哪一个富有 Which method of making the metal helmet is more economical in total? 生产这种金属头盔的方法哪一种总体上更节约 The diligent teller told a tedious story about the intelligent satellite. 勤奋的出纳讲述了一个关于智能卫星的乏味故事 The soda made the goddess nod by the fishing rod. 苏","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-2/:1:2","tags":["english"],"title":"考研词汇800句-2","uri":"https://blog.gethin.online/postgraduate-words-2/"},{"categories":["语言与平台"],"content":"800 句（第七天） The crying boy tries to fry the dry crystal. 哭喊的男孩试图用油炸干晶体 In the chimney the donkey and monkey found the key to the money monitor. 猴和驴在烟囱里找到了货币监视器的钥匙 At the edge of the wedged hedge, I acknowledged the knowledgeable man. 在楔形篱笆的边缘上 我向那位博识的人致谢 The shark’s remark on the marble mark in the market is remarkable. 骗子关于市场上大理石标记的评论值得关注 In the sparking park, the darling dark dog barked at the embarked larks. 在闪着火花的公园里 可爱的深色狗对着装载于船云雀吠叫 The drifter swiftly shifted the gift to the left of the lift. 那个漂泊者敏捷地将礼物换到电梯的左边 The rival’s arrival gives him a forgivable chance. 对手的到来给他一个可原谅的机会。 From the fact, the shivering driver derives that the diver may thrive on river. 发抖的司机从这个事实得出结论说跳水员可以 河流繁荣 The striver contrives to derive that privacy can’t be deprived. 奋斗者想方设法推导得出隐私 权 不可剥夺 The lively survivor surveyed the conveyer. 活泼的幸存者考察了输送装置 The living olive keeps the deliverer’s liver alive. 活橄榄使发货人的肝脏继续存活 With a knife the knitter ends his wife’s life in the lifeboat. 在救生艇上编织者用小刀结束了他妻子的性命。 Who made a whole hole in the holy holiday? 谁在神圣的假日里打了一个完整的孔 The man who broke the sole solid lid is solemnly condemned. 打破这个仅有的实心盖子的人受到庄严谴责 By the ruler’s schedule, the molecule capsules will play an important role in the roller. 根据统治者的时间表，这种分子胶囊将在滚筒上起重要作用 I deliberately liberated the man who was in despair and desperately struggled for liberation and liberty. 我有意解放了那个拼命地争取解放和自由的绝望者。 At the outset this set of setting settled the offset problem of the kettle. 在开始，这一套设置解决了水壶的弥补问题 I bet that he forgot the forged alphabetical targets. 我打赌他忘记了按字母顺序排列的锻造靶子 The draft for aircraft is sent to the airline by airmail. 订购航空器的汇票用航空邮件寄给了航空公司 On the impaired dairy the chairman lay in a pair of repaired chairs for haircut. 在遭到损害的牛奶场 主席躺在一对修理过的椅子上理发 I met a fairly unfair affair upstairs. 我在楼上遇到一件颇不公平的事 At the breakfast, the steak leaked from the break. 早餐时 肉片从缺口处漏出来。 The weak speaker made a speech on the bleak peak. 虚弱的讲话者在荒凉的山峰上发表了演说。 The mouse’s tearing the blouse and trousers aroused the housewife’s anger. 老鼠撕咬短衫和裤子激起了主妇的怒火。 We beat (defeated) the cheat who heated the wheat. 我们打败了给小麦加热的骗子。 He created the great creature with concrete for recreation. 他用混凝土创造了这个伟大的创造物作消遣 In the theater I threatened to treat the treaty with retreat. 在剧院里 我威胁要以退却来对待条约 The man in neat sweaty sweater seated himself in the rear. 穿整洁的汗湿毛衣的男子在后面就坐 The lagging man tagged the bags among the luggage with small flags. 落伍者给行李中的袋子加上小旗标签 The ragged man drags a wagon of rag fragments. 那个衣衫褴褛的人拉着一货车破布碎片 The lawyer’s son in law likes hawk’s claws and jaws. 律师的女婿喜欢鹰爪和下颌 The drawer put the strawberries and raw paws into a drawer in the saw mill. 绘图者把草莓和生熊掌放进锯板厂的抽屉里。 I had appetite for inviting the man who bit me despite I had spite against him. 我有意邀请咬我的人 尽管我怨恨他 On the exciting kite site, the excited reciter cited my verse. 在激动人心的风筝现场，激动的朗诵者应用了我的诗句。 The photographer put the graph in the paragraph on geographical geometry. 摄影师将图表插到论述地理几何学的段落 The telegram says that the diagrams show the grammar of the program. 电报说图表表示程序的语法 With gratitude he congratulated me on the celebration. 他怀着感激向我祝贺庆典 The rational operator started a new era of opera cooperation in AD 2000. 理性的操作者在公元 2000 年开创了一个歌剧合作的新时代 I can’t tolerate the acceleration in decorating the refrigerator. 我不能容忍对冷库装饰的加速 The fateful up to date data of the gate have a fatal error. 大门的决定性最新数据有一个致命错误 I’ve hatred for the hateful man’s skates bought with prior private privilege. 我对那个可恶男子用优先个人特权购买的冰鞋感到厌恶 With one penny I had this peculiar pen opened. 我花了一便士让人把这支奇特的钢笔打开了。 I lowered flowing flowers below the table. 我 把飘垂的花降低到桌子之下 The plowman slowly blows at the glowing globe. 犁地者对着发红的球体慢慢吹气 The fellow’s yellow pillow is hollowed by his follower. 那个家伙的黄色枕头被他的跟随者掏空了 The junior and senior of the senate all have driver’s licenses. 参议院的年长者和年少者都有驾驶执照 The immense expense in condensing the steam made me tense. 凝结蒸汽的巨大开支使我感到紧张 A sensible man’s sensor is sensitive to nonsense on census. 明智者的传感器对人口调查废话敏感 The offensive offender defended himself with the fence. 那个讨厌的触犯者用篱笆自卫 The depen","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-2/:1:3","tags":["english"],"title":"考研词汇800句-2","uri":"https://blog.gethin.online/postgraduate-words-2/"},{"categories":["语言与平台"],"content":"800 句（第八天） The attendants attend the meeting and pretend to be attentive. 侍从们出席会议并装出专注的样子。 The tenderer surrendered her tremendously slender tender fingers. 投标者交出了她异常纤细娇 嫩的手指 The tension tends to extend to a more extensive extent. 紧张倾向于向更广泛的程度扩展。 I spend money on expensive things endlessly; so the expenditure trends up. 我无休止地花钱买昂贵的东西 所以开支趋向上升。 I send him the blend calendar and the splendid bent lens he lent to me. 我把他借给我的混合日历和绝妙的弯曲透镜送给他 The goodness of the wooden goods gives me good mood. 木制商品的精华给我一个好心情 The teenagers in the canteen are keen to see the queen sitting between the green screens in the greenhouse. 食堂里的少年们巴望见到坐在温室里的绿色屏风间的女王。 From the tiny tin pin, the spinner pinched off an inch. 纺纱工从小锡别针上掐掉一英寸。 In my opinion, only the onion can grow in the iron environment. 据我看 只有洋葱能在铁质环境中生长。 The crazy jazzman gazed at the blaze on the razor with amazement. 疯狂的爵士音乐演奏者惊愕地盯 着剃刀上的白斑 The illustration illuminates the demonstrating Democrat’s penetrating strategy. 图解阐明了正在示威的民主党党员的渗透策略 The cat catches a fat rat and scatters the others under the mat. 猫抓了一只肥鼠并驱散了席子下面的其它老鼠。 On the flat platform the bat will pat whatever hat it likes. 在平坦的站台上 蝙蝠会拍打它喜欢的任何帽子 Hence the hen cries whenever it sees a chicken. 从此每当那只母鸡看见小鸡时就叫 The driller filled the grill with brilliant film. 钻孔者在烤架上填满辉煌的胶片 The ill man had a pill and sat on the pillar in stillness until now. 那个坏人吃了一颗药丸后静止不动地坐在柱子上直到现在 The skillful miller killed millions of lions with his ski. 技术娴熟的磨坊主用雪橇杀死了上百万头狮子。 The silly spilled the milk on the silver silk. 傻子把牛奶溅到银白色的丝绸上。 On the far farm the army’s arms are kept warm by a swarm of bees. 在远方的农场上 陆军的武器被一群蜜蜂保暖 The alarm harmed the charming harmony of the ceremony. 警报声损害了典礼迷人的和谐 Squirrel inquired an acquaintance and acquired the requirements. 松鼠询问了一位熟人 得知了那些要求 A title is entitled to the retired worker who repaired the entire tire tirelessly. 那个不倦地修理了整个轮胎的退休工人被授予了一个头衔 The hired admirer inspired his desire for the wire. 雇佣钦佩者激发了他对铁丝的渴望 The firm fireman first overcame thirst desire. 坚定的消防员首先克服口渴欲望。 The tiresome pirate sounded siren and le t off fireworks. 讨厌的海盗鸣汽笛放焰火 The career carpenter put the cargo on the carbon carpet. 职业木匠把货物放到碳质地毯上 The married man carried the scarred car and carriage onto the carrier. 已婚男子把有疤痕的汽车和马车带到了航母上。 Apart from that apartment, the departed department leader was partly partial to this one. 除了那套公寓外 已故系领导还有点偏爱这一套 I can hardly pardon his discarding the hardware and cardboard in the harbour. 我简直不能原谅他在港口丢弃五金和硬纸板 The guard guards the guarantee in the garden regardless of the hazard. 卫兵不顾危险看守着花园里的抵押品。 I packed the jackets and rackets into packets with the sacks. 我们用袋子将夹克和球拍打成小包。 The bachelor is detached to attach tags to the yacht. 学士被派遣去给游艇贴标签。 The attacker cracked the racks and stacked them on the track. 攻击者打裂 搁板并把它们堆在跑道上 The backward man lacks black background. 落后的男子缺少黑色背景 The awfully awkward warship is warned not to be awarded war reward. 那艘非常拙劣的军舰受到不给予战争报酬的警告。 Afterwards, I went toward the yard and looked upward, downward, inward, outward, forward and backward. 后来我走向院子 向上下内外前后看 The bright fighter is frightened and flies upright in straight line from the right. 那架明亮的战斗机受到惊吓后呈直线地从右边垂直飞起来 I slightly delight in flight in the sunlight and lightning. 我有点喜欢在阳光和闪电中飞行 Money will be tight overnight after tonight’s midnight. 银根将在今晚午夜之后一下紧缩 The sightseer speaks highly of the highway with sigh. 观光者叹息着盛赞这条公路 At the agency, the aged agent is urgently urged to go for surgery by the gentle surgeon. 在办事处 温和的外科医生急切地催促 年老的代理商做外科手术。 If you carry the cabinet of cabbage garbage to the garage, you’ll get an average wage. 如果你把这橱柜包菜垃圾扛进了汽车库 你将获得一份平均工资 The villagers in rage caused a tragedy on the cage like stage. 狂怒的村民在笼子形的舞台上制造了一场悲剧 It is imaginable that breaking the engagement will damage his image. 可以想象 违反婚约将损害他的形象。 The extra theme of the supreme scheme is an extreme secret. 至高无上的计划的额外主题是个极端机密 No extraordinary disorder happens on the orderly border. 在有序的边界上没有发生不寻常的混乱 The wordy lor d left his sword on the world. 多话的君主把他的剑留在了世界上 According to the record,","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-2/:1:4","tags":["english"],"title":"考研词汇800句-2","uri":"https://blog.gethin.online/postgraduate-words-2/"},{"categories":["语言与平台"],"content":"考研词汇800句 - Part 3 ","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-3/:1:0","tags":["english"],"title":"考研词汇800句-3","uri":"https://blog.gethin.online/postgraduate-words-3/"},{"categories":["语言与平台"],"content":"800 句（第九天） The beloved novelist put her lovely gloves above the stove. 敬爱的小说家把她美丽的手套放在火炉上方。 It’s proved that the approver improved waterproof roof. 经证实 赞同者改善了防水屋顶 In the reaction, the fraction acts as an agent. 在反应中 这些碎片起一种媒剂的作用 Actually the actor and actress reacted actively to the activity. 实际上男演员和女演员对这个活动作出了积极的反应。 In the racial horse race, the white racer’s race horse won. 在种族赛马运动中 白人赛手的马获胜 I feel a trace of disgrace for the gracious man’s embracing her bracelet. 我对仁慈男子拥抱她的手镯感到一丝耻辱 The preface is written on the surface of the furnace that faces the space facilities. 序言写在面对太空设施的火炉表面 “In fact, some factors are unsatisfactory to the factory,” the dissatisfied manager said. “事实上有些因素对工厂来说不是满意的。”不满的经理说。 The manufacturer manually manufactured many machines for the manufactory. 制造商为工厂手工制造了很多机器。 The exact contact with practice has practical impact on me. 同实践的密切接触对我有实际的影响 To make the contract attractive, the contractor subtracted a tractor from it. 为了使合同有吸引力 承包商从中减去了一台拖拉机。 In this chapter, the capture characterized the characteristics of the characters. 俘虏在本章描述了字符的特性 The captive captivated by the apt adaptation rapped the cavity with rapture. 被灵巧的改编迷住了的被捕者着迷地敲打空腔 I’m in charge of discharging a large amount of charcoal and coal at the coal mine. 我负责在煤矿卸一大堆木炭和煤。 With shortcomings overcome, the outcome become welcome. 随着缺点被克服 结果变得受欢迎 At the station the statesman hesitates to state the status of the statue. 在车站政治家不愿陈述雕像的状况。 The limitation on the imitations is preliminarily eliminated. 对模仿的限制初步被消除 The unconventional convention put many people to inconvenience. 那个不合惯例的大会使很多人感到不便 The ventilator inventor’s adventure prevented him from venturing revenge. 通风机发明家的奇遇阻止了他冒险复仇 Even the evening event couldn’t eventually spoil the joy of the New Year’s Eve. 即便是傍晚的事件最终也无损除夕的欢乐 After an explosion the explorer restored the storage of the explosive in the exploiter’s storehouse. 爆炸过后勘探者恢复了剥削者的仓库里炸药的储量 The sore is orally ignored by the ignorant immoral man. 疮痛被无知的不道德者口头忽视了 The boring boy bored ashore for ore core at the score. 讨厌的男孩在海岸上的刻线处钻探矿核 In the famine I got familiar with this famous family name surname. 在饥荒中 我熟悉了这个有名的姓。 The tame tigers play the same game on the frame. 温顺的老虎在框架上玩同一游戏 The shameless lame man is to blame for the flaming frame. 无耻的跛子 应为燃烧的框架负责。 The plain woman explained to me why she complained about the chain. 长相平平的女人向我解释她为什么抱怨那条链子。 After the entertainment the captain obtained an entrance fee. 娱乐表演之后 船长获得了一笔入场费 It’s ascertained that the certificate is behind the curtain of the stainless steel container. 经查实证书在不锈钢容器的帘子后面 In the building, the wild child hurt his mild chin on the china. 在大楼里 那个粗野的孩子在瓷器上弄伤了温柔的下巴。 The feeble man feels an ache on his heels and knees when he kneels on the steel steering wheel. 当虚弱男子跪在钢舵轮上时他的脚跟和双膝感到疼痛 The bee paid the fee of coffee, beef and beer for the cheerful deer. 蜜蜂为欢快的鹿付了咖啡、牛肉和啤酒的费用 To the ants, the infant elephant is a giant in the plantation. 对蚂蚁们来说 幼小的大象是种植园里的庞然大物 The merciful merchant wants t o grant some merchandise to the panting immigrants. 仁慈的商人要给喘气的移民们一些商品 The lengthened long fishing rod alongside the lake belongs to me. 在湖边的加长长钓竿属于我 The strong man among us strongly hates the wrongdoing. 我们当中的壮汉强烈憎恶这件坏事 In occasion al case the phrase emphasizes the importance of the phase to the laser. 在偶然情况下该短句强调了相位对于激光的重要性 Based on the basic case, the purchaser found the vase in the basin in the basement. 根据这个基本情况 购买者在地下室的盆子里找到了花瓶 On the camp of the campus the campaign champion put the camera on the camel. 在校园的营地上运动冠军将摄影机放在骆驼上 He stamped on the stamps and slammed the lamp on the damp dam. 他用脚踩邮票并将灯砰地摔在潮湿的坝上 When the boat floats through the throat, the goat in overcoat goes to the goal. 当船漂过狭口时 穿大衣的山羊 朝目标走去 The competitor is compelled to complete the competition. 竞争者被迫完成了比赛 I’m perplexed by the flexible complex index of sex and age. 我被灵活复杂的性别与年龄索引迷惑住了。 Since then the sincere princess has known the principal principle. 从那时起诚实的公主就知道 该主要原理。 The bead is put on the forehead of the dead shepherd ahead of the herd. ","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-3/:1:1","tags":["english"],"title":"考研词汇800句-3","uri":"https://blog.gethin.online/postgraduate-words-3/"},{"categories":["语言与平台"],"content":"800 句（第十天） The tenant is discontented with the content of the agreement for renting the tennis tent. 租客对承 租网球帐篷协议的内容不满。 The current occurrence of torrent spurs him to buy fur and sulfur. 最近的洪流事件刺激他去买皮毛和硫磺。 I’m confident that the dentist will deny the confidential accidental incident. 我确信这个牙医将会否认这个秘密的意外事件。 The student identified the identical idiom on the identity cards. 学生鉴别身份证上完全相同的的成语。 The stupid student rapidly studied the accident in the studio. 愚蠢（乏味、麻木）的学生在工作室内快速学习这个意外事件。 Considering considerable spiders outside, I stay in the president’s residence. 鉴于外面有太多的蜘蛛，我留在校长的住处。 Besides this side, I considered both the inside and outside. 除了这一侧面，内外两面我都考虑了。 It’s evident that the evil devil inevitably goes to ruin. 很明显，邪恶的魔鬼必定走向灭亡。 In the company my companion accompanied me until I accomplished polishing the shoes. 在公司，我的同伴一直陪伴着我，直到我完成了把鞋子抛光。 I prepare to compare the two comparable parallel companies. 我准备将那两个可比较的类似的公司进行比较。 My neighbor knows the height and weight of the highjacked freight. 我的邻居直到被抢劫的货物（船货）的高度和重量。 The rebels labeled the labor laboring in the laboratory and lavatory. 造反者将劳动操劳标记在实验室和厕所（盥洗室）。 At 8 o’clock the clerk locked the flock of cocks in the room. 在 8 点钟，职员将那群母鸡锁在房间内。 The mocker knocked the stock with the knots on the stocking and sock. 嘲弄者（模仿者）用长袜和短袜上的结敲打树干。 I’m determined to permit the permanent term on detergent. 我决定准许清洁剂上的永久条款。 The committee admits it committed an omission in commissioning the mission. 委员会允许在试运转这个任务期间犯一个遗漏（的错误）。 The odd man added an additional riddle to the middle of the saddle. 奇怪的男人在马鞍的中间额外加了一条谜语。 The insult to the adult consulter results in multiplication of the faulty faucets. 对那个成年咨询者的侮辱导致了成倍的有缺点的水龙头。 The detective detected that the arch was under the marching Arctic architects’ protection. 侦探发现，这个拱门是在正在行 军中的北极的建筑师保护之下的。 In the college, I alleged that I recollected the dialog in dialect about the dial collection. 在大学里，我声称，我回忆起了关于那个刻度盘收藏品的用方言的对话。 In the selection the lecturer neglected the negligible negative reflection on the election. 在这次选拔中， 演讲者忽略了可以忽略的对选举的负面影响。 The electrical connection in the photoelectric elevator involves electronics. 在光电升降机（电梯）中的电路包括了电子学。 The rising risk arises from the surprised fund raiser’s praise of the appraisal. 上升的危险来自于令人惊讶的资金筹集者对鉴定（估价、评价）的表扬（称赞）。 47 4. The efficient ancient scientist had conscience in science. 有效率的远古科学家对科学有良知。 The eagle is eager to anger the tiger in danger. 鹰渴望激怒在危险中的老虎。 The language angel hanged up the gang and banged them at the angle of the triangle. 语言天使举起了一伙人并把他们猛 撞到三角形的一个角上。 equal, equator, equation, equivalent, quiver. 相等的（胜任的，合适的，不相上下的），赤道，相等（平衡，等式，方程式），相等的（等价物），震动（颤抖） Qualified quality and adequate quantity are equally important. 有资格的质量和足够的数量同等重要。 Televisions and telescopes give the visitors visual ability to see the casual casualty. 电视和望远镜给了来访者视觉的能力来看偶然的事故（伤亡人员）。 The grown up growled at a crowd of crows. 成年人对一群乌鸦咆哮。 I threw a row of arrows, which narrowly passed the narrow minded man’s eyebrows. 我投掷了一排箭，勉强地（精细地）通过了小心眼的男人的眉毛。 48 2. “Sorry, I’ll borrow the lorry tomorrow,” the sorrowful man said with worry in the corridor. “对不起，我明天要借卡车”，悲伤的男人焦急地在走廊中说。 The signalman’s signature sign is significant to the vacant vacation. 通信兵的信号对空闲的假期是非常有意义（重要的）。 The resigned designer is designated to an assignment of reigning the foreigners. 顺从的（听天由命的）设计家被指派了一个支配外国人的任务。 Because of the temperature tempo, I temporarily lost temper to my contemporary in the temple. 因为温度的节奏（速度），我临时地对寺庙内与我同时代的人发火。 The empty empire’s emperor made an attempt to tempt the contemptuous man. 空虚的帝国的皇帝尝试去吸引（引诱）那个轻蔑的人。 The one eyed man obeyed the obedient audience’s order. 独眼男人服从了温顺的听众的命令。 The patriot’s radar made the radical patient impatient. 爱国者的雷达使得激进的病人不耐烦。 From the experiment the experienced expert gained an unexpected expertise. 从实验中，富有经验的专家获得了意想不到的专业知识。 Details about the tailor’s tail are available from the prevailing dailies. 关于裁缝尾部的详细资料是从流行的日报中获得的。 The sailor was nailed on the rail for he failed to trail the mail. 因为追踪邮件失败，这个水手被钉在了横杆（围栏）上。 The frank man put the first r","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-3/:1:2","tags":["english"],"title":"考研词汇800句-3","uri":"https://blog.gethin.online/postgraduate-words-3/"},{"categories":["语言与平台"],"content":"800 句（第十一天） The commonsense commonwealth government no longer uses the uncommon commonplace. 有常识的联邦政府不再使用不寻常的陈腐之言。 The communist communicated communism to this municipal community. 那个共产党员把共产主义传入该市立社区 In the bar the barber bargained for a jar of jam, then got over the barrier of barrels. 在酒巴里理发师为一罐果酱讲了价然后越过桶作的屏障 The quarrelsome general quarreled about a quarter quart of oil in the head quarters. 好争吵的将军在司令部为四分之一夸脱油而争吵 On the wedding I saw blooms embedded in the bed of the bedroom. 在婚礼上 我看见卧室的床上镶嵌着花朵 The fisherman wishes to finish the dish of reddish fish. 渔夫希望做完那盘略带红色的鱼。 On the Christmas the Christian’s assistant fisted Pistol Piston and twisted his wrist. 在圣诞节 基督徒的助手拳击了“手枪活塞”并扭了他的手腕 My sister insists consistently on persistent resistance to transistor radios. 妹妹一贯坚决主张持久抵制晶体管收音机。 The chemist and the mistress insist that the mist consists of several chemicals. 化学家和女教师坚持认为薄雾由几种化学物品构成 My nephew found a few dewdrops on the Jewish jeweler’s jewel. 侄儿发现犹太珠宝商的珠宝上有几滴露珠 The crew unscrewed the screws from the sewing machine and chewed them. 船员们从缝纫机上旋下螺钉并咀嚼它们 The interviewer reviewed the newspaper and renewed his viewpoint on the news. 采访者再次查看了报纸并更新了他对该新闻的看法 The refiner defined a definite confine with her fine finger. 提炼者用她精细的手指定义了一个明确的界限 The sugared vinegar is refined from the sugarcane and pine. 加糖的醋是从甘蔗和松木中精炼出来的 We are dined and wined in the inner dining room of the inn. 在旅店的内部餐厅 我们受到了酒宴款待 I’m inclined to underline these disciplines in the outline written on linen. 我倾向于给写在亚麻布上的大纲中的这些学科划下画线 The engineer examined the engine of the mining machine for sto mach. 工程师检查采矿机的发动机是否有肚子痛。 The submitted submarine on the magic magazine is shining and magnificent. 魔术杂志上那艘提交的潜艇闪亮而壮观。 Thus the enthusiastic dumb man thumbed the humble man’s umbrella. 于是热情的哑巴用拇指拨弄谦卑男子的伞 The trembles of the umbrella assembly lines have resemblances. 这些雨伞装配线的抖动有相似之处。 I’m interested in why he is arrested while resting in aural restaurant in the forest. 我对他为何在森林里的香味餐馆歇息的时候被捕感兴趣。 I guess the guest’s gesture suggested that he could not digest well. 我猜想客人的手势暗示 了他消化不良 The pretty priest protested the contest of protein test. 漂亮牧师抗议蛋白质化验赛 “What a marvelous carving!” the starving harvester in vest said. “好一件神奇的雕刻！”挨饿的穿着背心的收割者说 During the festival the investor investigated his ancestor. 节日期间投资 者调查了他的祖宗 Subsequently the eloquent man frequently asked the consequence of quenching in sequence. 其后雄辩者频繁地询问顺序灭火的结果 In this semester the westerner thinks Chest Orchestra is the best. 这学期西方人认为箱子乐队是最好的乐队 Henceforth, the north wind is worthless to the northerners. 从今以后，北风对北方人没有益处。 On the eastern Easter feast, at least one beast’s breasts were tested with yeast. 在东部复活节宴会上 至少有一头牲畜的乳房被用酵母做了试验 The young youths lounged in the south mouth of the cave for one month. 无经验的青年们在南洞口闲 荡了一个月 The bird nests only in northeast, northwest, southeast and southwest lest it be found. 此鸟只在东北、西北、东南和西南筑巢 以免被发现 The airport and seaport are important to import and export of portable goods. 机场和海港对于进口和出口轻便商品很重要 On the porter’s passport a portion of the portrait isn’t proportional. 在搬运工的护照上 部分肖像不成比例 With the reporter’s support, the sportsmen are transported to the airport. 在记者的支持下 运动员们被运送到了机场 After a fortnight’s torture, the unfortunate man got an opportunity to esc ape the misfortune. 经过两星期的拷打后那个不幸的人得到了逃脱不幸的机会 I got this sort of comfortable soft shorts with no efforts. 我不费吹灰之力弄到了这种柔软舒适的短裤。 The forecaster contrasted the cast castle with the vast desert. 预言者将铸造的城堡与广阔的沙漠作了对比。 I tasted the paste in haste and cast it on the waste plaster. 我匆忙品尝了浆糊然后将其丢在废泥灰上。 The astronaut, an astronomy fan, is astonished at the gymnastics show in the gymnasium. 宇航员 一位天文学迷 对体育馆里的体操表演感到惊骇 The master’s masterpiece caused a disaster to headmaster. 主人的杰作给校长 造成灾难 After the blast the plastics show everlasting elasticity. 爆炸过后 塑胶显示出永久的弹性 The pitch made me itch. I pitched the switch into the ditch around the kitchen. 沥青使我发痒 我把开关抛进围绕厨房的水沟里 I scratched a match and saw my watch catching a patch. 我划了一根火柴发现我的手表钩着了一块补丁。 With time elapsing, the flaps collapse up ","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-3/:1:3","tags":["english"],"title":"考研词汇800句-3","uri":"https://blog.gethin.online/postgraduate-words-3/"},{"categories":["语言与平台"],"content":"800 句（第十二天） In the passage the passenger passed a cassette of message to messenger. 在过道里 乘客给信差传递了一盒带信息。 It was not the aluminum but the massive brass and bronze on the grass that embarrassed me. 让我为难的不是铝而是草地上厚重的黄铜和青铜 From the classical class, the classmate with glasses knows the classification of classics. 戴眼镜的同学从古典文学课上知道了古典名著的分类 The hungry drunk plunged a trunk of lungs into the tunnel under the channel. 饥饿的醉汉把一大箱肺投进了水渠下面的隧道 I bundled a bunch of branches and anchored it on the punching bench. 我捆起一簇树枝 将它栓在冲压工作台上 The fundamental fund functions punctually in conjunction with abundant capital. 这笔重要基金与充裕的资本一起准时发挥作用 Uncle and aunt launched a laundry with the blunt hunter. 伯伯和伯母与直率的猎人创办了一家洗衣店 The upset supplement supplier wen t up with the puppet to the upper room for supper. 心烦意乱的增刊供给者与傀儡一起到上面的房间吃晚餐 I’m liable to give reliable reply to the application for supply of apples. 我有责任对申请供应苹果给予可 答复 Salaries vary with various jobs. 薪水随各种各样的工作而异。 I didn’t evaluate the blue glue due to the vague plague. 因为不明确的瘟疫 我没有对蓝色胶水估价。 The flu influenced the influential speaker’s fluency of speech. 流感影响了那个有影响的讲话者讲话的流畅 I have association with the socialists of the society. 我与协会内的社会主义者有交往 In the cinema the medicine immediately remedied the medium. 在电影院里这种药立刻拯救了中间人 I use the ripe recipe to wipe the pipeline. 我用成熟的配方来擦拭管道 The boastful toaster roasts himself on the coast in the sunshine. 好说大话的祝酒者在海岸上晒太阳 It was true that the rescued cruel man let fuel oil issue from the tissue. 获救的无情男子真的任凭燃油从薄纱中流出 The furious obscure curer is curious to secure the curly curved mercury curiosity. 盛怒的不出名治疗者渴望弄到这种带卷曲曲线的水银珍品。 The dictator predicted the contradiction in the dictionary. 独裁者预言了字典中 的矛盾 In the fiction, the victim of the conflict pictured the picnic after victory. 在小说中 冲突中的受害者描绘了胜利后的野餐 The pupils will fix with a mixture the fixed figure in the future. 学生们将来要用一种混合物整修固定轮廓。 The impure mixture with impurity is purified. 含杂质的不纯混合物被提纯。 The native has no nationality; he is an international man. 这个土著没有国籍 他是一个国际人 In the rural the naturally matured tomatoes have this nature. 在乡下自然成熟的番茄具有这种性质 The worshiper thinks that the worst is the insufficient horse power. 崇拜者认为最坏的事是马力不足 A year ago I could go without the foregoing favorite flavor. 一年前没有先前最喜爱的风味我也能过 The fresh flesh on the mesh refreshed the dog. 网格上的新鲜肉使狗恢复了体力 In the autumn the authorities automatically authorize me to buy highly mobile automobiles. 秋天 当权者自动授权我买高机动性的汽车 The columnist holds the colorful column of the colonial newspaper. 那位专栏作家主持殖民地报纸的多彩专栏 In the beautiful bureau my daughter’s laughter served for the sauce of the sausage. 在漂亮的办公署 女儿的笑声充当了香肠的调料。 The mechanical mechanic knows the technique and technology of the echo mechanism. 呆板的机修工知道共鸣装置的技术和工艺 The ugly druggist gauged the huge plug in the refugee’s rug. 丑陋的药剂师测量了难民毛毯中的巨大插头 I hope to make copper copies of the telescope and micros cope for hobby in the lobby. 我希望制作望远镜和显微镜的铜质复制品 The sloped envelope indicates the development velocity of printing. 那个倾斜的信封显示了印刷的发展速度。 The rope is proper property to the prospering rope maker. 绳子对成功的制绳者来说是真正的财产 It’s a pity that the spittoon in the pit was hit and split. 遗憾的是坑内的痰盂被打裂 The situation is fit for profiting and beneficial to the shops situated nearby. 这种形势适于获利且对坐落在附近的商铺有益。 The fanciful panda fan panics over the span of the pan like panel. 爱幻想的熊猫迷对盆状仪表板的全长感到恐慌 The advanced van has disadvantages as well as advantages. 这辆先进的篷车有优点也有缺点 The original Organ Organization was originated with an original man. 最初的风琴组织是由一个有创见的人发起的。 The pale salesman wholesales scales on a large scale. 面色苍白的推销员大规模批发比例尺 天平 鱼鳞 The males think the females have talent for telling stale tales. 男人认为女人有讲陈腐故事的才能。 Beneath (Underneath) the wreath the deaf man near death is out of breath. 花环下面那个快要死的聋子喘不过气来。 The conclusion includes my attitude toward his rudeness. 结论包含了我对他的粗鲁所持的态度 In the pond the sponsor responded to the correspondent’s corresponding responsibility. 在池塘里主办者对通讯员的相应责任作出了回应 In this version, some conversions are made to the verbs and adverbs in the conversati","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-3/:1:4","tags":["english"],"title":"考研词汇800句-3","uri":"https://blog.gethin.online/postgraduate-words-3/"},{"categories":["语言与平台"],"content":"考研词汇800句 - Part 4 ","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-4/:1:0","tags":["english"],"title":"考研词汇800句-4","uri":"https://blog.gethin.online/postgraduate-words-4/"},{"categories":["语言与平台"],"content":"800 句（第十三天） Last summer the drummer became an amateur dramatist dramatically. 去年夏天 鼓手戏剧性地变成了业余剧作家 Long Tongue League’s colleagues are fatigued with cataloguing. 长舌联合会的同僚们编目录编累了。 The bottle is hidden in the bottom of a ton of cotton the cottage. 瓶子被藏在农舍里一吨棉花的底部 The pattern of the battery doesn’t matter to the battle against the little brittle cattle. 电池的式样对与脆小牛作战无关要紧。 By the biography, the biologist’s playing the violet violin violently violated rules. 据传记记载，生物学家猛奏紫罗兰色的小提琴违犯了规矩 In the faithful waiter’s waist exists a list of the ten listeners. 在忠实的侍者的腰里存有那十位听众的名单。 The typist plays Typhoon on the piano in a typical style. 打字员以典型的风格在钢琴上演奏“台风”。 I pushed aside the crushed cushion in a rush and saw a bushy brush. 我急忙推开压皱的软垫子 看见一把浓密的刷子。 Riding on the ridge of the bridge, the proud bride shouts loudly to the cloud. 骄傲的新娘骑在桥脊上对着云大声喊 Th e decisive decimal point made the acid man decide to suicide. 决定性的小数点使刻薄之人决定自杀。 I’m convinced that the provincial government will provide provisional provisions. 我深信地方政府将提供临时供应品。 The hidden division is subdivided into individuals. 隐藏的师被细分为个体 The tides slide on the tidy wide beach and collide each other. 海潮在整洁宽阔的海滩上滑行并相互碰撞。 The briber described the tribe head’s bribery. 行贿者描述了部落首领的受贿行为 The ribbon of the rifle is fabricated with fiber. 来复枪的带子是用纤维制作的 The continent continues to control the import of petrol and petroleum. 大陆方面继续控制汽油和石油进口。 They returned in turn to bury the luxuries burnt in the burst. 他们依次返回来埋藏在爆炸中烧毁的奢侈品。 Banned murders in the suburb bring turbulent disturbance and burden to the urban turbine works. 在郊区被禁止的谋杀给都市透平工厂带来汹涌骚乱和重负 A nice price of the iced rice is offered to the officer. 军官得到了冰冻米的好价钱。 The poor man in poverty sleeps on the floor at the doorway. 那个贫困的可怜人睡在门口的地板上。 In the log lodge he said some illogical apologies. 在木屋里他说了些不合逻辑的道歉话 The slogan crier saw the dog and frog jump to and from in the fog. 呼口号者看见狗和青蛙在雾中来回跳 I recognized the large sized prize and seized it. 我认出了大号奖品并将它占有。 The lying liar lied to the dying diet maker that the tie was dyed blue. 躺着的说谎者对临死的食疗制作者谎称带子染成了兰色 The unyielding man fiercely pierced the shield in the field. 那个不屈的人凶猛地刺穿田野里的盾牌 Perhaps something happy will happen to the unhappy man. 或许那个不高兴的人将要碰上某件快乐的事。 The Greek checked his cheeks on the weekend. 希腊人在周末检查了他的面颊。 The troop’s stoop on the loop became the top topic at the bus stop. 部队在环行道上的屈服在公共汽车站成了头等话题。 The chop shopkeeper let the blood drip to the crops. 排骨店老板让血滴到庄稼上。 The pop song is popular in the populous city. 这首流行歌曲在人口稠密的城市 流行 Regretfully, we can’t regulate the irregular liner on the gulf. 遗憾的是我们不能调整海湾上不定期的班船。 The pig is obliged to dig a big pit for the pigeon. 猪被迫为鸽子掘一个大坑。 In this district I can strictly distinguish the distinct distinctions of bees’ sting by instinct. 在该地区我能 直觉严格分辨蜜蜂刺的明显特征。 In the Administration, this minister is in charge of registering regional religions. 在内阁中这个部长负责登记区域宗教。 The energetic enemy submerged in the water on the verge of the emergency. 在紧急情况快要发生时精力充沛的敌军沉入水中 The muscular musician found the bud in the mud in the museum. 肌肉发达的音乐家在博物馆里的泥巴中发现了嫩芽。 I also heard of the false pulses elsewhere. 我在别处也听说过这些虚假脉冲 The kid kidnapper can’t get rid of a ridiculous kidney disease. 绑架小孩的家伙无法摆脱荒谬的肾病。 My niece sacredly sacrificed a piece of pie to the God. 侄女郑重地给神供上一块馅饼 The sinful single singer’s finger skin is singular. 有罪的单身歌手的手指皮肤独特。 “The enterprise will be supervised by a group comprising prominent men,” the despising chairman said concisely with no compromise. “企业将由杰出人员构成的小组来监管 ,,”轻蔑的主席毫不妥协简明地说。 The promising singer underwent mysterious misery. 那位有前途的歌手遭受了神秘的痛苦 The physician made a physical examination to the sophisticated philosopher and physicist. 医生给世故的哲学家和物理学家作了体检。 Bowing its elbow, the owl sows in the bowl. 猫头鹰弯着肘在碗中播种。 The cowardly cow vows not to tow vowels. 胆怯的母牛发誓不拖元音字母。 The answer is: Owing to a shower, the powerful powder is no longer on show. 答案是：由于一场阵雨 这种强有力的火药不再展览了。 The biscuit compels the mosquitoes quit the equipment. 这种饼干迫使蚊子离开设备 What a nuisance, the suit is ruined due to the unsu","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-4/:1:1","tags":["english"],"title":"考研词汇800句-4","uri":"https://blog.gethin.online/postgraduate-words-4/"},{"categories":["语言与平台"],"content":"800 句（第十四天） When I fetched the sketch on the stretcher I found the secretary’s secret. 当我拿来担架上的素描时我发现了秘书的秘密 The mutual spirits inspired us to reach the annual aim. 相互的精神鼓舞了我们 达到年度目标 The roaring oar hit the coarse keyboard on the cupboard aboard the boat. 轰鸣的桨击中了船上碗柜上的粗糙键盘 My intimate mate’s ultimate estimate approximates the appropriate value. 我亲密伙伴的最终估计接近恰当的值 In case of necessity, necessary session can be held on the vessel. 必要时 必需的开庭可在船舶上进行 By the navigation of microwave, the navy paved a pavement on the wavy sea. 借助微波导航，海军在多浪的大海上铺了一条路。 The minority of us are confronted with difficulty in the frontier of the major. 我们少数人在该专业尖端领域面临困难 From the context of the text, I find the next pretext for selling the textile. 我从课文的前后关系中找到卖纺织品的下一个借口 The systematic items stem from the walker’s talk about the chalk. 这些系统的条款来源于步行者关于粉笔的谈话 Theoretically, their heir’s theory of meteorology can explain the meteor. 从理论上讲，他们的继承人的气象理论能解释这种大气现象。 I affirmatively confirmed the conformity of the theory with practice. 我断然确认了理论与实践相符 The subordinate coordinates are in accordance with that set by the cordial chorus. 从属坐标与热心的合唱团的设定值一致。 The transactor thinks activating the atomic interaction in the intact reactor is practicable. 办理人认为激活未受影响的反应堆内原子的相互作用是种可行的 The distracted reader can’t be absorbed in the abstract extract. 心神纷乱的读者无法专心于抽象的节录 The compact faction fractured because of friction. 紧密小宗派由于摩擦破裂了 Under the guideline, the output of streamlined seamless liners declines linearly. 在该方针的指引下 流线型无缝班机的产量直线下降 The dreadful tread on the meadow broke the deadly deadlock. 草场上可怕的践踏声打破了致命的僵局 The heading i s “Headline of Headlong Pleadings”. 标题为“仓促答辩状的摘要” I overhear that the hearty man heartily yearns for my harness in the barn. 我无意中听说那个热忱的人十分向往我的牲口棚中的马具 After the rehearsal, the weary mechanic repaired the gears with shears and spear. 排练完后，疲 倦的机修工用剪刀和矛修理了齿轮装置 Having checked the parameters of the apparatus, the paralyzed parasite went to the paradise by parachute. 检查过仪器的参数后 瘫痪的寄生虫乘降落伞到天堂去了 In the compartment, the impartial participant told me his counterpart’s departure. 在隔间里 公正 的参与者把其对等人物的离世告诉了我 The articulate man’s artistic cartoon startled the charterer. 发音清晰者的艺术卡通使包租人大吃一惊 The guardian found a quarterly quart of quartz in the safeguard. 监护人在安全装置内找到了四分之一夸脱石英 The immortal man’s mortgage can be a shortcut to resolve the food shortage. 不朽之人的抵押可以作为解决食品短缺的捷径 The escort resorted to the orthodox paradox to retort his distortion. 陪护者借助正统悖论反驳他的歪曲 The oppressor suppressed his aggressive opinion about compressor. 压制者制止了他的有关压缩机的挑衅性观点 The senseless senator’s pretense of consensus caused a sensation. 愚蠢参议员的舆论借口引起了轰动 The conspicuous suspicious pension is in suspension. 那笔引人注目的可疑养老金被暂停发放 He repents having compensated the dispensable pension for fear of penalty. 他后悔因害怕处罚而补偿了不必要的养老金 Abundance doesn’t mean redundance. The hound found a profound book on the roundabout. 充裕并不意味多余 猎犬在旋转木马上找到一本深奥的书 By courtesy of the mourner, he endeavors to devour the nourishing odour. 承蒙哀悼者同意，他努力吞食滋养气味 The thermal therapy terminated after the terminal germ seminar. 热疗在期末细菌研讨会后终止了 The terraced terrain near the Mediterranean ferry is terrific. 地中海渡口附近的台地地形好极了 The consul’s consultant hauled out the assaulter from the vault. 领事的顾问把袭击者从地窖中拖了出来 The nitrogen atoms combine instantaneously, simultaneously and spontaneously. 氮原子瞬间同时自动化合 The respectful spectator gave the prospective president a retrospect of the spectacular spectrum. 恭敬的旁观者对未来的总统回顾了壮观的光谱 景象 The suicides in adjacent area are incidental coincidence. 邻近区域内的自杀是偶然巧合 His ignorance of her dignity ignited her indignation. 他对她的高贵的无知点燃了她的愤怒 之火 The man tackling the drawback of the brackets runs a slack snack business. 那个解决支架缺点的人经营着萧条的小吃生意。 At the turning the turtle met a turkey and made a turnover on the turnips. 在拐弯处海龟遇见了火鸡，在萝卜上翻了个身 The overthrown president is overwhelmed by the controversy. 被推翻的总统被辩论降服 The handicapped man got a second hand handout of shorthand handbook beforehand. 残疾人事先得到了一本二手速记手册施舍品 Hitherto the withering flowers can’t withstand the sunshine no","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-4/:1:2","tags":["english"],"title":"考研词汇800句-4","uri":"https://blog.gethin.online/postgraduate-words-4/"},{"categories":["语言与平台"],"content":"800 句（第十五天） The assessor asserts that he inserted the deserted desserts in the desert with alert. 估价员断言他把荒废的甜点警惕地插入到了沙漠内。 The abrupt corrupt man had the Xeroxed code corroded in the erosion episode. 唐突的腐败的男人将被复印的代码侵蚀在一段腐蚀情节中。 The enlightened man highlighted his mighty insight into the fright. 开明的人在惊骇中突出他有力的洞察力。 I would rather withhold than uphold you unfold the gold foil on the threshold. 我宁愿拒绝也不支持你在门口（在快要开始的时候）打开金箔。 The imposing man posed as a man of good disposition and disposed of the rubbish. 使人难忘的人摆出好脾气的姿势然后处理垃圾。 The prose author’s diagnosis discloses that the hose is damaged. 散文作家的诊断透露这个软管损坏了。 The limping shrimp impulsively implemented the compulsory duty. 柔软的小虾有推动力地执行被强制的义务。 The implicit implication about the deficit is not explicit. 关于赤字的含蓄的暗示不清楚。 The degeneration of regenerative gene is exaggerated. 再生基因的退化（恶化）被夸大了。 The competent petitioner thinks the perpetual impetus is petty. 有能力的上诉人（请求人）认为永久的动力（刺激）是不重要的。 The superstitious man put the priority on the superficial supersonic superiority. 迷信的人将优先权放到肤浅的超级（超声波）的自尊（优势）上。 The traitor in strait straightforwardly told me the traits of the bait. 在窘迫中（苦恼）的叛国者直接地告诉了我诱饵的特征。 The Oriental is proficient in the ingredients. 东方人精通配料（成分）。 The recipe recipient transiently made the conscientious alien client unconscious. 处方容器片刻使尽责的外国顾客不省人事。 The rotary agitator irrigated him. 旋转式搅拌机为他清洗（伤口）。 The counselor bounced up to denounce discount. （法律）顾问跳起来公然指责折扣。 The degraded undergraduate upgraded the underlying virus program. 降级的大学肆业生升级了潜在的病毒程序。 Jail life made the frail retailer avail every snail in the pail. 监狱生活使虚弱的零售商人帮助每个在桶里的蜗牛。 Deviation in aviation is dangerous. Writing is alleviated via bias on abbreviation. 飞行中的偏移是危险的。书写通过对缩写的偏爱减轻了。 On the anniversary the versatile poet wrote an adverse verse Virtue versus Evil. 在周年纪念中，多才多艺的诗人写了一首相反的诗“美德对邪恶” The recruit made the current circulate in the circuit on the circumference. 新兵使电流在圆周上的 电路中循环（传播） In the suitcase, the guitar tutor found the tuition by intuition. 在手提箱内，吉他家庭教练凭直觉找到学费。 The watchful snatcher dispatched a batch of combatants to the hatch. 警惕的诱拐者派了一批战士去舱口。 The wretched butcher clutched the needle and stitched it clumsily. 可怜的（悲惨的，恶劣的）屠夫抓住针然后笨拙地缝它。 The peer’s queer peering is a sheer sneer. 同等的人的可疑的窥视是一个纯粹的嘲笑。 The currency curriculum made the excursionist incur loss of time and money. 流通（货币）课程使得旅行者招致了时间和金钱的损失。 The stray betrayer arrayed the sprayers on the road. 迷路的叛徒在路上排列了喷雾器。 Dust accumulated on the insulated simulator in the desolate lab. 在荒凉的实验室中，灰尘聚集在绝缘的模拟器上 The inflated balloon indicates a latent inflation on the plateau. 膨胀的气球预示着在高原上的一个潜在的通过膨胀（膨胀）。 Trivial tribute s constitute the attribute of constituent’s report. 微不足道的贡品形成（构成）了选举人的报告的属性。 I acutely and resolutely refuted the brutal persecution of mute commuter. 我尖锐和坚决地反驳了对无声的（沉默的）通勤者的残忍的迫害。 This measure may preclude the exclusive agency from selling crucial crude oil. 这个措施可以排除对至关重要的原油的销售的独家代理。 He depicted the conviction that contradicted the verdict. 他叙述（描述）了与裁决相矛盾的定罪。 Magnify the magnitude of the magnetism. 放大磁力（磁）的量圾。 The deputy chairman of the charity clarified the importance of clarity and purity. 慈善团体的代理注意阐明了透明和纯洁的重要性。 The tramp from the tram swamped the ham hamburger with shampoo. 有轨电车的脚步声淹没了带有香波的火腿汉堡。 According to the pamphlet, the current in the amplifier can be amplified to 3 amperes. 根据这个小册子，在放大器中的电流可以被增强到 3 安培 。 Prolong the sponge along the longitude and latitude at an altitude. 在一个高度，沿着经度和惟独拉长海绵。 The conservative man made a reservation in the observatory. 保守的人在天文台做了预约。 The mender recommends me to amend the legend (传说) agenda (议程). 修理的人建议我改正图例 操作规程。 His comprehensive apprehension about the appendix of the pendulum is obvious. 他对钟摆的附属品的全面的理解是很明显的。 Elevate the eleventh level to relevant height. 升高第 11 级到相应的高度。 Thereafter, I adhered to the coherence inherent to the theory. 从那以后，我 坚持理论的内在一致。 The prophet appropriately appropriated the fund for repairing propeller. 预言者适当地拨出资金来修理螺旋桨。 I’m baffled why the affiliated man initiated the negotiator into ego. 我感到困惑，为什么有关联的（附属的）人倡导（","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-4/:1:3","tags":["english"],"title":"考研词汇800句-4","uri":"https://blog.gethin.online/postgraduate-words-4/"},{"categories":["语言与平台"],"content":"800 句（第十六天） The extinct exotic bird’s feather contains zinc. 那种已绝迹的珍奇的鸟的羽毛中含锌 The smuggler shrugged to the bugler hugging the bug in the tugboat. 走私者对在拖船中拥抱臭虫的号手耸耸肩 The vocation advocate found the word “vocal” and “reciprocal” not in the vocabulary. 职业倡导者发现“嗓音的”和“交 互的”两词不在词汇表中 Without my aid I’m afraid the maiden would have been raided. 没有我的帮助我怕少女已遭到袭击。 The slim Muslim reached his climax when he found the axis of the galaxy. 苗条的穆斯林在发现银河的轴线时达到了 人生的 顶点 Bonus is a stimulus for me to study the silicon in the bacon. 奖金是我研究薰肉中硅原子的动力 The categories of the lubricated duplicators are intricate. 那些润滑过的复印机的种类错综复杂 The wagging wasp grasps the crisp clasp for a gasp. 摇摆的黄蜂抓住脆钩喘息 The reconciled reptiles rest on a fragile tile. 和解的爬行动物歇在 易碎的瓷砖上 The gossip tossed the mossy blossom fossil. 爱讲闲话者向上抛长满苔藓的花化石 Test the immune function by immersed dispersion. 用浸入扩散 法 测试免疫功能 The lateral elite is literally illiterate. 边上的杰出人物简直是文盲 To abide the abiding bidding, the oxide bidder strides on the seaside. 为了忍耐无休止的吩咐 氧化物投标者在海滨阔步行走 The tormentor enlarged the engagement garment. 折磨者加大了订婚服装 The cripple dipped the whip tip into the chip solution nearby his hip. 跛子将鞭子末端浸入他臀部旁边的芯片溶液中。 The tickler pricked a t ick on the nickname Nickel. 挠痒者在绰号“镍币”上刺了个勾号。s The administrator diminished the feminine miniature to minimal size. 管理员将女性缩样缩减到最小尺寸 The man with mittens intermittently intervened the remittance. 戴连指手套的人间歇地介入汇款 The scorched couch is put in the porch of epoch. 被烤焦睡椅放在时代门廊内 The monstrous monarch monopolized monarchy. 可怕的君主垄断了君主国 The missionary transmitted emission emitted lately. 传教士传播了新近散发出来的散发物 I’m intent on tentative retention of potential patents. 我热衷于潜在专利权的暂时保 留 The expelled man repelled billions of rebellions. 遭到驱逐的男子击退了数十亿次叛乱 The cellar dweller yelled, “Fell the jellyfish burglar!”. 住地下室的人喊道 打倒海蜇窃贼 The diplomatic diplomas are made in automation in the autonomy. 外交证书在自治区是自动化生产的。 The enrolled jolly stroller polled on the trolley. 被招收的快乐的散步者在无轨电车上投票 The contaminated vital vitamin made racial discrimination come to culmination. 被污染的重要维他命使种族歧视达到极点 The jogger made an analytical analogy between the ecology and geology. 慢 跑者在生态学和地质学之间进行了分析类比 The alliance enhanced the reliability of the applicable alloy appliances. 盟友增强了适用的合金用具的可 性 The gigantic panther in pants passed the transition period of heart transplant. 穿裤子的巨大黑豹度过了心脏移植的过度期 With a clatter, the flatterer shattered the chattering wattmeter in the chaos. 当啷一声 马屁精在混乱中打碎了格格作响的瓦特表 “Homely food is wholesome,” the comedian said on the dome. “家常食品有益于健康，”喜剧作家在拱顶上说 The subtle subscriber found the prescription manuscript. 敏锐的认购者找到处方原稿 Time is finite and infinite. I defy the indefinite definition. 时间既是有限的又是无限的 我公然对抗这个模糊的定义 . ","date":"2021-09-02","objectID":"https://blog.gethin.online/postgraduate-words-4/:1:4","tags":["english"],"title":"考研词汇800句-4","uri":"https://blog.gethin.online/postgraduate-words-4/"},{"categories":["数据与算法"],"content":"分治法 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:1:0","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"分治法概念 将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:1:1","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"分治法思想策略 对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:1:2","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"分治法特征 该问题的规模缩小到一定的程度就可以容易地解决 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用； 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。 第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:1:3","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"分治法基本步骤 1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题； 2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 3 合并：将各个子问题的解合并为原问题的解。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:1:4","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"适用分治法求解的经典问题 1）二分搜索 2）大整数乘法 3）Strassen矩阵乘法 4）棋盘覆盖 5）合并排序 6）快速排序 7）线性时间选择 8）最接近点对问题 9）循环赛日程表 10）汉诺塔 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:1:5","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"动态规划 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:2:0","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"动态规划概念 每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:2:1","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"动态规划思想策略 将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。 在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:2:2","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"动态规划特征 能采用动态规划求解的问题的一般要具有3个性质： (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 (3) 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:2:3","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"动态规划基本步骤 （1）分析最优解的性质，并刻画其结构特征。 （2）递归的定义最优解。 （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 （4）根据计算最优值时得到的信息，构造问题的最优解 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:2:4","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"适用动态规划求解的经典问题 矩阵连乘， 走金字塔 最长公共子序列(LCS) ， 最长递增子序列(LIS) ， 凸多边形最优三角剖分 ， 背包问题 ， 双调欧几里得旅行商问题 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:2:5","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"贪心法 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:3:0","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"贪心法概念 在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:3:1","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"贪心法思想策略 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:3:2","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"贪心法基本步骤 1.建立数学模型来描述问题。 2.把求解的问题分成若干个子问题。 3.对每一子问题求解，得到子问题的局部最优解。 4.把子问题的解局部最优解合成原来解问题的一个解。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:3:3","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"适用贪心法求解的经典问题 活动选择问题， 钱币找零问题， 再论背包问题， 小船过河问题， 区间覆盖问题， 销售比赛， Huffman编码， Dijkstra算法（求解最短路径）， 最小生成树算法 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:3:4","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"回溯法 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:4:0","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"回溯法概念 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:4:1","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"回溯法思想策略 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:4:2","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"回溯法特征 （1）针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。 （2）确定结点的扩展搜索规则 （3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:4:3","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"适用回溯法求解的经典问题 八皇后问题， 图的着色问题， 装载问题， 批处理作业调度问题， 再再论背包问题， 最大团问题， 连续邮资问题， 符号三角形问题， ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:4:4","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"分支限界法 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:5:0","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"分支限界法概述 类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:5:1","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"分支限界法策略 在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:5:2","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["数据与算法"],"content":"与回溯法的区别 回溯法：【方式不同】深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解【目标不同】。 分支限界法：【方式不同】广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解【目标不同】。 版权声明：本文为CSDN博主「Kevin’s life」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/ght886/article/details/80289142 ","date":"2021-08-30","objectID":"https://blog.gethin.online/five-algorithms-design-ideas/:5:3","tags":["算法"],"title":"[转载]五大算法设计思想","uri":"https://blog.gethin.online/five-algorithms-design-ideas/"},{"categories":["架构艺术"],"content":"应用场景 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:1:0","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"单体架构 好处 容易理解、开发、测试 容易部署 合适小范围项目 不足 紧密耦合 容易产生复杂代码 所有子域都一刀切 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:1:1","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"N-tier Summary 多层次 层适合特殊的任务 层可以在物理上分离 技术层并不是逻辑上的层 技术边界分层 Typical: 3层架构 显示层(UI \u0026 单纯的UI逻辑) 逻辑层(业务逻辑) 数据层 Advantages 开发独立 易扩展 Disadvantages 改动会影响各个层级 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:1:2","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"Service-Oriented Summary 多服务 每个服务都是一个业务活动 服务可以组合 协议统一标准 企业服务总线 Advantages 服务是松散耦合的 可扩展性好 没有功能重复 Disadvantages 降低敏捷性和团队自主性 费用比较高 会有许多不同的观点 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:1:3","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"Microservices Summary 多服务 每个服务都是一个业务活动 以团队形式提供服务 没有重逻辑的企业总线 自动化最大化 Advantages 服务是松散耦合的，易于扩展 灵活性高 可靠性高 设计了故障处理机制 Disadvantages 边界并不总是清晰的 交互可能会变得很复杂 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:1:4","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"Serverless Summary Backend as a service Function as a service ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:1:5","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"peer-to-peer Summary 去中心化 没有固定的连接 动态发现的 Advantages 分享资源 节约成本 可缩放 Disadvantages 可能存在安全问题 只适用于特殊场景 代码比较重 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:1:6","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"应用程序架构模式 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:2:0","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"分层 Summary 显示层(UI) 应用层(Translation between UI \u0026 busniess) 业务层(Business logic) 持久层(Code to interact with the database) 数据层(Data) Advantages 开发之间容易理解 容易组织代码 Disadvantages 可能导致单体应用 需要撰写大量代码 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:2:1","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"Microkernel Summary 执行任务 工作流 数据处理 浏览界面 图形设计 Advantages 灵活 边界清晰 容易分组 运行过程中容易添加和删除功能 Disadvantages 核心 API 不一定适应未来的插件 插件可以被信任吗 并不总是清楚什么是属于核心代码 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:2:2","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"CQRS Summary 命令查询责任分离 2 模式: 读/查询 \u0026 写/命令 允许特定场景查询 有同步要求 与事件源模式不同 Advantages 容易查询 更快、更可扩展的读取查询 更容易对接 Disadvantages 添加数据比较复杂 有学习曲线 可能数据不一致 最终一致性 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:2:3","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"Event sourcing Summary 存储事件而不是当前状态 Event = 发生在过去的事情 Rehydration or replay Advantages 跟踪事件 数据轨迹 业务语言 事件重演 Disadvantages 重演事件 和 外部系统 事件结构的变化 快照 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:2:4","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"CQRS and Event sourcing combined Summary 2个不同的概念 强强联合 它不适用于简单的域，您可以从事件溯源开始，然后再添加 CQRS。 Advantages 简单快速查询 可扩展的 事件跟踪 数据轨迹 商业语言 Disadvantages 增加复杂度 学习曲线 数据不一致 事件结构变化 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:2:5","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"UI Patterns ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:3:0","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"MVC Summary Controller Model View Advantages 关注点分离 并行开发 流行的框架 Disadvantages 控制器可能会变得臃肿 不同的定义 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:3:1","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"MVP Summary View Presenter Model Advantages 对桌面开发友好 关注点分离 测试性好 Disadvantages Presenter层变得臃肿 桌面开发不流行 MVVM Pattern ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:3:2","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"MVVM Summary View ViewModel Model Advantages 现代桌面和移动开发友好 关注点分离 测试性好 Disadvantages UI过度 难以调试 桌面开发不流行 ","date":"2021-08-16","objectID":"https://blog.gethin.online/software-architecture-pattern/:3:3","tags":["架构"],"title":"软件架构模式","uri":"https://blog.gethin.online/software-architecture-pattern/"},{"categories":["架构艺术"],"content":"设计模式六大原则 单一职责原则 Single Responsibility Principle 一个类只负责一个功能领域中的相应职责，或者就一个类而言，应该只有一个引起它变化的原因。 开放封闭原则 Open-Close Priciple 一个软件实体应当对扩展开放，对修改封闭。软件实体应该尽量在不修改原有代码的情况下进行扩展。 里氏替换原则 Liskove Substitution Principe 所有引用基类的地方必须能透明的使用其子类的对象。（在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物） 依赖倒置原则 Dependency Inversion Principle 抽象不应该依赖于细节，细节应该依赖于抽象，要针对接口编程，而不是针对实现编程。（依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象） 接口隔离原则 Interface Segregation Principle 使用多个专用接口，而不是使用单一的总接口，客户端不应该依赖于那些它不需要的接口。 迪米特法则 Law of Demeter 一个软件实体应当尽可能少的与其他实体发生互相作用（高内聚，低耦合）。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:1:0","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"为什么要多用组合，少用继承 变化部分取出并封装起来，便于以后扩展，而不影响其他部分。要针对接口编程而不是针对实现编程。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:2:0","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"一句话常用设计模式 Iterator——迭代器 Adapter（适配器）————换个包装再度利用 ◎ 万事交给子类： Template Method（模板方法）————实际处理就交给子类 Factory Method（工厂方法）————建立对象实例交给子类 ◎建立对象实例 Singleton（单件）————唯一的对象实例 Prototype（原型）————复制建立对象实例 Builder（生成器）————组合复杂的对象实例 Abstract Factory（抽象工厂）————把相关零件组合成产品 ◎切割性思考 Bridge（桥接）————分成功能层次和实现层次 Strategy（策略）————把算法整个换掉 ◎一视同仁 Composite（组成）————对容器和内容一视同仁 Decorator（装饰）————对装饰和内容一视同仁 ◎在结构中穿梭来去 Visitor（访问者）————在结构中穿梭还同时做事 Chain of Responsibility（职责链）————责任转送 ◎简单最好 Facade（外观）————单一窗口 Mediator（中介者）————只要面对一个顾问 ◎管理状态 Observer（观察者）————通知状态变化 Memento（备忘录）————存储状态 State（状态）————以类表示状态 ◎精简不浪费 Flyweight（享元）————有相同的部分就分享，采取精简政策 Proxy（代理）————要用在建立 ◎用类来表示 Command（命令）————将命令写成类 Interpreter（解释器）————以类来表达语法规则 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:3:0","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"设计模式口诀 创建5：工厂，抽象工厂，单例，原型，建造者， 【抽工建单元】 结构7：适配器，代理，桥接，组合，装饰，外观，享元，【时代接合装外向】 行为11：解释器，模版，责任链，命令，中介，观察者，迭代器，备忘录，访问者，状态，策略 【责令中介观迭被，解释策略防撞模】 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:4:0","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"设计模式代码 自己整理的设计模式UML图与代码如下，UML 使用VS2015建模项目。 https://github.com/Gethin1990/design_pattern ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:5:0","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"C# 中常用的设计模式 单例（全局唯一）、工厂（反射）、迭代器（foreach）、观察者（消息队列）、责任链（pipeline）、外观（Gateway）、代理（网络相关）、解释器（表达式树）、策略（打折业务）等 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:6:0","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"设计模式介绍 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:0","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"抽象工厂模式 意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。 注意事项：产品族难扩展，产品等级易扩展。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:1","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"工厂模式 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:2","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"建造者模式 意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 主要解决：在软件系统中，有时候面临着\"一个复杂对象\"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 何时使用：一些基本部件不会变，而其组合经常变化的时候。 如何解决：将变与不变分离开。 关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的\"套餐”。 2、JAVA 中的 StringBuilder。 优点： 1、建造者独立，易扩展。 2、便于控制细节风险。 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。 使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。 注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:3","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"单例模式 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 1、一个班级只有一个班主任。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:4","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"原型模式 意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 主要解决：在运行期建立和删除原型。 何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。 关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些\"易变类\"拥有稳定的接口。 应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。 优点： 1、性能提高。 2、逃避构造函数的约束。 缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:5","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"适配器模式 意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决：在软件系统中，常常要将一些\"现存的对象\"放到新的环境中，而新环境要求的接口是现对象不能满足的。 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 如何解决：继承或依赖（推荐）。 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。 应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。 缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。 注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:6","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"代理模式 意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:7","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"桥接模式 意图：将抽象部分与实现部分分离，使它们都可以独立的变化。 主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。 何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。 如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。 关键代码：抽象类依赖实现类。 应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。 优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。 缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:8","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"组合模式 意图：将对象组合成树形结构以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。 关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。 应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。 优点： 1、高层模块调用简单。 2、节点自由增加。 缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。 使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。 注意事项：定义时为具体类。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:9","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"装饰器模式 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。 何时使用：在不想增加很多子类的情况下扩展类。 如何解决：将具体功能职责划分，同时继承装饰者模式。 关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。 应用实例： 1、孙悟空有 72 变，当他变成\"庙宇\"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：多层装饰比较复杂。 使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。 注意事项：可代替继承。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:10","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"外观模式 意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。 何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个\"接待员\"即可。 2、定义系统的入口。 如何解决：客户端不与系统耦合，外观类与系统耦合。 关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。 应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。 优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。 缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。 使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。 注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:11","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"享元模式 意图：运用共享技术有效地支持大量细粒度的对象。 主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。 何时使用： 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。 如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。 关键代码：用 HashMap 存储这些对象。 应用实例： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。 优点：大大减少对象的创建，降低系统的内存，使效率提高。 缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。 使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。 注意事项： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:12","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"责任链模式 意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用：在处理消息的时候以过滤很多道。 如何解决：拦截的类都实现统一接口。 关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。 应用实例： 1、红楼梦中的\"击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。 缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。 使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。 注意事项：在 JAVA WEB 中遇到很多应用。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:13","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"命令模式 意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。 主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 何时使用：在某些场合，比如要对行为进行\"记录、撤销/重做、事务\"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\"行为请求者\"与\"行为实现者\"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。 如何解决：通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。 关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口 应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。 优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。 缺点：使用命令模式可能会导致某些系统有过多的具体命令类。 使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。 注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:14","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"中介者模式 意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。 何时使用：多个类相互耦合，形成了网状结构。 如何解决：将上述网状结构分离为星型结构。 关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。 应用实例： 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。 优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。 缺点：中介者会庞大，变得复杂难以维护。 使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 注意事项：不应当在职责混乱的时候使用。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:15","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"观察者模式 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 如何解决：使用面向对象技术，可以将这种依赖关系弱化。 关键代码：在抽象类里有一个 ArrayList 存放观察者们。 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。 优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。 缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:16","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"迭代器模式 意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 主要解决：不同的方式来遍历整个整合对象。 何时使用：遍历一个聚合对象。 如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。 关键代码：定义接口：hasNext, next。 应用实例：JAVA 中的 iterator。 优点： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。 注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:17","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"备忘录模式 意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有\"后悔药\"可吃。 如何解决：通过一个备忘录类专门存储对象状态。 关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。 应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。 优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 使用场景： 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。 注意事项： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:18","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"解释器模式 意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 主要解决：对于一些固定文法构建一个解释句子的解释器。 何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 如何解决：构建语法树，定义终结符与非终结符。 关键代码：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。 应用实例：编译器、运算表达式计算。 优点： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。 缺点： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。 使用场景： 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。 注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:19","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"策略模式 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决：将这些算法封装成一个一个的类，任意地替换。 关键代码：实现同一个接口。 应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。 优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。 使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:20","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"访问者模式 意图：主要将数据结构与数据操作分离。 主要解决：稳定的数据结构和易变的操作耦合问题。 何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，使用访问者模式将这些封装到类中。 如何解决：在被访问的类里面加一个对外提供接待访问者的接口。 关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。 应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。 优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。 缺点： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。 使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，也不希望在增加新操作时修改这些类。 注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:21","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"状态模式 意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用：代码中包含大量与对象状态有关的条件语句。 如何解决：将各种具体的状态类抽象出来。 关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 应用实例： 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，‘钟是抽象接口’,‘钟A’等是具体状态，‘曾侯乙编钟’是具体环境（Context）。 优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对\"开闭原则\"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。 注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:22","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"模板模式 意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 主要解决：一些方法通用，却在每一个子类都重新写了这一方法。 何时使用：有一些通用的方法。 如何解决：将这些通用算法抽象出来。 关键代码：在抽象类实现，其他步骤在子类实现。 应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。 优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。 注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:23","tags":["设计模式","系统架构师"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["软件工程"],"content":"1. 定义问题与归结模型 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:1:0","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"1.1 问题分析 在问题定义上达成共识 问题概述，影响，结果，优点 理解问题的本质 因果鱼骨图（将问题写在右边的方框里，确定问题潜在原因的主要类别，用头脑风暴法寻找原因并归类） 帕累托图（明确问题，找出问题原因，选择评价标准和考察期限，收集各种原因发生的频率与费用数据，将原因按照发生的频率排列，将原因横轴频率纵轴） 确定项目干系人和用户 定义系统边界（上下文范围图，用例模型） 确定系统实现的约束 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:1:1","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"1.2 问题定义 目标（优势，度量，合理性，可行性，可达成性） 功能需求（注意二义性【同名异义词，代词】） 非功能需求（感官需求，易用性需求，性能需求，可操作性需求，可维护性和可移植性需求，安全性需求，文化和政策需求，法律需求，） ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:1:2","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"2 需求分析与软件设计 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:2:0","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"2.1 需求分析的任务与过程 问题识别，分析与综合，编制需求分析的文档，需求分析与评审 分类：功能需求，非功能需求，设计约束，业务需求，用户需求，系统需求 需求工程：开发，管理 分析方法：结构化分析方法，软系统方法，面向对象分析方法，面向问题分析 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:2:1","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"2.2 如何进行系统设计 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:2:2","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"2.3 软件设计的任务与活动 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:2:3","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"3 架构化分析与设计 是一种面向数据流的需求分析和设计方法，适用与分析设计大型数据处理系统 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:3:0","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"3.1 结构化分析 结构化分析工作步骤：研究“物质环境“；建立系统逻辑模型；划清人机界限 数据流图：过程；外部实体；数据存储；数据流；实时连接； 细化几率DFD部件 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:3:1","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"3.2 结构化设计 概要设计与详细设计的主要任务； 结构图； 程序流程图和盒图； PAD和PDL ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:3:2","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"3.3 模块设计 信息隐蔽原则 模块独立性原则 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:3:3","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"4 面向对象的分析与设计 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:4:0","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"4.1 面向对象的基本概念 对象与类：实体类，控制类，边界类 继承与泛化 多态与重载 模版类 消息与消息通信 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:4:1","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"4.2 面向对象分析 OOA/OOD方法 5个层次：主题，对象类，结构，属性，服务 5个步骤：标识对象类，标识结构与关联，划分主题，定义属性，定义服务 4个部分：设计问题域部分，设计人机交互部件，设计任务管理部分，设计数据管理部分 Booch方法 4个步骤：标识类和对象，确定类和对象的含义，标识关系，说明类的接口和实现 OMT方法 三大模型：对象模型，动态模型，功能模型 OOSE方法 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:4:2","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"4.3 统一建模语言 UML设计与基本概念 UML结构：构造块（建模元素，关系，图），公共机制（规格说明，修饰，公共分类，扩展机制），架构（逻辑视图，进程视图，实现视图，部署视图，用例视图） 用例图基础： 参与者，用例，包含和扩展。 类图和对象图基础： 类和对象（类的获取和命名，类的属性，类的操作） 类之间的关系（依赖关系，泛化关系，关联关系【聚合，组合】，实现关系） 多重性问题 类图 对象图 交互图基础：顺序图，通信图，定时图 状态图基础：状态，初始状态，结束状态，状态转移。 活动图基础：基本活动图，带泳道的活动图，对象流，信号 构件图基础：面向对象系统的物理方面进行建模1。 部署图基础：面向对象系统的物理方面进行建模2。 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:4:3","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"5 用户界面设计 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:5:0","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"5.1 用户界面设计的原则 置用户于控制之下 减少用户的记忆负担 保持界面的一致 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:5:1","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"5.2 用户界面设计过程 用户、任务、环境分析，界面设计，实现，界面确认 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:5:2","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"6 工作流设计 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:6:0","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"6.1 工作流设计概述 工作流，流程定义，流程实例，工作流管理系统，流程定义工具，参与者，活动，活动所有者，工作所有者，工作项。 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:6:1","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"6.2 工作流管理系统 流程定义工具，工作流执行服务，其他工作流执行服务，客户应用程序，被调用应用程序，管理和监控工具 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:6:2","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"7 简单分布式计算机应用系统的设计 基于实例协作 基于服务协助 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:7:0","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"8 系统运行环境的集成与设计 集中式设计：单计算机结构，集群结构，多计算机结构 分布式系统 C/S结构 多层结构 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:8:0","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"9 系统过渡计划 直接过度，并行过度，阶段过渡 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:9:0","tags":["软件工程","系统架构师"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["语言与平台"],"content":"概述 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:1:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"谈一谈对DDD的理解 DDD，领域驱动设计。就是通过领域来指导软件设计，是一种十分抽象的软件设计思想，它主要分为战略设计和战术设计。 战略方面，通过事件风暴进行领域模型的划分，划分出核心域，子域，支撑域，定义通用语言，划分出界限上下文。 在战术设计方面，ddd将架构分层，“松耦合，高内聚”是架构设计的整体思想。按照DDD思想，可以分为领域层，基础设施层，应用层，接口层。 接口层为前端用户提供api接口。基础设施层可以放一些第三方的服务，数据库连接等内容。 应用层是对领域服务的编排，是很薄的一层（目前我自己的架构，应用的是cqrs，所有的相关逻辑都是放在了应用层，而领域层只是放了实体，因为暂时还不是特别理解领域层的服务和事件都应该写什么）。 领域层包括实体，值对象，聚合根，领域服务，领域事件等内容。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:1:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"ASP.NET Core 比 ASP.NET 更具优势的地方是什么 跨平台 对框架没有依赖 处理请求效率更高 可以自我寄宿 轻量高性能 可以使用vs；vs code进行开发 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:1:2","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"ASP.NET Core 主要的特性有哪些 startup 类 依赖关系注入（服务） 中间件 主机 服务器 appsettings.json 配置 选项 环境（dev,stage,prod） Logging 路由 处理错误 发送HTTP请求 静态文件 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:1:3","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"Startup ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:2:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"什么是dot net core的startup class Startup class是dot net core应用的入口。 所有的dot net core应用必须有这个class。这个类用来配置应用。 这个类的调用是在program main函数里面进行配置的。类的名字可以自己定义。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:2:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"如何在controller中注入service ConfigureServices 添加 Service； services.TryAddTransient\u003cIDataAccess, DataAccess\u003e(); 在controller 添加注入 private readonly ILogManager _logManager; public HomeController(ILogManager logManager) { _logManager = logManager; } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:2:2","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"Startup 类包括哪些配置 ConfigureServices （可选择）方法以配置应用的服务。 服务是一个提供应用功能的可重用组件。 在 ConfigureServices 中注册服务，并通过依赖关系注入 (DI) 或 ApplicationServices 在整个应用中使用服务。 Configure 方法用于指定应用响应 HTTP 请求的方式。 可通过将中间件组件添加到 IApplicationBuilder 实例来配置请求管道。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:2:3","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"startup class的configure方法有什么作用 这个方法来定义整个应用如何响应HTTP请求。 它有几个比较重要的参数，application builder，Hosting environment, logo factory， 在这里我们可以配置一些中间件用来处理路径，验证和session等等。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:2:4","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"依赖注入 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"ASP.NET Core Filter如何支持依赖注入 可以通过全局注册，支持依赖注入； 通过TypeFilter(typeof(Filter)) 标记在方法，标记在控制器 通过ServiceType(typeof(Filter))标记在方法，标记在控制器，必须要注册Filter这类； TypeFilter和ServiceType的本质是实现了一个IFilterFactory接口； ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"介绍ASP.NET Core中服务的生命周期 Singleton 只有一个服务的实例被创建，这个实例，存储在内存中，可以在整个应用程序中使用。我们可以对一些初始化代价比较大的服务，使用Singleton模式。 services.AddSingleton\u003cIProductService, ProductService\u003e(); Scoped 范围内的，作用域生存期服务，以每个客户端请求(连接)一次的方式创建。可以这么理解：同一个请求中同一个IServiceProvider提供的对象是同一个。 services.AddSingleton\u003cIProductService, ProductService\u003e(); Transient 服务每次被请求的时候，都会创建一个服务实例，这种模式特别适合轻量级、无状态的服务。 services.AddSingleton\u003cIProductService, ProductService\u003e(); ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:2","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"什么是依赖注入 通过控制反转（Ioc），对象A在被创建的时候，由一个IOC容器来控制依赖，把类B通过构造函数，属性或工厂模式等方法，注入到类A内，实现对类A和类B的解耦。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:3","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"依赖注入有哪几种方式 属性注入 using Microsoft.Extensions.Logging; using Microsoft.Extensions.Logging.Abstractions; namespace MyApp { public class ProductService { public ILogger\u003cProductService\u003e Logger { get; set; } private readonly IProductRepository _productRepository; public ProductService(IProductRepository productRepository) { _productRepository = productRepository; Logger = NullLogger\u003cProductService\u003e.Instance; } public void Delete(int id) { _productRepository.Delete(id); Logger.LogInformation($\"Deleted a product with id = {id}\"); } } } 构造函数注入 public class ProductService { private readonly IProductRepository _productRepository; public ProductService(IProductRepository productRepository) { _productRepository = productRepository; } public void Delete(int id) { _productRepository.Delete(id); } } 接口注入 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:4","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"控制反转是什么 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:5","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"依赖注入有哪些著名的框架 Unity、autofac、spring.net、MEF、Injection、Asp.Net Core的ServiceCollection。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:6","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"依赖注入实现原理 实现DI，核心在于依赖注入容器IContainer，该容器具有以下功能 （容器）保存可用服务的集合 // 要用的特定对象、特定类、接口服务 （注册）提供一种方式将各种部件与他们依赖的服务绑定到一起；// Add…函数或containerBuilder.Register函数， （解析点）为应用程序提供一种方式来请求已配置的对象： 构造函数注入、属性注入. 运行时，框架会一层层通过反射构造实例，最终得到完整对象。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:7","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"中间件 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"什么是中间件（Middleware） 中间件是一种装配到应用管道以处理请求和响应的软件。 每个组件： 选择是否将请求传递到管道中的下一个组件。 可在管道中的下一个组件前后执行工作。 请求委托用于生成请求管道。 请求委托处理每个 HTTP 请求。 使用 RunMap 和 Use 扩展方法来配置请求委托。 可将一个单独的请求委托并行指定为匿名方法（称为并行中间件），或在可重用的类中对其进行定义。 这些可重用的类和并行匿名方法即为中间件，也叫中间件组件。 请求管道中的每个中间件组件负责调用管道中的下一个组件，或使管道短路。 当中间件短路时，它被称为“终端中间件”，因为它阻止中间件进一步处理请求。 public class Startup { public void Configure(IApplicationBuilder app) { app.Use(async (context, next) =\u003e { // Do work that doesn't write to the Response. await next.Invoke(); // Do logging or other work that doesn't write to the Response. }); app.Run(async context =\u003e { await context.Response.WriteAsync(\"Hello from 2nd delegate.\"); }); } } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"中间件的使用场景有哪些 身份验证，Session存储，日志记录等。 其实我们的Asp.net core项目中本身已经包含了很多个中间件。比如 身份认证中间件 UseAuthorization()等系列。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:2","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"列举官方常用的中间件 以下 Startup.Configure 方法将为常见应用方案添加中间件组件： 异常/错误处理 当应用在开发环境中运行时： 开发人员异常页中间件 (UseDeveloperExceptionPage) 报告应用运行时错误。 数据库错误页中间件报告数据库运行时错误。 当应用在生产环境中运行时： 异常处理程序中间件 (UseExceptionHandler) 捕获以下中间件中引发的异常。 HTTP 严格传输安全协议 (HSTS) 中间件 (UseHsts) 添加 Strict-Transport-Security 标头。 HTTPS 重定向中间件 (UseHttpsRedirection) 将 HTTP 请求重定向到 HTTPS。 静态文件中间件 (UseStaticFiles) 返回静态文件，并简化进一步请求处理。 Cookie 策略中间件 (UseCookiePolicy) 使应用符合欧盟一般数据保护条例 (GDPR) 规定。 用于路由请求的路由中间件 (UseRouting)。 身份验证中间件 (UseAuthentication) 尝试对用户进行身份验证，然后才会允许用户访问安全资源。 用于授权用户访问安全资源的授权中间件 (UseAuthorization)。 会话中间件 (UseSession) 建立和维护会话状态。 如果应用使用会话状态，请在 Cookie 策略中间件之后和 MVC 中间件之前调用会话中间件。 用于将 Razor Pages 终结点添加到请求管道的终结点路由中间件（带有 MapRazorPages 的 UseEndpoints）。 public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); app.UseDatabaseErrorPage(); } else { app.UseExceptionHandler(\"/Error\"); app.UseHsts(); } app.UseHttpsRedirection(); app.UseStaticFiles(); app.UseCookiePolicy(); app.UseRouting(); app.UseAuthentication(); app.UseAuthorization(); app.UseSession(); app.UseEndpoints(endpoints =\u003e { endpoints.MapRazorPages(); }); } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:3","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"中间件的执行顺序 异常/错误处理 HTTP 严格传输安全协议 HTTPS 重定向 静态文件服务器 Cookie 策略实施 路由 身份验证 会话 MVC ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:4","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"application builder的use和run方法有什么区别 这两个方法都在start up class的configure方法里面调用。都是用来向应用请求管道里面添加中间件的。 Use方法可以调用下一个中间件的添加，而run不会。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:5","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"dot net core 管道里面的map拓展有什么作用 可以针对不同的路径添加不同的中间件。 public class Startup { private static void HandleMapTest1(IApplicationBuilder app) { app.Run(async context =\u003e { await context.Response.WriteAsync(\"Map Test 1\"); }); } private static void HandleMapTest2(IApplicationBuilder app) { app.Run(async context =\u003e { await context.Response.WriteAsync(\"Map Test 2\"); }); } public void Configure(IApplicationBuilder app) { app.Map(\"/map1\", HandleMapTest1); app.Map(\"/map2\", HandleMapTest2); app.Run(async context =\u003e { await context.Response.WriteAsync(\"Hello from non-Map delegate. \u003cp\u003e\"); }); } } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:6","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"配置 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:5:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"ConfigurationBinder 的常用方法 GetValue GetSection GetChildren Exists AddJsonFile ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:5:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"日志 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:6:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"日志的级别有哪些 LogLevel “值” 方法 描述 Trace 0 LogTrace 包含最详细的消息。 这些消息可能包含敏感的应用数据。 这些消息默认情况下处于禁用状态，并且不应在生产中启用。 调试 1 LogDebug 用于调试和开发。 由于量大，请在生产中小心使用。 信息 2 LogInformation 跟踪应用的常规流。 可能具有长期值。 警告 3 LogWarning 对于异常事件或意外事件。 通常包括不会导致应用失败的错误或情况。 错误 4 LogError 表示无法处理的错误和异常。 这些消息表示当前操作或请求失败，而不是整个应用失败。 严重 5 LogCritical 需要立即关注的失败。 例如数据丢失、磁盘空间不足。 无 6 指定日志记录类别不应写入任何消息。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:6:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"路由 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:7:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"默认路由的配置和使用 public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddMvc(); } public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { app.UseMvc(routes =\u003e { routes.MapRoute( name: \"default\", template: \"{controller=Home}/{action=Index}/{id?}\"); }); } } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:7:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"配置多个默认路由 app.UseMvc(routes =\u003e { //New Route routes.MapRoute( name: \"about-route\", template: \"about\", defaults: new { controller = \"Home\", action = \"About\" } ); routes.MapRoute( name: \"default\", template: \"{controller=Home}/{action=Index}/{id?}\"); }); ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:7:2","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"配置标签(Attributes)为个方法或控制器指定路由 [Route(\"[controller]\")] public class AnalyticsController : Controller { [Route(\"Dashboard\")] public IActionResult Index() { return View(); } [Route(\"[action]\")] public IActionResult Charts() { return View(); } } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:7:3","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"配置RESTful路由 [Route(\"api/[controller]\")] public class ValuesController : Controller { // GET api/values [HttpGet] public IEnumerable\u003cstring\u003e Get() { return new string[] {\"hello\", \"world!\"}; } // POST api/values [HttpPost] public void PostCreate([FromBody] string value) { } // POST api/values/5 [HttpPost(\"{id}\")] public void PostUpdate(int id, [FromBody] string value) { } } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:7:4","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"配置路由器参数约束 [HttpGet(\"{id:int}\")] public string GetById(int id) { return \"item \" + id; } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:7:5","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"错误处理 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:8:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"Asp.Net Core中有哪些异常处理的方案 继承 Controller，重写 OnActionExecuted 使用 ActionFilterAttribute 使用 IExceptionFilter 使用 ExceptionHandler 自定义 Middleare 处理 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:8:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"词根(2565) 词根 含义 示例 -cel 动画序列中的单帧【词根】天空【后缀】表小称或“缩小” parcel(n.包裹，小包，邮包) -dom 【词根】家；房子；驯服；驯服【后缀】表示抽象名词 kingdom(n.王国；领域，界) -ed 埃德（男名）【词根】吃【后缀】形容词【后缀】 edible(n. 食品, 食物) -fic 【词根】做【后缀】表示“形成…的”，“产生…的” fiction(n.小说；虚构，杜撰) -ite 【词根】走【后缀】名词【后缀】;形容词【后缀】;动词【后缀】 computerite(n. 电脑迷（等于computernik）；电脑技术人员) -let vi.出租【后缀】表小称或“缩小”【词根】诱使 houselet（n. 小房子） -long adj. 长的；过长的【词根】长的【后缀】表示方向 prolong（vt. 延长；拖延（pro向前+long→向前长→延长）） -man n. 人；男人【词根】停留；手【后缀】表示“人” manual(n. 手册; 指南) -ment 【词根】思考；心智;记忆【后缀】表示抽象名词 mention(vt.\u0026n.提及，说起（ment+ion→有思考→想到，提到) -tic / tik/ n. 痉挛【词根】形容词【后缀】 dramatic（adj. 戏剧的；引人注目的；激动人心的） -ward n.病房；选区【词根】照顾，照料【后缀】表示方向 reward(n. [劳经] 报酬；报答；酬谢) *-al 【词根】滋养【前缀】总的【后缀】表示抽象名词 principal(a.主要的) *ac 【词根】酸的；尖锐的【前缀】＝ad-[用于c,k或q前] acid(adj. 酸的；讽刺的；刻薄的) accept(vt. 接受；承认；承担（ac往里，cept拿）) *ag / Ag/ a. 农业的【词根】行为；行动【前缀】转为动词 agent(作用因素,代理人(ag+ent表人或物=做的人=代理人)) *am / Am, Em/ 上午【词根】喜爱【前缀】不；无 amateur(n. 业余从事者; 粗通的人; 外行; 爱好者) *arch / a:tF/ n.拱【词根】首领；统治者【前缀】古代 anarchism（无政府主义的(an无+arch+ism主义)） *be v. 是; 值【词根】居住【前缀】变换为及物动词 tribe(n.部落，宗族) *cor 【医】 心脏, 心【词根】心【前缀】一同，合并 correspond(v 符合,通信(cor共同+respond回答=两人互相回答=通信)) *di 【词根】日【前缀】二 dial(n.钟面；拨号盘) *du 【计】 定义使用【词根】负债【前缀】二,双 duplicate(n. 复制品) *em 【词根】拿；买【前缀】进入某种状态，使成为… enamor(vt. 使迷恋，使倾心) *ev 【电】 电子伏特【词根】年龄；时代【前缀】良好 medieval(a.中世纪的（medi中间+eval→中间时代的→中世纪的）) *fort n.要塞，堡垒【词根】强壮的,运气【前缀】十四 fortune(n. 财富, 兴隆, 运气) *hom 【词根】人【前缀】相同 homogeneous(a.同类的；均匀的) *ig 【词根】行为；行动【前缀】不,非,无 navigation(n.航行；航海术；导航) *im 【词根】主张【前缀】不,非,无；向内,进入,朝 impossible(adj. 不可能的；不可能存在的) *mal 【医】 [疾]病【前缀】不舒服；与bene相反【词根】坏 malice(n.恶意；蓄意犯罪) *med 【词根】治疗【前缀】=mid中间 remedy(n.\u0026vt.治疗；补救) *mega 【计】 兆; 百万【词根】大【前缀】百万,兆 megalith(n. 巨石) *mis 【词根】送；释放【前缀】坏，错误，否定 misconduct(n. 不端行为；处理不当) *mon 等于Monday星期一【词根】劝告；吃【前缀】单一 monument(n. 纪念碑（monu警告，提醒+ment→提醒的东西→纪念碑）) *pan / pAn/n.平底锅【词根】面包【前缀】全；所有的 panacea(n. 灵丹妙药；万能药) *par n. 标准【词根】准备；相等的；出现；生【前缀】完全 parent(n. 父亲（或母亲）；父母亲；根源) *pel 【计】 象素【词根】驱动；驱赶【前缀】完全；彻底 repel(vt.拒绝；使厌恶) *peri n. 美丽仙女【词根】通过；尝试【前缀】周围；环绕 expert(n.专家) *pil 【词根】毛发；柱【前缀】完全；彻底 compile(vt.编辑，编制，搜集) *pur 【词根】纯粹的【前缀】为了…；代替…；赞成… pursuit(n.追赶；追求；事务) *sept / sept/ n. 氏族【前缀】七【词根】腐烂 septet(n. [计] 七位字节；七重奏) *sim 【前缀】单一；一个接一个【词根】相似 simply(ad.简单地；朴素地) *sum / sQm/n.总数, 和, 金额【前缀】下；次【词根】集结 resume(n. 摘要；[管理] 履历，简历) *sur 【词根】确定的；安全的【前缀】在下面,超过 survive(vt. 幸存；生还；幸免于（sur在下面+viv+e→在[事故]下面或下来→辛存） *tele n. 电视【词根】远【前缀】远距离 television(n.电视；电视机) *un 联合国【词根】一【前缀】不,无；相反的动作 unlimited(a.无限的；不定的) *ut 【词根】用【前缀】向外；超越；胜过 utmost(a.最远的) abl 【词根】：能力 able(adj. 能；[经管] 有能力的；能干的) abol 【词根】：废除 abolish(vt. 废除，废止；取消，革除) academ 【词根】：学术 academic（adj. 学术的；理论的；学院的） accoutr 【词根】：dress（穿着） accoutrement （n. 穿着；配备（等于accouterment）） acer 【词根】：苦, 酸, 尖 acerbic（adj. 尖刻的（等于acerb）；酸的；辛辣的） acerb adj. 尖锐的；酸涩的【词根】尖,酸,锐利 acerbate(adj. 恼怒的；粗鄙的) acet 【化】 次乙基; 乙酰【词根】sharp,sour尖,酸 acetimeter(n. 醋酸比重计) acid / 5Asid/ a.酸的【词根】酸的；尖锐的 acid(n.酸；酸的，酸性的) acm 【词根】：top（顶端） acme（n. 顶点，极点；最高点） acou 【词根】：听,闻 acoustics（n. 声学；音响效果，音质） acr 【词根】酸的；尖锐的 acrid(adj. 刺激的; 刻薄的; 苦的, 辣的) acri 【词根】：表示“尖，酸，锐利” acrid(adj. 刺激的; 刻薄的) act / Akt/ 表演【词根】行为；行动 react(vi.起反应；有影响) acu 【词根】：表示“尖，酸，锐利” acute(adj. 尖锐的; 剧烈的) add vi. 加；增加【词根】加 addendum(n. 补遗; 补篇; 追加; 附录) adelph 【词根】：兄弟 adelphogamy(n. 姊妹交配，同胞交配) adip 【词根】：fat（肥） adipose（adj. 脂肪的；肥胖的） adjut 【词根】：assist（帮助） adjutant（n. 副官，助手） advant 【词根】：ahead（前面） advantage（n. 优势；利益；有利条件） aeg 【词根】：山羊,保护、庇护 aegagrus(n.野山羊) aem 【词根】：血 anaemic(adj. 贫血的，患贫血症的；无活力的) aer 【医】 气压单位【词根】空气；天空 aerial(空气的(aeri+al表形容词)) aeri 【词根】：表示“空气，充气”等 aerial(adj. 航空的; 由飞机进行的; 飞机的; 空气的) aero adj.航空的。【词根】表示“空气，充气”等 aerospace(n. 航空宇宙) aesth 【词根】：发觉 aesthete(n. 唯美主义者；审美家) aesthet 【词根】感觉 aesthetics(n 美学(aesthet感觉+ics)) aestiv 【词根】夏天 aestivation(n. 度夏; 夏眠) agap 【词根】：爱 agape(n.神对世人的爱) agi 【词根】：表示摇动、行动、驱使、领导、引领等 agitate（vt. 摇动；骚动；使…激动) ago adv. 以前【词根】引导 pedagog(n. （小学）教师) agog adj. 兴奋的。【词根】：表示“引导” demagogue(n. 煽动者, 群众煽动者) agogue 【词根】领导者 demagogue(n 煽动者(dem人民+agogue=引导肉民者=煽动者)) agon n. 斗争；竞赛。【词根】：表示“挣扎，斗争” agony(n.极度痛苦; 临死的痛苦; 苦恼) agor 【词根】：市场 agora(n. 市场；集会) agr 【词根】田野，农田 agriculture(n.农业，农艺；农学) agri 【词根】田地，农田 agrimotor(农用拖拉机(agri+motor机动车)) agro n. 暴力行为。 【词根","date":"2021-08-03","objectID":"https://blog.gethin.online/english-root-full/:1:0","tags":["english"],"title":"英语词根","uri":"https://blog.gethin.online/english-root-full/"},{"categories":["语言与平台"],"content":"前后缀(10) 词根词缀 含义 示例 *-a 一【前缀】用于加强语气,不【后缀】表示抽象名词 atom（n 原子(a不+tom=不能在切割的小东西=原子)） *-al 【词根】滋养【前缀】总的【后缀】表示抽象名词 principal(a.主要的) *-an / An, En/ 一【前缀】无；非；缺乏【后缀】表示\"人” anarchy（无政府状态(an无+archy)） *-ant / Ant/ 蚂蚁【前缀】在前；相反【后缀】表示“人” sergeant（n. 警官, 军士） *-ar 【前缀】转为动词【后缀】表性质、大小状况、状貌 pedlar(n.(挨户兜售的)小贩) *-d 【前缀】：右或顺时针方向.【后缀】:构成某些动词的过去式等 D-glucose（n. 葡萄糖） *-e 【前缀】出,除去；超出【后缀】名词结尾e,无实意 eject(v.喷出；驱逐（e出+ject→扔出→喷出）) *-el 【前缀】进入某种状态，使成为【后缀】表小称或缩小 parcel(n.包裹，小包，邮包) *-en n. 半方,字母N【前缀】进入【后缀】起功能转换作用 encage(vt. 关在笼中；禁闭) *-es 【前缀】出自；超出;=ex【后缀】构成复数 escape（vt. 逃避，避免；被忘掉） *-in 在…里面【前缀】不,非,无【后缀】表示“集体活动” inaction(n. 不活动；迟钝) ","date":"2021-08-03","objectID":"https://blog.gethin.online/english-affix-full/:1:0","tags":["english"],"title":"英语词缀","uri":"https://blog.gethin.online/english-affix-full/"},{"categories":["语言与平台"],"content":"前缀(275) 词根词缀 含义 示例 *ab prep. 从, 自【前缀】 表示“偏离，脱离或离开”之义 abuse（滥用(ab+use用=用坏=滥用)） *abs 【前缀】离开，离去 abstract（抽象的,心不在焉的(abs+tract拉=被拉开=心不在焉)） *ac 【词根】酸的；尖锐的【前缀】＝ad-[用于c,k或q前] acid(adj. 酸的；讽刺的；刻薄的) accept(vt. 接受；承认；承担（ac往里，cept拿）) *acro 【前缀】：表示“最高，顶点，开头” acrobat杂技演员 *ad / Ad/ abbr.公元（后）【前缀】表示“向……”之义 adjust（v. 调节; 校正; 改变…以适应; 校准） *af 【前缀】表示动作的开始或结束；转为动词 affect(v 影响,感动(af使+fect=使人做=影响)) *after adv. 后来【前缀】表示“在…后面”，“在…以后” aftercare（n. 安置；病后的照顾调养） *ag / Ag/ a. 农业的【词根】行为；行动【前缀】转为动词 agent(作用因素,代理人(ag+ent表人或物=做的人=代理人)) *am / Am, Em/ 上午【词根】喜爱【前缀】不；无 amateur(n. 业余从事者; 粗通的人; 外行; 爱好者) *amb 【前缀】周围；二者 ambient(a.周围的，包围着的) *ambi 【前缀】二,双 ambition(n.雄心，抱负，野心) *amphi 【前缀】二,双 amphibian（n. 两栖动物, 水陆两用车） *ana / ‘B:nE/ n. 言论集, 语录【前缀】表示相似 analogue(n.类似物；同源语) *anci 【前缀】在前 ancient（a 古代的(anci+ent)） *andr 【前缀】：男 androgyne(n. 具有男女两性的人) *ante / ‘Anti/ n. 赌注vt. 下赌注【前缀】在前；先前,早于 anterior（adj. 前部的, 前面的; 较早的; 以前的; 在前的） *anti n. 反对者【前缀】在前；与post相反；相反；抵抗 anticipate(vt.预料，预期，期望) *ap 【前缀】远，离，分离 apart（adv. 分别地; 分离; 分成零件） *apo 【前缀】远,远离 apology（n 道歉,认错(apo离开+logy=退后一步说=道歉)） *arch / a:tF/ n.拱【词根】首领；统治者【前缀】古代 anarchism（无政府主义的(an无+arch+ism主义)） *arche 【前缀】主要的 archenemy（n. 主要敌人; 魔王; 大敌; 撒旦） *archi 【前缀】原始，旧，原，第一，主要 architect(n. 建筑师; 缔造者, 创造者; 设计师) *arist 【前缀】：最优越 aristocracy（n. 贵族；贵族统治；上层社会；贵族政治） *as / Az, Ez/ 作为【前缀】表示”一再”等加强意 assault(进攻(as+saul跳=跳起来=进攻)) *at / At, Et/ 在…(指时间的某一点)【前缀】转为动词 attain(vt.达到，获得，完成) *auth 【前缀】作者 author(n. 作者；作家；创始人) *be v. 是; 值【词根】居住【前缀】变换为及物动词 tribe(n.部落，宗族) *bene n. 祈祷；祝福【前缀】很好；与mal(e)相反 benefit(n.利益；恩惠；津贴) *bi 【前缀】生命，二 biography传记(bio+graphy写=写生命=传记) *bibl 【前缀】书 bible(n.基督教《圣经》) *bin / bin/n. 箱子，容器；二进制【前缀】双；二 binary（n. 一双, 一对; 二进制数; 双体; 双子星） *bon 【前缀】很好 bonus(n. 奖金; 红利) *bronch 【前缀】：支气管 bronchitis（n. [内科] 支气管炎) *by / bai/ 通过；经过【前缀】副,次要的；附近 bypass(n. 旁路, 支路 ) *caco 【前缀】坏的；不好的 cacophony(n 刺耳的声音(caco刺耳,坏+phony)) *cat / kAt/n.猫【前缀】下面 category(n.种类，类目；范畴) *cata n. 渺位【前缀】下面 catalogue(n目录,一览表(cata下面+logue在下面要说的话=目录)) *centi n. 厘；百分之一【前缀】百,百分之一 centigrade(a.百分度的) *chili n. 干辣椒, 辣椒粉【前缀】千 chiliad(n. 一千年) *circu 【前缀】环绕；在…周围 circuit(n.电路；环行；巡行) *circum n. 环绕，周围【前缀】周围,环绕 circumference(n.圆周，周长，圆周线) *co 【前缀】一起；共同；联合 cognate(a 同族的,同种的(cog同+nate=同出生的=同种的)) *col / kRl/ n. 出口, 山坳【计】 列【前缀】共同 collection(n.搜集，收集；收藏品) *com 【前缀】 表示“一起”、“共同”、“完全” incomplete(a.不完全的，未完成的) *con / kRn/vt. 精读；默记【前缀】表示\"共同” conflict(v 冲突,斗争(con共同+flict=共同打=冲突)) *contra / ‘kRntrE/ n. 反对, 相反【前缀】反对；逆 contravention(n. 违反; 矛盾; 违背) *contro 【前缀】反对；逆 controversy(n.争论，辩论，争吵) *cor 【医】 心脏, 心【词根】心【前缀】一同，合并 correspond(v 符合,通信(cor共同+respond回答=两人互相回答=通信)) *coun 【前缀】国家,全 country(n. 国家; 祖国; 国土; 故乡; 乡村) *counter / 5kauntE/ n.柜台【前缀】反对；逆 counteract(对抗,抵消(counter+act行为=反着行动=对抗)) *countrer 【前缀】:反对,相反 counterclaim(n. 反诉；反对要求) *crypt n. 土窖，地下室；腺窝【前缀】隐藏的 cryptogram(n.密码) *de 【化】 非对映体过量【前缀】去,反,解,往底下 detach(vt. 分离；派遣；使超然(（de分开+tach→把钉子上的分开→拆开）) *deca 【前缀】十 decade(n. 十年，十年期；十) *decem 【前缀】十 December（n. 十二月（古罗马时为十月）） *deci 【计】 十分之一【前缀】十 decimeter(n. [计量] 分米；公寸) *demi adj. 小的，一半的【前缀】半 demigod(n. 受崇拜的人，英雄人物；半神半人) *des 【前缀】脱，去，除，离，解除 dessert(n.甜点心) *di 【词根】日【前缀】二 dial(n.钟面；拨号盘) *dia 【前缀】在两者之间 dialog(n.对话，对白) *dif 【前缀】表示\"不，否定，分开” different(a.差异的；各种的) *dil 【前缀】表示否定、相反或相对；表示分离 dilate（vi. 扩大；膨胀；详述） *dis 【前缀】表示“分开； 分离； 否定； 不”之义 dismiss(vt. 解散；解雇；开除) *do / du:, du/ aux.v.vt.做,干,办【前缀】二；双 dozen(n. 十二个，一打) *dodeca 【前缀】十二 dodecagon（n. [数] 十二边形；十二角形） *du 【计】 定义使用【词根】负债【前缀】二,双 duplicate(n. 复制品) *duo / ‘dju:Eu/ n. 二重唱【前缀】二,双 duodenum(n.十二指肠) *dy 【前缀】：二, 两次, 两倍 dyon(n. [高能] 双荷子) *dys 【医】 不良, 困难, 障碍【前缀】不好的 dyslexia(n.阅读障碍（dys不良+lex+ia病→对词汇不良的病→阅读障碍）) *ec 【前缀】出,除去；超出 eclipse(n. (日，月)食) *ecto 【前缀】外面；…外 ectoderm(n. 外胚层，外细胞层) *ef 【前缀】表示“由…出来，自”之义 effluence(n. 流出；流出物；发射物) *em 【词根】拿；买【前缀】进入某种状态，使成为… enamor(vt. 使迷恋，使倾心) *endo 【前缀】在里面的 endocardial(adj. 心内膜的；心脏内的) *ennea 【前缀】九 enneasyllable(九音节) *enter / 5entE/vt.进入, 加入, 参加【前缀】在中间,肠道 entertain(vt. 娱乐；招待；怀抱(（enter在中间+tain→在[工作]中间拿) *ento 【前缀】在内 entotic（adj.耳中的） *eo 【前缀】黎明；开始 eobiont(n.原生物（生命起源中的一个假想阶段）) *ep 【前缀】在…上面；在…外面 epoch(n.新纪元；新时代；时间上的一点) *epi 【前缀】在…上面；在…外面 epicenter(n. 震中；中心) *eso 【前缀】内；在…里面 esoteric（adj","date":"2021-08-03","objectID":"https://blog.gethin.online/english-affix-full/:2:0","tags":["english"],"title":"英语词缀","uri":"https://blog.gethin.online/english-affix-full/"},{"categories":["语言与平台"],"content":"后缀(266) 词根词缀 含义 示例 -ability / E5biliti/ n.能力；才能【后缀】表示抽象名词 probability(n.可能性；概率) -able / 5eibl/ 能【后缀】表性质、大小状况、状貌 indispensable(a.必不可少的，必需的) -ably adv. 巧妙地【后缀】表副词，“能…地” miserably(ad. 悲惨地,糟糕地) -acal 【后缀】：用以构成的词仅用作形容词，＝-ac maniacal(adj. 疯狂的，狂热的；躁狂的) -ace / eis/ n.(纸牌中的)“A\"牌，爱司【后缀】表示地点 terrace(n.平台，阳台，露台) -acea 【后缀】:某些动物纲名、目名 crustacea(n.甲壳类) -aceae 【后缀】:许多植物科名 pinaceae((pl. )松科) -aceous 【后缀】：表形容词，“具有…特征的” foliaceous(a 叶状的(foli 叶+aceous;参考:foliage树叶)) -acious 【后缀】：表形容词，“有特征的，多…的” sagacious(a 精明的,智慧的(sag+aclous多…的=知道很多的=智慧的)) -acity 【后缀】：表名词，“有…倾向” capacity(n.容量；能力；能量) -acle 【后缀】： 表名词，“…物品，状态” manacle(n 手铐,束缚(man+acle东西=手上的东西=手铐)) -acy 【后缀】：表名词，“性质，状态” intimacy(n. 亲密, 亲昵行为) -ade n.果汁饮料【后缀】表示抽象名词 renegade(n. 背教者, 叛徒, 变节者) -ado n. 忙乱【后缀】构成名词，表示“人”,“物” desperado（n. 亡命之徒，暴徒（de+sper+ado人→无希望之人→亡命徒）） -ae 【后缀】：用于动植物名称后构成动植物科名；构成复数 algae(n. [植] 藻类；[植] 海藻) -age / eidV/ n. 年龄；时代；寿命【后缀】表示抽象名词 hostage(n.人质，抵押品) -ain 【后缀】表示“人” captain(n. 陆军上尉; 空军上尉; 海军上校; 船长; 首领) -aire n. 亚耳河（英国约克郡西部河流）【后缀】表示“人” millionaire(n.百分富翁，巨富) -algia 【后缀】：用于构成名词，表示“痛”，“疼痛” gastralgia(n. [内科] 胃痛) -ality 【后缀】：表名词，“状态，性质” frugality(n. 节约; 节俭; 朴素) -amin abbr. 最小声幅【后缀】表“物质” vitamin(n.维生素，维他命) -ance n. 状态；性质；情况【后缀】表示抽象名词 nuisance(n.讨厌的东西) -ancy 【后缀】表示抽象名词 inerrancy（n 无错误(in无+err+ancy=无错误)） -and conj. 和【后缀】附在动词后构成名词，表示“对象” viand（n. 食物；食品） -ane 【后缀】：构成名词，表示“烷,烷属烃” methane（n. [有化] 甲烷；[能源] 沼气） -aneity 【后缀】：表名词，表示“性质，状态” spontaneity(n. 自发性; 自然发生) -aneous 【后缀】：表形容词，表示“…有；…特征的” simultaneous(adj. 同时的, 同时发生的) -apsis n. 教堂东端之半圆室【后缀】情况，状态：另见-sis periapsis（n. [天] 近拱点） -ard 【后缀】表示“人” coward(n.懦夫；胆怯者) -arian 【后缀】构成形容词或名词 librarian(n. 图书馆员; 图书管理员) -arious 【后缀】：构成形容词，表示“与…有关的” hilarious(adj. 欢闹的；非常滑稽的；喜不自禁的) -arity 【后缀】：名词【后缀】，表示情况 similarity（n. 类似；相似点） -arium 【后缀】：表名词，“地点，场所” vivarium(n. 动物园, 植物园) -art / a:t/ 美术【词根】技巧；艺术【后缀】表示“人” artist(n.艺术家，美术家) -ary n. 氩【后缀】表性质、大小状况、状貌 elementary(a.基本的；初级的) -asm 【后缀】表示抽象名词 enthusiasm(n.热情，热心，热忱) -ass n. 屁股；驴子；蠢人【后缀】表示抽象名词 embarrass(vt.使窘迫，使为难) -ast 【后缀】：表名词，“…人，物” ballast(n. 压载物, 压舱物) -astic 【后缀】：形容词【后缀】，表示“…的” gymnastic（adj. 体操的，体育的） -ate v.eat的过去式【后缀】表示“人” delegate (n 代表(de+leg选+ate…选出来的人 …代表)) -atic 【后缀】：表形容词，“有…性质的” emblematic(adj. 象征的; 标记的) -ation 【后缀】构成抽象名词，表示“动作”,“过程”等 alteration（n. 修改，改变；变更） -ative 【后缀】：表形容词.“有…倾向（性质）的” sedative(n.镇静剂) -ator 【后缀】构成抽象名词，表示“做…动作的人”等 improvisator（n. 即席演奏者；即兴诗人） -atory 【后缀】:表形容词,‘有…性质的’;表名词,‘场所,地点’ propitiatory(adj. 安抚的; 取悦的; 劝解的) -berg / bE:g/ n. 冰山【后缀】山；村庄 iceberg(n. [地理] 冰山；显露部分) -cade n. 杜松【后缀】队伍，行列 motorcade(n. 汽车行列，车队) -ce 【后缀】表示抽象名词 province(n.领域，范围，职权) -cel 动画序列中的单帧【词根】天空【后缀】表小称或“缩小” parcel(n.包裹，小包，邮包) -cele 【后缀】：表示“腔”，“瘤”，“肿”，“膨出”，“疝” blastocele（n. 囊胚腔；分裂腔） -cian 【后缀】：表示人的职业 logician(n. 逻辑学家；论理学者) -cle 【后缀】表小称或“缩小” particle(n.粒子，微粒) -cul 【后缀】耕种,培养 cultivate(v. 培养; 耕作) -cule 【后缀】表小称或“缩小” animalcule(n. 微生物) -dom 【词根】家；房子；驯服；驯服【后缀】表示抽象名词 kingdom(n.王国；领域，界) -eal 【后缀】：形容词【后缀】，表示“似…的” funereal（adj. 悲哀的；送葬的；适合葬礼的） -ean 【后缀】：形容词【后缀】，表示“如…的” gigantean（adj.巨大的，庞大的） -ed 埃德（男名）【词根】吃【后缀】形容词【后缀】 edible(n. 食品, 食物) -ee 【后缀】表示“人” committee(n.委员会；全体委员) -een 【后缀】：构成名词，表示“可爱的人(或物)、小的人(或物)” colleen（n. 姑娘；（爱尔兰）少女） -eer adv.无论何时，曾经【后缀】表示“人” engineer(n. 工程师；工兵；火车司机) -efy 【后缀】：等于fy，表示“…化” liquefy（vt. 液化；溶解） -ella 【后缀】表小称或“缩小” umbrella(n.伞，雨伞) -emia 【后缀】表示“血液” anemia(n. 贫血；贫血症) -ence 【后缀】用于形容词后构成名词，通常是代替-ent existence(n. 存在，实在；生存，生活；存在物，实在物) -ency 【后缀】表示抽象名词,表示性质，状态，情况等 proficiency(n.熟练，精通) -ene 【后缀】：名词【后缀】，表示“烯”类 polyethylene（n. [高分子] 聚乙烯) -enne 【后缀】：表名词，“女性” comedienne(n. 女喜剧演员) -ent 【后缀】表性质、大小状况、状貌 dependent(adj. 依靠的；从属的（de+pend悬挂+ent)) -eous 【后缀】表形容词，“有…的” aqueous(adj. 水成的; 水的) -ept dj.聪明能干的【后缀】表示“适应，能力” adept(adj. 熟练的, 内行的; 拿手的) -er 【后缀】名词【后缀】;动词【后缀】;形容词及副词【后缀】 player(n.游戏的人；比赛者) -ere 【后缀】:指地方 here(adv. 在这里；此时) -erel 【后缀】：名词【后缀】，表示“小称” cockerel(n. （未满一年的）小公鸡；好斗的年轻人) -erly 【后缀】：形容词、副词【后缀】，表示“向…” easterly(adj. 在东方的；向东的) -ern 【后缀】表示方向;表示场所、地点 western(adj. 西方的，西部的；有西方特征的) -ery 【后缀】名词【后缀】,表示地点、状态等 printery（n. 印刷工厂） -esce 【后缀】动词【后缀】，表示“开始发生”，“开始成为” evanesce（vi. 消散；逐渐看不见） -escence 【后缀】:用以构成名词，相当于形容词【后缀】-escent coalescence(n. 合并；联合；接合) -","date":"2021-08-03","objectID":"https://blog.gethin.online/english-affix-full/:3:0","tags":["english"],"title":"英语词缀","uri":"https://blog.gethin.online/english-affix-full/"},{"categories":["语言与平台"],"content":"前缀 方向: ad【朝向】；by【旁边】；epi【旁边】；para【旁边】；circum【周围】；dia【居中】；en;em【进入】；inter;【之间】；per【穿过】；para【旁边】；tele【远距离】；trans【穿越】； de【下降】；hyper【之上】；hypo【之下】；sub;suc;suf;sup【在下方】；super【在上方】；over【上方】； under【下】；up【上】； fore【前面】；pre【前】；pro【向前】；post【后面】；with【向后】；ex;e;ec;ef;exo【向外】；il;im;in;ir【向内】；intro【向内】；intra【里面】；out【外】； ab【相反】；dif【分开】；dis【相反】；ob;op【反】；re【相反】；se【分开】；extra【超出】；sur【超过】； 数字： bi【二】；deca;dec;deci【十】；kilo【千】；octo;octa;octu【八】；tri【三】；twi【二】；hemi【一半】；mon;mono【单一】；multi【多】；poly【多】；uni【单一】； 意义： anti【反对】;arch【主要的；弧形 】；auto【自动】;be【使】；bene【好】；co【共同】；contra【对抗】； eco【生态】；geo【土地】；homo【相同】；mal【坏】；micro【微】mini【小】mis【错误】；sym;syn【共同的】；un【不】； a| 加强 ab;abs| 离开；相反；不 | away;from;not absent| abs+ent abduct| ab+duct abstract| abs+tract abuse| ab+use abnormal| ab+norm+al ab;ac;af;ap;ar;as;at| 加强 |to account accustom ad| 朝向 | to;toward admire| ad+mire adjoin| ad+join advertisement| ad+vert+ise+ment addict| ad+dict adorn| ad+orn anti| 反对 | aggainst antiaircraft| anti+aircraft antigas| anti+gas antimissile| anti+missile arch| 主要的；弧形 | chief architecture| archi+tect+ure archbishop| arch+bishop auto| 自己；自动 | self automatic| auto+matic automobile| auto+mobile autoalarm| auto+alarm be|使；加以；在| make behave beloved bene| 好 | good benefit| bene+fit benefactor| bene+fact+or benediction| bene+dict+ion bi| 二 | two bicycle| bi+cycle binoculars| bi+noculars bilingual| bi+lingu+al by| 旁边 | near byroad| by+road bypass| by+pass byline| by+line circum| 周围；环绕 | around circumambulate| circum+ambul+ate circumnavigate| circum+navigate circumscribe| circum+scribe circumspect| circum+spect circumvent| circum+vent co;com;con;cor;col| 共同；一起 | with;together coherent| co+her+ent combine| com+bine compassion| com+pass+ion congest| con+gest cooperation| co+oper+ation contra;contrp;counter| 反对；对抗 | against contradict| contra+dict contrary| contra+ry controversial| contro+versial counteract| counter+act counterattack| counter+attack de| 去除；下降 | down;away decline| de+cline decrepit| de+crep+it demeaning| de+mean+ing demerit| de+merit demolish| de+mol+ish deca;dec;deci | 十 | ten decade| deca+de decathlete| dec+athlete decible| deci+ble dia| 穿越；居中 | through;between diagnose| dia+gnose dialogue| dia+logue diameter| dia+meter dif| 分开；否定 | difference diffident dis| 相反的 | not disagree| dis+agree discourage| dis+cour+age dishonest| dis+honest dislike| dis+like dismiss| dis+miss eco| 生态；经济 |lift; ecological en;em| 使进入 | in embellish| em+bell+ish embrace| em+brace enclose| en+close enforce| en+force enhance| en+hance epi| 在…旁边；上；后 | epigram| epi+gram epigraph| epi+graph epilogue| epi+logue ex;e;ec;ef;exo| 向外 | out exclude| ex+clude exhale| ex+hale export| ex+port exposure| ex+pos+ure extend| ex+tend extra;extro| 超过 | over;beyond extracurricular| extra+curricul+ar extraordinary| extra+ordin+ary extravagant| extra+vag+ant fore| 前面 | before forearm| fore+arm forecast| fore+cast foredoom| fore+doom forefather| fore+father forehead| fore+head geo| 地；土地 | hemi| 一半 | half hemicycle| hemi+cycle hemisect| hemi+sect hemisphere| hemi+sphere homo| 相同 | of teh same homogenous| homo+genous homologous| homo+log+ous hyper| 在–之上；过度 | over hyperactive| hyper+act+ive hyperbolize| hyper+bol+ize hypercritical| hyper+crit+ical hypo| 在–之下；低于 | under hypogastric| hypo+gastr+ic hypotension| hypo+tens+ion hypothesis| hypo+thesis il;im;in;ir| 向内 | in immerse| im+merse immigrate| im+migrate implant| im+plant impress| im+press imprison| im+prison indoors| in+doors insert| in+sert insight| in+sight insist| in+sist invade| in+vade inter| 在–之间 | between;among interact| inter+act interfere| inter+fere interlace| inter+lace international| inter+nation+al interrupt| inter+rupt intro| 向内 | in introduce| intro+duc+e introvert| intro+vert intra| 在–里面 | in intracity| intra+city intragenic| intra+gene+ic intra-party| intra+party kilo| 千 kilogram| kilo+gram kilometer| kilo+meter kilowatt| kilo+watt mal;male| 坏 | bad malady malfunction| mal-function maltreat| mal+treat micro| 微 | small microorganism| micro+organism microscope| micro+scope","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:1:0","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"后缀 ","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:2:0","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"名词 acy;cy| 状态；特质 accuracy| ac+cur+acy conspiracy| con+spir+acy privacy| priv+acy age| 做；做之后的结果 advantage| ad+vant+age courage| cour+age marriage| marri+age al| 做；做之后的结果 approval| ap+prov+al capital| capit+al disposal| dis+pos+al ance;ence| （抽象）状态；做 assurance| as+sur+ance evidence| e+vid+ence occurrence| oc+curr+ence ancy;ency| （抽象）状态 constancy| con+sta+ancy fluency| flu+ency vacancy| vac+ancy ant;ent| 人；特质 accountant| ac+count+ant detergent| de+terg+ent opponent| op+pon+ent ar;er;or| 人；物 beggar| begg+ar calculator| calculat+or founder| found+er ate| 状态；人；物 advocate| ad+voc+ate certificate| certi+fic+ate illiterate| il+liter+ate action| 行为 accusation| ac+cuse+ation adaptation| ad+apt+ation congratulation| con+gratul+ation dom| 领域；状况 freedom| free+dom kingdom| king+dom wisdom| wise+dom ful| 分量 handful| hand+ful mouthful| mouth+ful ian;an| 人 magician| magic+ian pedestrian| ped+estr+ian vegetarian| vegetar+ian ic;ics| 学科 civics| civ+ics dramatics| dramat+ics dynamics| dynam+ics ice| 行动；状态 malice| mal+ice notice| not+ice prejudice| pre+jud+ice ing| 物；做 blessing| bless+ing earning| earn+ing following| follow+ing ion| 状态；行动 circulation| circu+lat+ion convention| con+vent+ion recession| re+cess+ion ism| 主义；行动 atheism| a+the+ism pessimism| pessim+ism racism| rac+ism ist| 人 chemist| chem+ist dentist| dent+ist terrorist| terror+ist ite| 人；物 appetite| ap+pet+ite dynamite| dynam+ite opposite| op+pos+ite ity;ty| 状态；性质 conformity| con+form+ity maturity| matur+ity novelty| nov+el+ty ive| 有–性质的；人 captive| capt+ive motive| mot+ive native| nat+ive ment| 行为；结果；手段 appointment| ap+point+ment displacement| dis+place+ment document| docu+ment ness| 状态；性质 illness| ill+ness kindness| kind+ness seriousness| serious+ness ory| 地点 factory| fact+ory laboratory| labo+rat+ory territory| terr+it+ory ship| 身份相关；动作 friendship| friend+ship leadership| lead+er+ship relationship| relat+ion+ship ure| 结果；做 departure| de+part+ure failure| fail+ure pleasure| pleas+ure y| 做之后的结果 discovery| dis+cover+y inquiry| in+quir+y mastery| master+y ","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:2:1","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"动词 ate| 导致；引发 en| 导致；使变成 er;or| 做 ify| 导致；引发 ize| 导致；引发 ure| 做 ","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:2:2","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"形容词 able;ible| 能够 al;ial;ical| 特质 ant;ent;ient| 有–性质的 ar;ary| 有–性质的 ate| 有–性质的 ed| 具–的特质 en| 物质 ful| 具有–特质 ic| 特质；–的 ile;ish| 具–特质 ive;ative;itive| 具–特质 less| 没有 ous;eous;ose;ious| 具–特质；和–相关 y| 状态；特质 ","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:2:3","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"副词 ly| 有–特质 ward| 朝–方向 wise| 和–有关 ","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:2:4","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"词根 abl;abili| 能 acid;acri;acrid;acu| 尖酸；锐利 act;ag| 做 aer;aero;aeri| 空气 agri;agro;agr| 田地，农田 alter(n);ali| 其它;改变 am;amor;amat| 爱 ambul| 行走 anim| 气息 ann(u)| 年 aqu| 水 arch(y)| 统治 arm| 武器 art(i)| 技巧 aud(i);audit| 听 aut;auto| 自己 av;avar;avi |渴望；鸟 ball;bol |抛；舞；球 ban| 禁止 bas| 低 bell;bel| 战争；打斗 bio| 生物 brev| 短 cad;cas;cid| 降落 cand| 白光 cant;cent| 唱歌 cap;capt;cept;ceive;cip;cup| 抓取 card;cord| 心脏；一致 cede;ceed;cess| 行进；走；让步 cent(i)| 一百 celer| 快速 centr(i)| 中心 cern;cert;cret| 确定；区别 chron| 长时间 cide| 杀害 close;clude;clus| 关闭 circ;cycl| 圆 civ| 公民 cit| 引用；唤起 claim;clam| 呼喊 clear;clar;clair| 清楚；明白 clin;cliv| 倾斜；斜坡 clos;clud;clus| 关闭 cord| 心 corp;corpor| 身体；团体 cover| 遮盖；盖子 creed;cred| 信任 cre;creas| 增长；产生 cruc;crus;crux| 十字；交叉 crypt| 秘密 cub;cumb| 躺 cur| 关心 dent| 牙齿 derm;dermat| 皮肤 dic;dict| 说；断言 dign| 值得；高贵 doc| 教 don;dit| 给予 du(o);dub;dou(b)| 二，双 dur| 持久；坚硬 duc;duct| 引导，带来 dyn;dynam| 力量 electr| 电 em;empt;ampl| 拿 equ;equi| 相等；平均 erg| 能量；活动 err| 漫游；犯错误 ev|年龄 fabl;fabul| 说 fac(t);fec(t);fic(t)| 做 fall;fail;fault| 犯错误；欺骗 fend;fens| 打击 fer| 带来；拿来 ferv| 热 fid| 相信；信念 fin| 范围；结束 flam;flagr| 火焰 flect;flex| 弯曲 flict| 打击 flor;flour| 花 flu| 流动 fore;fort| 强大 form| 形成；形式 found;fund| 基础 fract;frang| 打碎 frig;friger| 冷 frim| 坚定 fug| 逃 fus| 流；泻 gen(e);gener| 出产；产生；根源 gnos(t);gnor| 知道 gon| 角 grad;gress| 行进 grat;gree| 高兴 grav;griev| 重 greg| 群体 gress| 行走 habit| 居住 hap| 运气 her;hes| 粘附 hibit| 拿住 hydy;hydro| 水 idea;ideo| 思想；观点 imag| 想象 ject| 投掷 jur;juris| 发誓；法律 join(t);junct| 连接，结合 judg;judic| 判断 labor| 劳动 laps| 滑走 lav;luv;lut| 洗；冲洗 lect;lig| 选择；收集 lect;leg| 讲；读 lev;live| 提高；举起；变轻 liber| 自由；考虑 line| 直线；线条 liqu| 液体 liter| 字母；文字 loc| 地方 locu;log;loqu| 说话 long;leng| 长 lingu| 语言 maj| 大,伟大 man(i);manu| 手 mark;marc| 记号，符号 med(i);mid| 中间 mend| 修改 miss;mit| 发送 mount| 登上，升 mun(i)| 公共的 neg| 否认，拒绝 norm| 规则 nounc(i)| 讲，说 nov| 新的 oper| 工作 opt| 选择，视力，眼 part| 部分，分开 pass| 走，通过 part(i)| 父亲，祖国 pear| 看见 ped 足 pel;puls| 驱动，推 pend| 悬挂 phon(o)| 声音，嗓音 physi(o)| 自然 pict| 绘 place| 地方 plant| 种植 ple;plen(t);plet| 满，填满 port| 拿，运；部分，分开 prehend;prehens| 抓 press| 挤压；逼迫 prim;prem;prin| 第一，主要的 priv| 单个 proach;proxim| 接近靠近 prob;prov| 证明 prot| 运送；携带 pose| 放置 press| 按压 psych(o)| 心理，精神 quaint| 知道 quest;quir;quis;quer| 寻求，获得 quot| 引用；数目 radi| 光线 range| 行列；顺序 rest| 停留 rect;reg| 正，直 rud| 天然的，原始的 rupt| 破，断裂 san;sanit| 健康的 sacr| 神圣的 sati;satis;satur 足够的 scop| 观察，看；镜 scrib;script| 写 sect;seg| 切，割 secu;sequ;sue| 追随 sens;sent| 感觉；保持 set| 放，安置 sess;sid| 坐 sign| 记号，信号 simil;simul(t);sembl| 类似，一样 sist;sta| 站立 soci| 同伴；社会 sol(i)| 单独；太阳 spec(i)| 外观；种类 soect;spic;spec| 看 spher(o)| 球 spond;spons| 承诺，约定 st;sta(n);stant;stat| 站，立 stall| 放 strain;strict;string| 拉紧 struct| 建造，建立 sum;sumpt| 拿，取 sum(m)| 加 sur| 肯定；安全 tact;tag| 接触 tail| 剪切 tain;ten;tin| 拿住 techn(o)| 技术，技艺 tect| 盖上 tele| 远；电 temper;tempor| 时间或事件引起的现象 tend;tens| 伸展 test(i)| 测试，证据 them(o)| 热 toler| 容忍 touch| 摸碰 tort| 扭转 tract| 拉，拖 treat| 处理 tribute| 给予 trude;truse| 推 urb| 城市 vac;void| 空；缺乏 vail;val(u)| 价值，之，强壮 vers;vert| 转 view;vis;vid| 看；分开 viv(i);vit;vig| 生命 vol;volunt| 意志，意愿 ","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:3:0","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"必考核心词！378个雅思高频听力单词词汇表 引用：https://ieltsonlinetests.com/zh-hans/listening-tips/378-high-frequency-words-ielts-listening 0 1 2 3 4 校园类 图书馆 Shelf Librarian The stacks Return Fine Magazine Copier Overdue Reading room Reference room Periodical room Study lounge Catalogue Index Keyword Volume Library card Book reservation Periodical Quarterly Back issue Current issue Latest number Writing permission Check out Put on reserve 学生 Freshman Sophomore Junior student Senior student Bachelor Master Doctoral candidate Alumni/alumnus Post doctorate 老师 Lecturer Associate professor Supervisor Professor Dean Teaching assistant 上课及选课 Take the course Credit Register Drop the course Introductory course Advanced course Rank Syllabus Curriculum Seminar Elective/optional course Compulsory course Drop-out Makeup exam Psychology course Physics Computer course Computer science 读书 Book review Novel Press Publisher Publication Biography Editorial Extra copy Paperback edition Out of print Read selectively Get through a novel Plough through Read extensively 课余活动 Devote to Run for Candidate Vote Conflict Election campaign Campaign manager Participant The student’s union Chairman Speech contest Enroll Sign up for 生活交际类 购物消费 Convenience store Department store Mall Chain store Shopping list Supermarket Family size Receipt Outlet On sale Sell out Grocery store Out of stock In stock Customer Complaint Deliver Counter Closing time Balance Luxurious items Electronic product Stationery Digital video camera Past the prime 居家琐事 Housework Electric cooker Laundry Iron Vacuum cleaner Housemaid Housekeeper Housewife Keep an eye on Household expenses Keep down the cost Fix the dinner Budget In a mess Economical 日常交往 Leisure time Telephone booth Date Pay phone Call on sb. Long-distance call Take a message Hang up Keep contact Hold on Hospitable 工作商务类 求职面试 Job hunting Inexperienced Opportunity Want ads Unemployment Position Wage Opening/vacancy Full-time job Part-time job Inquiry Do odd jobs Consult Resume Application letter Fire Hire Recruit Interview Job-hopping Interviewee Take over Interviewer Appointment Impression Confident Turn down Have no match for 工作往来 On business Be involved in Appointment In charge of Client Compromise Get along with Proposal Assistance Branch Cooperation Transaction Bid Transfer 工作态度 Attitude Personality Overwork Determined Forgetful Diligent Wear out Perseverance Hang on Workaholic Workload Struggle Continuous exploration Hard-working 工作业绩 Recognition Tribute Achievement Pioneer Blaze a trail Symbol Legend 娱乐休闲类 文化艺术 Napkin Beverage Gardening Excursion Performance TV channels Horror movie Broadcast Live broadcast Documentary Violence movie Commercial advertisement Entertainment industry TV theater 外出就餐 Waiter/waitress Pork Beef steak Menu Raw Medium Done Dessert Snack Join sb. for dinner Appetizer Make a reservation Cutlery Loaf Buffet Staple Go dutch Regular dinner Mutton Change 个人健康类 疾病和症状 Epidemic Sore throat Bird flu Runny nose SARS Stomachache Infectious illness Toothache Symptom Allergy Sneeze Fracture Diabetes Have a temperature Dental decay 医院和医生 Attending/chief doctor consultant Infirmary Physician Surgeon Clinic Anesthetist 减肥锻炼 Put on weight Watch your diet Overweight On diet Lose weight Physical exercise 身体状况 In good shape In a fit state Out of shape Fit as a fiddle In poor shape Feel under the weather 旅行交通类 Travel agency Flight number Check in Motel Book the ticket Platform Hiking Hitch-hike Conductor Skiing Mineral bath Streetcar Resort Visa Express train High-speed train Shuttle Ferry Tube/underground Expressway/freeway Roundtrip 热点话题类 Prosperous Decline Depression Recession Collapse Bankrupt Monetary Circulation Financier Surplus Inflation Deflation Economic crisis Potential Cyberspace Multimedia Hacker Server 气象环境类 Recycled water Renewable energy Sewage treatment Recyclable Deforestation rate Water and soil erosion Temperature Muggy Humidity Breeze Climate trend Climate variation Climate warming Climate watch Climate-sensitive ac","date":"2021-07-23","objectID":"https://blog.gethin.online/ielts-usually/:1:0","tags":["english"],"title":"Ielts Usually","uri":"https://blog.gethin.online/ielts-usually/"},{"categories":["语言与平台"],"content":"英语六种构词法 派生法 英语构词法中在词根前面加前缀或在词根后面加后缀，从而构成一个与原单词意义相近或截然相反的新词的方法叫作派生法。 前缀 除少数英语前缀外，前缀一般改变单词的意义，不改变词性；英语后缀一般改变词类，而不引起词义的变化。 表示否定意义的前缀常用的有dis-, il-, im-, in-, ir-, mis-, non-, un-等，在单词的前面加这类前缀常构成与该词意义相反的新词。例如： agree同意→disagree不同意 fair公平的→unfair不公平的 possible可能的→impossible不可能的 understand理解→misunderstand误解 表示其他意义的前缀常用的有a-(多构成表语形容词), anti- (反对；抵抗), auto- (自动), co- (共同), en- (使), inter- (互相), re- (再；又), sub- (下面的；次；小), tele- (强调距离)等。例如： co-worker 同事，帮手 enlarge 使变大 cooperate 合作 rewrite 重写 subway 地铁 后缀 给单词加后缀也是英语构词的一种重要方法。后缀通常会改变单词的词性，构成意义相近的其他词性；少数后缀还会改变词义，变为与原来词义相反的新词。下面仅作简单介绍。 构成名词的后缀常用的有-ence，-(e)r/ -or (从事某事的人),-ese (某地人)，-ess (雌性)，-ian (精通……的人)，-ist (专业人员)，-ment (性质；状态)，-ness (性质；状态)，-tion(动作；过程)等。例如： differ不同于→difference区别 write写→writer作家 China中国→Chinese中国人 act表演→actress女演员 music音乐→musician音乐家 构成动词的后缀常用的有-(e)n (多用于形容词之后)，-fy (使……化)，-ize (使……成为)。例如： wide→widen加宽 beauty→beautify美化 pure→purify提纯 real→realize意识到 organ→organize组织 sharp→sharpen使变锋利 构成形容词的后缀常用的有-al，-able (有能力的)，-(a)n(某国人的)，-en (多用于表示材料的名词后)，-ern (方向的)，-ese(某国人的)，-ful，-(ic)al，-ish，-ive，-less (表示否定)，-like (像……的)，-ly，-ous，-some，-y (表示天气)等。例如： nature自然→natural自然的 reason道理→reasonable有道理的 America美国→American美国的 China中国→Chinese中国人的 gold金子→golden金的 east东→eastern东方的 child孩子→childish孩子气的 snow雪→snowy雪的 构成副词的常用后缀有-ly (主要用于形容词之后表示方式或程度)，-ward(s) (主要用于表示方位的词之后表示方向)。例如： angry生气的→angrily生气地 to到→towards朝……，向…… east东方→eastward向东 构成数词的后缀有-teen (十几)，-ty (几十)，-th (构成序数词)。例如： six六→sixteen十六→sixteenth第十六 four四→forty四十→fortieth第四十 合成法 英语构词法中把两个单词连在一起合成一个新词，前一个词修饰或限定后一个词，这样的方法就是合成法。 合成名词 名词＋名词 weekend 周末 名词＋动词 daybreak 黎明 名词＋动名词 handwriting 书法 名词＋及物动词＋er／or pain-killer 止痛药 名词＋介词＋名词 sister-in-law 嫂子 代词＋名词 she-wolf 母狼 动词＋名词 typewriter 打字机 动名词＋名词 reading-room 阅览室 现在分词＋名词 flying-fish 飞鱼 形容词＋名词 freshman 大一新生 副词＋动词 outlook 景色，风光 介词＋名词 afterbrain 后脑 合成形容词 名词＋形容词 bloodred 血红的 名词＋现在分词 French-speaking 讲法语的 名词＋to＋名词 one-to-one 一对一的 名词＋过去分词 man-made 人造的 数词＋名词 one-way 单行道的 数词＋名词＋形容词 three-year-old 三岁的 数词＋名词＋ed ten-storeyed 十层的 动词＋副词 one-off 一次性的 形容词＋名词 high-quality 高质量的 形容词＋名词＋ed noble-minded 高尚的 形容词＋形容词 light-green 浅绿色的 形容词＋现在分词 ordinary-looking 相貌一般的 副词＋形容词 ever-green 常青的 副词＋现在分词 hard-working 辛勤的 副词＋过去分词 well-known 著名的 副词＋名词 fast-food 专门提供快餐服务的 介词＋名词 indoor 室内的 合成动词 名词＋动词 sleep-walk 梦游 形容词＋动词 white-wash 粉刷 副词＋动词 overwhelm 压倒，制服 合成副词 形容词＋名词 hotfoot 匆忙地 形容词＋副词 everywhere 到处 副词＋副词 however 尽管如此 介词＋名词 beforehand 事先 介词＋副词 forever 永远 合成代词 代词宾格＋self herself 她自己 物主代词＋self myself 我自己 形容词＋名词 anything 一切 合成介词 副词＋名词 outside 在……外面 介词＋副词 within 在……之内 副词＋介词 into 进入 混合法 英语构词还可以将两个词混合或各取一部分紧缩而成一个新词，前半部分表属性，后半部分表主体。这样的英语构词法就是混合法。 ex. news broadcast→newscast 新闻广播 television broadcast→telecast 电视播送 smoke and fog→smog 烟雾 photo and graphy→photography 摄影，摄影术 helicopter airport→heliport 直升飞机场 转化法 英语构词法中把一种词性用作另一种词性而词形不变的方法叫作转化法，有的名词可以作动词，有的形容词可以作副词或动词。 1. 动词转化为名词 1. **意思没有变化**，例如：I think we'd better finish the talk now.我想我们的谈话最好现在结束。 2. **意思有一定变化**，例如：He is a man of strong build.他是一个体格健壮的汉子。 3. **构成短语**，例如：Let's have a look first. 我们先看一下吧。 2. 名词转化为动词 1. **表示物体的**，如：Have you booked the ticket?你订好票了吗? 2. **表示身体部位的**，如：Hand in your papers please.请把你们的试卷交上来。 3. **表示一类人的**，如：She nursed her husband back to health.她看护丈夫，使他恢复了健康。 4. **抽象名词**，如：We breakfasted together.我们在一起吃了早餐。 3. 形容词转化为动词 **少数形容词可以转化为动词**。例如：We will try our best to better our living conditions.我们要尽力改善我们的生活状况。 4. 副词转化为动词 **有少数副词可以转化为动词**。例如：Murder will out.恶事终必将败露。 5. 形容词转化为名词 1. **表示颜色的形容词常可转化为名词**，如：The girl in black appears very beautiful.那个穿黑衣服的女孩子看上去非常漂亮。 2. **一些形容词如old, young, poor, rich, wounded, injured等与the连用，表示一类人，作主语时，谓语用复数**，如：We don't belong to the rich, but we dong't belong to the poor either. 我们不是有钱人，但我们也不是穷人。 截短法 将单词缩写，词义和词性保持不变的英语构词法称为截短法，主要有截头、去尾、截头去尾等形式。 1. 截头 telephone→phone airplane→plane 2. 去尾 mathematics→maths examination→exam kilogram→kilo laboratory→lab taxicab→taxi 3. 截头去尾 influenza→flu refrigerator→fridge 缩写法 用单词首尾字母组成一个新词的英语构词法叫做首尾字母缩略法。这种形式的英语构词生成的新词，读音主要有两种形式，即各字母分别读音；作为一个单词读音。 ex. Testing of English as a Foreign Language→TOEFL托福 Teach English ","date":"2021-07-12","objectID":"https://blog.gethin.online/language-and-platformlanguage-and-platform/:0:1","tags":["english"],"title":"英语构词法","uri":"https://blog.gethin.online/language-and-platformlanguage-and-platform/"},{"categories":["云上漫谈"],"content":" 云上基础架构 Iaas \u0026 Paas \u0026 Saas 虚拟机和容器 Docker \u0026 Kubernetes 基础架构的关注点 Azure Kubernets Service - AKS ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:0:0","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"Iaas \u0026 Paas \u0026 Saas IaaS 基础架构即服务， 硬件相关的部分由第三方运营，如服务器，存储，网卡等。其他由拥有者来维护。 PaaS 平台即服务，部分与应用无关的部分由第三方运营，自己的应用程序是基于第三方提供的平台来进行开发维护，但数据和应用程序由拥有者本人来进行管理。 SaaS 软件即服务，将所有的部分都交给第三方管理，拥有者本身只需要基于应用程序进行配置或是二次开发。 啥是 azure-paas ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:1:0","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"虚拟机和容器 虚拟机，用传统开发和部署的方式来运行在服务器上，如IIS，Tomcat等 为什么要选用容器，容器有什么优势么？ 平台独立，一次build，可以运行在各个平台。 资源的效率和利用率比较高 有效的隔离性和可分享性 速度很快，可以在短时间内进行创建，复制和销毁 可以实现平滑的伸缩 操作便捷 改进开发人员的生产力和开发流程 语言独立性 ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:2:0","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"Docker \u0026 Kubernetes Docker是时下流行的来实现容器的一种方式。关于容器编排，市场上还有其他的方式，如Azure Service Fabric，Amazon Elastic Container Service 那么我们为什么要选用K8S? 容器编排 非常适合采用多云方式进行 大规模部署和更新应用程序，以加快产品上市时间（水平自动缩放，滚动更新，Canary部署） 天然支持云原生应用 降低基础设施成本 它可以在本地或混合环境中运行 您可以将Kubernetes集群从一个托管供应商移动到另一个托管供应商，而无需更改（几乎）任何部署和管理过程。 零停机时间部署，容错，高可用性，扩展，调度和自愈功能在Kubernetes中具有重要价值。 ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:3:0","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"基础架构的关注点 服务注册 服务发现 监控 限流 路由 负载均衡 超时重试 熔断 服务降级 故障迁移 ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:4:0","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"Azure Kubernets Service -AKS ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:5:0","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"1. 第一步 AKS云原生基本概念 - Key Words Pod: K8S 基本单位，一个Pod相当于一个容器 Node： 一个节点相当于一台服务器 Replication Controller： 弹性伸缩管理器 Service 服务，作为K8S内部调用的一个服务，使用标签选择符标识的一组Pod Namespace，命名空间，逻辑隔离级别 Ingress，应用程序入口，通常用来将内部service公开给外部使用的路由。 Deployment，一个 Deployment 控制器为 Pods和ReplicaSets提供声明式的更新能力。 StatefulSet 用来管理 Deployment 和扩展一组 Pod，并且能为这些 Pod 提供_序号和唯一性保证_。 DaemonSet 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。 Job 会创建一个或者多个 Pods，并确保指定数量的 Pods 成功终止 ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:5:1","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"2. 使用三方组件来改进系统 Helm, Traefik, Kubeapps, Prometheus, Grafana, ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:5:2","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"3. 使用服务网格 (Istio) 来进行微服务管理 Gateway \u0026 Virtual Service Cert Kiali \u0026 Grafana 使用 CI/CD 来部署你的系统. Azure DevOps Scaling 智能路由与金丝雀发布 https://docs.microsoft.com/en-us/azure/aks/servicemesh-istio-scenario-routing?pivots=client-operating-system-linux ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:5:3","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["语言与平台"],"content":"CSS 语法 /*这是个注释*/ p {color:red;text-align:center;} ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:1:0","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"CSS 选择器 ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:2:0","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"id选择器 #para1 { text-align:center; color:red; } ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:2:1","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"class 选择器 .center {text-align:center;} ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:2:2","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"css样式表 ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:0","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"外部样式表(External style sheet) /* mystyle.css */ hr {color:sienna;} p {margin-left:20px;} body {background-image:url(\"/images/back40.gif\");} /* html*/ \u003chead\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"\u003e \u003c/head\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:1","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"内部样式表(Internal style sheet) \u003chead\u003e \u003cstyle\u003e hr {color:sienna;} p {margin-left:20px;} body {background-image:url(\"images/back40.gif\");} \u003c/style\u003e \u003c/head\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:2","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"内联样式(Inline style) \u003cp style=\"color:sienna;margin-left:20px\"\u003e这是一个段落。\u003c/p\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:3","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"多重样式优先级 （内联样式）Inline style \u003e （内部样式）Internal style sheet \u003e（外部样式）External style sheet \u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:4","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"盒子模型 ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:5","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"分组选择器 h1,h2,p { color:green; } ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:6","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"嵌套选择器 p{ }: 为所有 p 元素指定一个样式。 .marked{ }: 为所有 class=\"marked” 的元素指定一个样式。 .marked p{ }: 为所有 class=\"marked” 元素内的 p 元素指定一个样式。 p.marked{ }: 为所有 class=\"marked” 的 p 元素指定一个样式。 p { color:blue; text-align:center; } .marked { background-color:red; } .marked p { color:white; } p.marked{ text-decoration:underline; } ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:7","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"隐藏元素 visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。 display:none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 块元素是一个元素，占用了全部宽度，在前后都是换行符。 内联元素只需要必要的宽度，不强制换行。 块元素：\u003ch1\u003e \u003cp\u003e \u003cdiv\u003e 内联元素 \u003cspan\u003e \u003ca\u003e 如何改变一个元素显示 li {display:inline;} span {display:block;} ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:8","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"Position(定位) static 定位 HTML 元素的默认值，即没有定位，遵循正常的文档流对象。 fixed 定位 元素的位置相对于浏览器窗口是固定位置。 即使窗口是滚动的它也不会移动。 relative 定位 相对定位元素的定位是相对其正常位置。 absolute 定位 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于\u003chtml\u003e。 sticky 定位 sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。 position: sticky; 基于用户的滚动位置来定位。 粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。 重叠的元素 元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素 z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面） ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:9","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"Float(浮动) CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。 img { float:right; } 元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。 .text_line { clear:both; } ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:10","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"CSS 布局 - 水平 \u0026 垂直对齐 元素居中对齐： margin: auto; 文本居中对齐: text-align: center; 图片居中对齐：margin: auto; 左右对齐 - 使用定位方式: position: absolute;right: 0px; 左右对齐 - 使用 float 方式：float: right; 垂直居中对齐 - 使用 padding: padding: 70px 0; text-align: center 垂直居中 - 使用 line-height: line-height: 1.5; 垂直居中 - 使用 position 和 transform：position: absolute;transform: translate(-50%, -50%); ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:11","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"组合选择符 后代选择器(以空格 分隔) 子元素选择器(以大于 \u003e 号分隔） 相邻兄弟选择器（以加号 + 分隔） 普通兄弟选择器（以波浪号 ～ 分隔） ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:12","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"伪类(Pseudo-classes) \u0026 伪元素 selector:pseudo-class {property:value;} selector:pseudo-element {property:value;} ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:13","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"导航栏、下拉菜单、提示工具、图片廊、图像透明、图像拼合、表单、网页布局 参考：https://www.runoob.com/css/css-navbar.html ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:14","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"属性选择器 [title] { color:blue; } ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:15","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"CSS 基础 属性 描述 CSS 背景 background 简写属性，作用是将背景属性设置在一个声明中。 background-attachment 背景图像是否固定或者随着页面的其余部分滚动。 background-color 设置元素的背景颜色。 background-image 把图像设置为背景。 background-position 设置背景图像的起始位置。 ackground-repeat 设置背景图像是否及如何重复。 CSS 文本格式 color 设置文本颜色 direction 设置文本方向。 letter-spacing 设置字符间距 line-height 设置行高 text-align 对齐元素中的文本 text-decoration 向文本添加修饰 text-indent 缩进元素中文本的首行 text-shadow 设置文本阴影 text-transform 控制元素中的字母 unicode-bidi 设置或返回文本是否被重写 vertical-align 设置元素的垂直对齐 white-space 设置元素中空白的处理方式 word-spacing 设置字间距 CSS字体 font 在一个声明中设置所有的字体属性 font-family 指定文本的字体系列 font-size 指定文本的字体大小 font-style 指定文本的字体样式 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 指定字体的粗细。 链接样式 a:link 正常，未访问过的链接 a:visited 用户已访问过的链接 a:hover 当用户鼠标放在链接上时 a:active 链接被点击的那一刻 CSS列表属性 list-style 简写属性。用于把所有用于列表的属性设置于一个声明中 list-style-image 将图像设置为列表项标志。 list-style-position 设置列表中列表项标志的位置。 list-style-type 设置列表项标志的类型。 CSS 盒子模型 Margin(外边距) 清除边框外的区域，外边距是透明的。 Border(边框) 围绕在内边距和内容外的边框。 Padding(内边距) 清除内容周围的区域，内边距是透明的。 Content(内容) 盒子的内容，显示文本和图像。 CSS 边框属性 border 简写属性，用于把针对四个边的属性设置在一个声明。 border-style 用于设置元素所有边框的样式，或者单独地为各边设置边框样式。 border-width 简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。 border-color 简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。 CSS 尺寸 height 设置元素的高度。 line-height 设置行高。 max-height 设置元素的最大高度。 max-width 设置元素的最大宽度。 min-height 设置元素的最小高度。 min-width 设置元素的最小宽度。 width 设置元素的宽度。 CSS Overflow visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 CSS 伪类 :checked 选择所有选中的表单元素 :disabled 选择所有禁用的表单元素 :empty 选择所有没有子元素的p元素 :enabled 选择所有启用的表单元素 :first-of-type 选择的每个 p 元素是其父元素的第一个 p 元素 :in-range 选择元素指定范围内的值 :invalid 选择所有无效的元素 :last-child 选择所有p元素的最后一个子元素 :last-of-type 选择每个p元素是其母元素的最后一个p元素 :not(selector) 选择所有p以外的元素 :nth-child(n) 选择所有 p 元素的父元素的第二个子元素 :nth-last-child(n) 选择所有p元素倒数的第二个子元素 :nth-last-of-type(n) 选择所有p元素倒数的第二个为p的子元素 :nth-of-type(n) 选择所有p元素第二个为p的子元素 :only-of-type 选择所有仅有一个子元素为p的元素 :only-child 选择所有仅有一个子元素的p元素 :optional 选择没有\"required\"的元素属性 :out-of-range 选择指定范围以外的值的元素属性 :read-only 选择只读属性的元素属性 :read-write 选择没有只读属性的元素属性 :required 选择有\"required\"属性指定的元素属性 :root 选择文档的根元素 :target 选择当前活动#news元素(点击URL包含锚的名字) :valid 选择所有有效值的属性 :link 选择所有未访问链接 :visited 选择所有访问过的链接 :active 选择正在活动链接 :hover 把鼠标放在链接上的状态 :focus 选择元素输入后具有焦点 :first-letter 选择每个\u003cp\u003e 元素的第一个字母 :first-line 选择每个\u003cp\u003e 元素的第一行 :first-child 选择器匹配属于任意元素的第一个子元素的 \u003cp\u003e 元素 :before 在每个\u003cp\u003e元素之前插入内容 :after 在每个\u003cp\u003e元素之后插入内容 :lang(language) 为\u003cp\u003e元素的lang属性选择一个开始值 CSS伪元素 :link 选择所有未访问链接 :visited 选择所有访问过的链接 :active 选择正在活动链接 :hover 把鼠标放在链接上的状态 :focus 选择元素输入后具有焦点 :first-letter 选择每个\u003cp\u003e 元素的第一个字母 :first-line 选择每个\u003cp\u003e 元素的第一行 :first-child 选择器匹配属于任意元素的第一个子元素的 \u003cp\u003e 元素 :before 在每个\u003cp\u003e元素之前插入内容 :after 在每个\u003cp\u003e元素之后插入内容 :lang(language) 为\u003cp\u003e元素的lang属性选择一个开始值 媒体类型 all 用于所有的媒体设备。 aural 用于语音和音频合成器。 braille 用于盲人用点字法触觉回馈设备。 embossed 用于分页的盲人用点字法打印机。 handheld 用于小的手持的设备。 print 用于打印机。 projection 用于方案展示，比如幻灯片。 screen 用于电脑显示器。 tty 用于使用固定密度字母栅格的媒体，比如电传打字机和终端。 tv 用于电视机类型的设备。 计数器 content 使用 ::before 和 ::after 伪元素来插入自动生成的内容 counter-increment 递增一个或多个值 counter-reset 创建或重置一个或多个计数器 ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:4:0","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"CSS3 基础 ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:5:0","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"图片、按钮、分页、框大小、弹性盒子、多媒体查询 参考：https://www.runoob.com/css3/css3-images.html ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:5:1","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"基础属性如下 属性 描述 边框 border-image 设置所有边框图像的速记属性。 border-radius 一个用于设置所有四个边框- *-半径属性的速记属性 box-shadow 附加一个或多个下拉框的阴影 圆角 border-radius 所有四个边角 border---radius 属性的缩写 border-top-left-radius 定义了左上角的弧度 border-top-right-radius 定义了右上角的弧度 border-bottom-right-radius 定义了右下角的弧度 border-bottom-left-radius 定义了左下角的弧度 背景 background-clip 规定背景的绘制区域。 background-origin 规定背景图片的定位区域。 background-size 规定背景图片的尺寸。 渐变 background-image: linear-gradient(direction, color-stop1, color-stop2, ...); 线性渐变 background-image: linear-gradient(angle, color-stop1, color-stop2); 角度渐变 background-image: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); 透明度 background-image: repeating-linear-gradient(red, yellow 10%, green 20%); 重复线性渐变 background-image: radial-gradient(shape size at position, start-color, ..., last-color); 径向渐变 background-image: radial-gradient(circle, red, yellow, green); 设置形状 closest-side、farthest-side、closest-corner、farthest-corner 不同尺寸大小关键字 background-image: repeating-radial-gradient(red, yellow 10%, green 15%); 重复的径向渐变 新文本 hanging-punctuation 规定标点字符是否位于线框之外。 punctuation-trim 规定是否对标点字符进行修剪。 text-align-last 设置如何对齐最后一行或紧挨着强制换行符之前的行。 text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。 text-justify 规定当 text-align 设置为 “justify” 时所使用的对齐方法。 text-outline 规定文本的轮廓。 text-overflow 规定当文本溢出包含元素时发生的事情。 text-shadow 向文本添加阴影。 text-wrap 规定文本的换行规则。 word-break 规定非中日韩文本的换行规则。 word-wrap 允许对长的不可分割的单词进行分割并换行到下一行。 新转换属性 transform 适用于2D或3D转换的元素 transform-origin 允许您更改转化元素位置 transform-style 规定被嵌套元素如何在 3D 空间中显示。 perspective 规定 3D 元素的透视效果。 perspective-origin 规定 3D 元素的底部位置 backface-visibility 定义元素在不面对屏幕时是否可见。 2D 转换方法 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 translate(x,y) 定义 2D 转换，沿着 X 和 Y 轴移动元素。 translateX(n) 定义 2D 转换，沿着 X 轴移动元素。 translateY(n) 定义 2D 转换，沿着 Y 轴移动元素。 scale(x,y) 定义 2D 缩放转换，改变元素的宽度和高度。 scaleX(n) 定义 2D 缩放转换，改变元素的宽度。 scaleY(n) 定义 2D 缩放转换，改变元素的高度。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 skew(x-angle,y-angle) 定义 2D 倾斜转换，沿着 X 和 Y 轴。 skewX(angle) 定义 2D 倾斜转换，沿着 X 轴。 skewY(angle) 定义 2D 倾斜转换，沿着 Y 轴。 3D 转换方法 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate3d(x,y,z) 定义 3D 转化。 translateX(x) 定义 3D 转化，仅使用用于 X 轴的值。 translateY(y) 定义 3D 转化，仅使用用于 Y 轴的值。 translateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 定义 3D 缩放转换，通过给定一个 X 轴的值。 scaleY(y) 定义 3D 缩放转换，通过给定一个 Y 轴的值。 scaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿 X 轴的 3D 旋转。 rotateY(angle) 定义沿 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿 Z 轴的 3D 旋转。 perspective(n) 定义 3D 转换元素的透视视图。 过渡属性 transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。默认是 0。 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 transition-delay 规定过渡效果何时开始。默认是 0。 动画属性 @keyframes 规定动画。 animation 所有动画属性的简写属性。 animation-name 规定 @keyframes 动画的名称。 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 animation-fill-mode 规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。 animation-delay 规定动画何时开始。默认是 0。 animation-iteration-count 规定动画被播放的次数。默认是 1。 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 多列属性 column-count 指定元素应该被分割的列数。 column-fill 指定如何填充列 column-gap 指定列与列之间的间隙 column-rule 所有 column-rule-* 属性的简写 column-rule-color 指定两列间边框的颜色 column-rule-style 指定两列间边框的样式 column-rule-width 指定两列间边框的厚度 column-span 指定元素要跨越多少列 column-width 指定列的宽度 columns column-width 与 column-count 的简写属性。 用户界面特性 appearance 允许您使一个元素的外观像一个标准的用户界面元素 box-sizing 允许你以适应区域而用某种方式定义某些元素 icon 为创作者提供了将元素设置为图标等价物的能力。 nav-down 指定在何处使用箭头向下导航键时进行导航 nav-index 指定一个元素的Tab的顺序 nav-left 指定在何处使用左侧的箭头导航键进行导航 nav-right 指定在何处使用右侧的箭头导航键进行导航 nav-up 指定在何处使用箭头向上导航键时进行导航 outline-offset 外轮廓修饰并绘制超出边框的边缘 resize 指定一个元素是否是由用户调整大小 弹性盒子属性 display 指定 HTML 元素盒子类型。 flex-direction 指定了弹性容器中子元素的排列方式 justify-content 设置弹性盒子元素在主轴（横轴）方向上的对齐方式。 align-items 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。 flex-wrap 设置弹性盒子的子元素超出父容器时是否换行。 align-content 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 flex-flow flex-direction 和 flex-wrap 的简写 order 设置弹性盒子的子元素排列顺序。 align-self 在弹性子元素上使用。覆盖容器的 align-","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:5:2","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"HTML的基础标签 ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:0","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"基础标签 \u003c!-- 定义 HTML 文档 --\u003e \u003chtml\u003e \u003c!-- 头部标签元素 --\u003e \u003chead\u003e \u003c!-- 元数据（不显示在页面上，但会被浏览器解析，用于指定网页的描述，关键词） --\u003e \u003cmeta charset=\"utf-8\"\u003e \u003c!-- 描述了基本的链接地址/链接目标 --\u003e \u003cbase href=\"http://www.runoob.com/images/\" target=\"_blank\"\u003e \u003c!-- 标签定义了文档与外部资源之间的关系 --\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"\u003e \u003c!-- 标题 --\u003e \u003ctitle\u003e文档标题\u003c/title\u003e \u003c!-- 定义文档的主体 --\u003e \u003cbody\u003e \u003c!-- h1 - h6 --\u003e \u003ch1\u003e这是一个标题\u003c/h1\u003e \u003ch2\u003e这是一个标题\u003c/h2\u003e \u003ch3\u003e这是一个标题\u003c/h3\u003e \u003c!-- 段落 --\u003e \u003cp\u003e这是一个段落。\u003c/p\u003e \u003c!-- 链接 --\u003e \u003ca href=\"https://www.baidu.com\"\u003e这是一个链接\u003c/a\u003e \u003c!-- 图像 --\u003e \u003cimg loading=\"lazy\" src=\"/images/logo.png\" width=\"258\" height=\"39\" /\u003e \u003c!-- map 与 area --\u003e \u003cimg loading=\"lazy\" src=\"planets.gif\" width=\"145\" height=\"126\" alt=\"Planets\" usemap=\"#planetmap\"\u003e \u003cmap name=\"planetmap\"\u003e \u003carea shape=\"rect\" coords=\"0,0,82,126\" alt=\"Sun\" href=\"sun.htm\"\u003e \u003carea shape=\"circle\" coords=\"90,58,3\" alt=\"Mercury\" href=\"mercur.htm\"\u003e \u003carea shape=\"circle\" coords=\"124,58,8\" alt=\"Venus\" href=\"venus.htm\"\u003e \u003c/map\u003e \u003c!-- 换行 --\u003e \u003cbr\u003e \u003c!-- 水平线 --\u003e \u003chr\u003e \u003c!-- 区块 --\u003e \u003cdiv\u003e \u003cspan\u003e \u003c!-- 注释 --\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:1","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"表格、列表、表单、框架、脚本 \u003c!-- 表格 --\u003e \u003ctable border=\"1\"\u003e \u003ctr\u003e \u003ctd\u003eRow 1, cell 1\u003c/td\u003e \u003ctd\u003eRow 1, cell 2\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c!-- 无序列表 --\u003e \u003cul\u003e \u003cli\u003eCoffee\u003c/li\u003e \u003cli\u003eMilk\u003c/li\u003e \u003c/ul\u003e \u003c!-- 有序列表 --\u003e \u003col\u003e \u003cli\u003eCoffee\u003c/li\u003e \u003cli\u003eMilk\u003c/li\u003e \u003c/ol\u003e \u003c!-- 自定义列表 --\u003e \u003cdl\u003e \u003cdt\u003eCoffee\u003c/dt\u003e \u003cdd\u003e- black hot drink\u003c/dd\u003e \u003cdt\u003eMilk\u003c/dt\u003e \u003cdd\u003e- white cold drink\u003c/dd\u003e \u003c/dl\u003e \u003c!-- 表单 --\u003e \u003cform\u003e \u003c!-- Text Fields --\u003e Name: \u003cinput type=\"text\" name=\"name\"\u003e\u003cbr\u003e \u003c!-- password --\u003e Password: \u003cinput type=\"password\" name=\"pwd\"\u003e\u003cbr\u003e \u003c!-- Radio Buttons --\u003e \u003cinput type=\"radio\" name=\"sex\" value=\"male\"\u003eMale\u003cbr\u003e \u003c!-- Checkboxes --\u003e \u003cinput type=\"checkbox\" name=\"vehicle\" value=\"Bike\"\u003eI have a bike\u003cbr\u003e \u003c!-- Submit Button --\u003e \u003cinput type=\"submit\" value=\"Submit\"\u003e \u003c/form\u003e \u003c!-- 框架 --\u003e \u003ciframe src=\"URL\"\u003e\u003c/iframe\u003e \u003c!-- 脚本 --\u003e \u003cscript\u003e document.write(\"Hello World!\"); \u003c/script\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:2","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"常用属性 class： 为html元素定义一个或多个类名（classname）(类名从样式文件引入) id： 定义元素的唯一id style： 规定元素的行内样式（inline style） title： 描述了元素的额外信息 (作为工具条使用) ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:3","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"文本格式化 标签 描述 文本格式化标签 \u003cb\u003e 定义粗体文本 \u003cem\u003e 定义着重文字 \u003ci\u003e 定义斜体字 \u003csmall\u003e 定义小号字 \u003cstrong\u003e 定义加重语气 \u003csub\u003e 定义下标字 \u003csup\u003e 定义上标字 \u003cins\u003e 定义插入字 \u003cdel\u003e 定义删除字 “计算机输出” 标签 \u003ccode\u003e 定义计算机代码 \u003ckbd\u003e 定义键盘码 \u003csamp\u003e 定义计算机代码样本 \u003cvar\u003e 定义变量 \u003cpre\u003e 定义预格式文本 引文, 引用, 及标签定义 \u003cabbr\u003e 定义缩写 \u003caddress\u003e 定义地址 \u003cbdo\u003e 定义文字方向 \u003cblockquote\u003e 定义长的引用 \u003cq\u003e 定义短的引用语 \u003ccite\u003e 定义引用、引证 \u003cdfn\u003e 定义一个定义项目。 ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:4","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"HTML5 新元素 标签 描述 \u003ccanvas\u003e 新元素 \u003ccanvas\u003e 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API 新多媒体元素 \u003caudio\u003e 定义音频内容 \u003cvideo\u003e 定义视频（video 或者 movie） \u003csource\u003e 定义多媒体资源 \u003cvideo\u003e 和 \u003caudio\u003e \u003cembed\u003e 定义嵌入的内容，比如插件。 \u003ctrack\u003e 为诸如 \u003cvideo\u003e 和 \u003caudio\u003e 元素之类的媒介规定外部文本轨道。 新表单元素 \u003cdatalist\u003e 定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。 \u003ckeygen\u003e 规定用于表单的密钥对生成器字段。 \u003coutput\u003e 定义不同类型的输出，比如脚本的输出。 新的语义和结构元素 \u003carticle\u003e 定义页面独立的内容区域。 \u003caside\u003e 定义页面的侧边栏内容。 \u003cbdi\u003e 允许您设置一段文本，使其脱离其父元素的文本方向设置。 \u003ccommand\u003e 定义命令按钮，比如单选按钮、复选框或按钮 \u003cdetails\u003e 用于描述文档或文档某个部分的细节 \u003cdialog\u003e 定义对话框，比如提示框 \u003csummary\u003e 标签包含 details 元素的标题 \u003cfigure\u003e 规定独立的流内容（图像、图表、照片、代码等等）。 \u003cfigcaption\u003e 定义 \u003cfigure\u003e 元素的标题 \u003cfooter\u003e 定义 section 或 document 的页脚。 \u003cheader\u003e 定义了文档的头部区域 \u003cmark\u003e 定义带有记号的文本。 \u003cmeter\u003e 定义度量衡。仅用于已知最大和最小值的度量。 \u003cnav\u003e 定义导航链接的部分。 \u003cprogress\u003e 定义任何类型的任务的进度。 \u003cruby\u003e 定义 ruby 注释（中文注音或字符）。 \u003crt\u003e 定义字符（中文注音或字符）的解释或发音。 \u003crp\u003e 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。 \u003csection\u003e 定义文档中的节（section、区段）。 \u003ctime\u003e 定义日期或时间。 \u003cwbr\u003e 规定在文本中的何处适合添加换行符。 ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:5","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"HTML5 本地储存 客户端存储数据的两个对象为： localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。 sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。 //保存数据 function save(){ var siteurl = document.getElementById(\"siteurl\").value; var sitename = document.getElementById(\"sitename\").value; localStorage.setItem(sitename, siteurl); alert(\"添加成功\"); } //查找数据 function find(){ var search_site = document.getElementById(\"search_site\").value; var sitename = localStorage.getItem(search_site); var find_result = document.getElementById(\"find_result\"); find_result.innerHTML = search_site + \"的网址是：\" + sitename; ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:6","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"HTML5 Web SQL Web SQL 数据库 API 并不是 HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用 SQL 操作客户端数据库的 APIs。 以下是规范中定义的三个核心方法： openDatabase：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。 transaction：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。 executeSql：这个方法用于执行实际的 SQL 查询。 var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024); var msg; db.transaction(function (tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")'); msg = '\u003cp\u003e数据表已创建，且插入了两条数据。\u003c/p\u003e'; document.querySelector('#status').innerHTML = msg; }); db.transaction(function (tx) { tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) { var len = results.rows.length, i; msg = \"\u003cp\u003e查询记录条数: \" + len + \"\u003c/p\u003e\"; document.querySelector('#status').innerHTML += msg; for (i = 0; i \u003c len; i++){ msg = \"\u003cp\u003e\u003cb\u003e\" + results.rows.item(i).log + \"\u003c/b\u003e\u003c/p\u003e\"; document.querySelector('#status').innerHTML += msg; } }, null); }); ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:7","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"HTML5 Web Workers // demo_workers.js var i=0; function timedCount() { i=i+1; postMessage(i); setTimeout(\"timedCount()\",500); } timedCount(); // web_worker.html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003eWeb Worker\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e计数： \u003coutput id=\"result\"\u003e\u003c/output\u003e\u003c/p\u003e \u003cbutton onclick=\"startWorker()\"\u003e开始工作\u003c/button\u003e \u003cbutton onclick=\"stopWorker()\"\u003e停止工作\u003c/button\u003e \u003cp\u003e\u003cstrong\u003e注意：\u003c/strong\u003e Internet Explorer 9 及更早 IE 版本浏览器不支持 Web Workers.\u003c/p\u003e \u003cscript\u003e var w; function startWorker() { if(typeof(Worker) !== \"undefined\") { if(typeof(w) == \"undefined\") { w = new Worker(\"demo_workers.js\"); } w.onmessage = function(event) { document.getElementById(\"result\").innerHTML = event.data; }; } else { document.getElementById(\"result\").innerHTML = \"抱歉，你的浏览器不支持 Web Workers...\"; } } function stopWorker() { w.terminate(); w = undefined; } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:8","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"HTML5 服务器发送事件(Server-Sent Events) Server-Sent 事件 - 单向消息传递 \u003c!-- demo_sse.php --\u003e \u003c?php header('Content-Type: text/event-stream'); header('Cache-Control: no-cache'); $time = date('r'); echo \"data: The server time is: {$time}\\n\\n\"; flush(); ?\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003eServer-Sent Events\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e获取服务端更新数据\u003c/h1\u003e \u003cdiv id=\"result\"\u003e\u003c/div\u003e \u003cscript\u003e if(typeof(EventSource)!==\"undefined\") { var source=new EventSource(\"demo_sse.php\"); source.onmessage=function(event) { document.getElementById(\"result\").innerHTML+=event.data + \"\u003cbr\u003e\"; }; } else { document.getElementById(\"result\").innerHTML=\"抱歉，你的浏览器不支持 server-sent 事件...\"; } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:9","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"HTML5 WebSocket WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003eWebSocket\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function WebSocketTest() { if (\"WebSocket\" in window) { alert(\"您的浏览器支持 WebSocket!\"); // 打开一个 web socket var ws = new WebSocket(\"ws://localhost:9998/echo\"); ws.onopen = function() { // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(\"发送数据\"); alert(\"数据发送中...\"); }; ws.onmessage = function (evt) { var received_msg = evt.data; alert(\"数据已接收...\"); }; ws.onclose = function() { // 关闭 websocket alert(\"连接已关闭...\"); }; } else { // 浏览器不支持 WebSocket alert(\"您的浏览器不支持 WebSocket!\"); } } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"sse\"\u003e \u003ca href=\"javascript:WebSocketTest()\"\u003e运行 WebSocket\u003c/a\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e HTML 参考手册 ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:10","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["架构艺术"],"content":"UML 的各种图 UML 又称为统一建模语言，是为面向对象开发系统进行说明、可视化的一种标准语言。 UML 的分类如下： UML 用例视图 用例图 设计视图 类图 对象图 进程视图 时序图 协作图 状态图 活动图 实现视图 构件图 拓扑视图 部署图 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:1:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"用例图 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:2:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"类图 类图是描述类与类之间的关系，在类图里有常见的六种关系。分别是泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency) 各种关系的强弱顺序： 泛化 = 实现 \u003e 组合 \u003e 聚合 \u003e 关联 \u003e 依赖 泛化（一种继承关系） 例如：动物 -\u003e 老虎 实现（类与接口的关系，表示接口的实现） 例如：鸟 -\u003e 燕子 聚合（部分和整体的关系，但部分可以脱离整体单独存在） 【代码体现】：成员变量 例如：汽车 -\u003e 轮子 组合（部分和整体的关系，但部分不能脱离整体单独存在，整体没了部分也无法独活） 【代码体现】：成员变量 例如：公司 -\u003e 部门 关联（类和类之间知道彼此的存在【属性、方法之类】，关联可以是单项的，也可以是双向的） 【代码体现】：成员变量 例如：夫妻、师生 依赖（使用的关系，类与类独立，仅存在协助关系，并且尽量不使用双向互相依赖） 【代码表现】：局部变量、方法的参数或者对静态方法的调用 例如：人 -\u003e 锤子 各种类图的关系 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:3:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"对象图 描述的是参与交互的各个对象在交互过程中某一时刻的状态。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:4:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"状态图（Statechart Diagrams） 是描述一个实体基于事件反应的动态行为，显示了该实体如何根据当前所处的状态对不同的事件做出反应。 框里是状态，线是行为。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:5:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"活动图（Activity Diagrams） 用于表示系统中各种活动的次序。 实圆圈是开始，框里是行为，菱形是选择，套圈是结束。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:6:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"时序图（equence Diagrams） 描述了对象之间消息发送的先后顺序，强调时间顺序。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:7:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"协作图（Collaboration Diagrams） 描述了收发消息的对象的组织关系，强调对象之间的合作关系。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:8:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"构件图（Component Diagrams） 构件图是用来表示系统中构件与构件之间，类或接口与构件之间的关系图。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:9:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"部署图（Deployment Diagrams） 描述了系统运行时进行处理的结点以及在结点上活动的构件的配置。强调了物理设备以及之间的连接关系。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:10:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["计算机基础"],"content":"HTTP 响应代码 HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。 响应分为五类： 信息响应(100–199) 成功响应(200–299) 重定向(300–399) 客户端错误(400–499) 服务器错误 (500–599) 状态代码由 section 10 of RFC 2616定义 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:1:0","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"信息响应 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:2:0","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"100 Continue 这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:2:1","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"101 Switching Protocol 该代码是响应客户端的 Upgrade (en-US) 标头发送的，并且指示服务器也正在切换的协议。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:2:2","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"102 Processing (WebDAV (en-US)) 此代码表示服务器已收到并正在处理该请求，但没有响应可用。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:2:3","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"103 Early Hints 此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:2:4","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"成功响应 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:0","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"200 OK 请求成功。成功的含义取决于HTTP方法： GET：资源已被提取并在消息正文中传输。 HEAD：实体标头位于消息正文中。 POST：描述动作结果的资源在消息体中传输。 TRACE：消息正文包含服务器收到的请求消息 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:1","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"201 Created 该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:2","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"202 Accepted 请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:3","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"203 Non-Authoritative Information 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:4","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"204 No Content 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:5","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"205 Reset Content 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:6","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"206 Partial Content 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:7","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"207 Multi-Status (WebDAV (en-US)) 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 208 Already Reported (WebDAV (en-US)) 在 DAV 里面使用: propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:8","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"226 IM Used (HTTP Delta encoding) 服务器已经完成了对资源的 GET 请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:9","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"重定向 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:0","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"300 Multiple Choice 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:1","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:2","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"302 Found 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:3","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"303 See Other 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:4","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"304 Not Modified 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:5","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"305 Use Proxy 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:6","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"306 unused 在最新版的规范中，306 状态码已经不再被使用。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:7","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"307 Temporary Redirect 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:8","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"308 Permanent Redirect 这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:9","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"客户端响应 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:0","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"400 Bad Request 语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 请求参数有误。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:1","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"401 Unauthorized 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:2","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"402 Payment Required 此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:3","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"403 Forbidden 服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:4","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:5","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"405 Method Not Allowed 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:6","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"406 Not Acceptable 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:7","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"407 Proxy Authentication Required 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:8","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"408 Request Timeout 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:9","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"409 Conflict 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:10","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"410 Gone 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:11","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"411 Length Required 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:12","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"412 Precondition Failed 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:13","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"413 Payload Too Large 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:14","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"414 URI Too Long 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:15","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"415 Unsupported Media Type 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:16","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"416 Range Not Satisfiable 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:17","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"417 Expectation Failed 此响应代码意味着服务器无法满足 Expect 请求标头字段指示的期望值。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:18","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"418 I’m a teapot 服务器拒绝尝试用 “茶壶冲泡咖啡”。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:19","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"421 Misdirected Request 该请求针对的是无法产生响应的服务器。 这可以由服务器发送，该服务器未配置为针对包含在请求 URI 中的方案和权限的组合产生响应。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:20","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"422 Unprocessable Entity (WebDAV (en-US)) 请求格式良好，但由于语义错误而无法遵循。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:21","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"423 Locked (WebDAV (en-US)) 正在访问的资源被锁定。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:22","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"424 Failed Dependency (WebDAV (en-US)) 由于先前的请求失败，所以此次请求失败。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:23","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"425 Too Early 服务器不愿意冒着风险去处理可能重播的请求。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:24","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"426 Upgrade Required 服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做。 服务器在 426 响应中发送 Upgrade (en-US) 头以指示所需的协议。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:25","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"428 Precondition Required 原始服务器要求该请求是有条件的。 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:26","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"429 Too Many Requests 用户在给定的时间内发送了太多请求（“限制请求速率”）。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:27","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"431 Request Header Fields Too Large 服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:28","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"451 Unavailable For Legal Reasons 用户请求非法资源，例如：由政府审查的网页。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:29","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"服务端响应 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:0","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"500 Internal Server Error 服务器遇到了不知道如何处理的情况。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:1","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"501 Not Implemented 此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:2","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"502 Bad Gateway 此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:3","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"503 Service Unavailable 服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:4","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"504 Gateway Timeout 当服务器作为网关，不能及时得到响应时返回此错误代码。 505 HTTP Version Not Supported 服务器不支持请求中所使用的HTTP协议版本。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:5","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"506 Variant Also Negotiates 服务器有一个内部配置错误：对请求的透明内容协商导致循环引用。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:6","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"507 Insufficient Storage 服务器有内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:7","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"508 Loop Detected (WebDAV (en-US)) 服务器在处理请求时检测到无限循环。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:8","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"510 Not Extended 客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:9","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"511 Network Authentication Required 511状态码指示客户端需要进行身份验证才能获得网络访问权限。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:10","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["数据与算法"],"content":"1. 封装集合 概念：本文所讲的封装集合就是把集合进行封装，只提供调用端需要的接口。 正文：在很多时候，我们都不希望把一些不必要的操作暴露给调用端，只需要给它所需要的操作或数据就行，那么做法就是封装。这个重构在微软的代码库也经常遇到。比如最经典的属性对字段的封装就是一个很好的例子，那么下面我们将看到对集合的封装，如下代码所示，调用端只需要一个集合的信息，而我们则提供了一个IList的集合，大家都知道IList具有对集合的所有操作，所以这会带来很多隐患，最好的做法就是对它进行重构。 那么重构之后，我们把IList换成了IEnumerable，大家都知道只包括一个返回值为IEnumerator的GetEnumerator()方法，所以这样只能遍历取出它的值，而不能对这个集合做出改变，这正是我们所需要的结果，具体代码如下： using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.EncapsulateCollection.Before { public class Order { private List\u003cOrderLine\u003e _orderLines; private double _orderTotal; public IList\u003cOrderLine\u003e OrderLines { get { return _orderLines; } } public void AddOrderLine(OrderLine orderLine) { _orderTotal += orderLine.Total; _orderLines.Add(orderLine); } public void RemoveOrderLine(OrderLine orderLine) { orderLine = _orderLines.Find(o =\u003e o == orderLine); if (orderLine == null) return; _orderTotal -= orderLine.Total; _orderLines.Remove(orderLine); } } public class OrderLine { public double Total { get; private set; } } using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.EncapsulateCollection.After { public class Order { private List\u003cOrderLine\u003e _orderLines; private double _orderTotal; public IEnumerable\u003cOrderLine\u003e OrderLines { get { return _orderLines; } } public void AddOrderLine(OrderLine orderLine) { _orderTotal += orderLine.Total; _orderLines.Add(orderLine); } public void RemoveOrderLine(OrderLine orderLine) { orderLine = _orderLines.Find(o =\u003e o == orderLine); if (orderLine == null) return; _orderTotal -= orderLine.Total; _orderLines.Remove(orderLine); } } public class OrderLine { public double Total { get; private set; } } } 总结：这个例子很容易让我们想到以前系统间耦合常喜欢用数据库。每个系统都会操作数据库，并且有些系统还会对数据库的表结构或字段进行修改，那么这很容易就会造成维护的地狱，很明智的一个做法就是使用SOA来隔开这些耦合，让一些只需要数据展示的系统得到自己需要的数据即可。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:1:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"2. 移动方法 概念：本文所讲的移动方法就是方法放在合适的位置（通常指放在合适的类中）。 正文：移动方法是一个很简单也很常见的重构，只要是系统就会存在很多类，那么类里面包括很多方法，如果一个方法经常被另外一个类使用（比本身的类使用还多）或者这个方法本身就不应该放在这个类里面，那么这个适合应该考虑把它移到合适的类中。代码如下： 移动以后大家可以看到BankAccount类的职责也单一，同时CalculateInterestRate也放到了经常使用且适合它的类中了，所以此重构是一个比较好的重构，能让整个代码变得更加合理。 namespace LosTechies.DaysOfRefactoring.MoveMethod.Before { public class BankAccount { public BankAccount(int accountAge, int creditScore, AccountInterest accountInterest) { AccountAge = accountAge; CreditScore = creditScore; AccountInterest = accountInterest; } public int AccountAge { get; private set; } public int CreditScore { get; private set; } public AccountInterest AccountInterest { get; private set; } public double CalculateInterestRate() { if (CreditScore \u003e 800) return 0.02; if (AccountAge \u003e 10) return 0.03; return 0.05; } } public class AccountInterest { public BankAccount Account { get; private set; } public AccountInterest(BankAccount account) { Account = account; } public double InterestRate { get { return Account.CalculateInterestRate(); } } public bool IntroductoryRate { get { return Account.CalculateInterestRate() \u003c 0.05; } } } } namespace LosTechies.DaysOfRefactoring.MoveMethod.After { public class AccountInterest { public BankAccount Account { get; private set; } public AccountInterest(BankAccount account) { Account = account; } public double InterestRate { get { return CalculateInterestRate(); } } public bool IntroductoryRate { get { return CalculateInterestRate() \u003c 0.05; } } public double CalculateInterestRate() { if (Account.CreditScore \u003e 800) return 0.02; if (Account.AccountAge \u003e 10) return 0.03; return 0.05; } } } namespace LosTechies.DaysOfRefactoring.MoveMethod.After { public class BankAccount { public BankAccount(int accountAge, int creditScore, AccountInterest accountInterest) { AccountAge = accountAge; CreditScore = creditScore; AccountInterest = accountInterest; } public int AccountAge { get; private set; } public int CreditScore { get; private set; } public AccountInterest AccountInterest { get; private set; } } } 总结：这个重构法则在很多时候能让我们把代码组织的结构调整得更合理，同时也能给以后的维护带来方便。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:2:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"3. 提升方法 概念：提升方法是指将一个很多继承类都要用到的方法提升到基类中。 正文：提升方法是指将一个很多继承类都要用到的方法提升到基类中，这样就能减少代码量，同时让类的结构更清晰。如下代码所示，Turn方法在子类Car和Motorcycle 都会用到，因为Vehicle 都会有这个方法，所以我们就会想到把它提到基类中。 重构后的代码如下，那么现在Car 和Motorcycle 都具有Turn这个方法，如果这个方法修改也只需要修改基类即可，所以给维护和以后的重构带来了方便。 namespace LosTechies.DaysOfRefactoring.PullUpMethod.Before { public abstract class Vehicle { // other methods } public class Car : Vehicle { public void Turn(Direction direction) { // code here } } public class Motorcycle : Vehicle { } public enum Direction { Left, Right } } namespace LosTechies.DaysOfRefactoring.PullUpMethod.After { public abstract class Vehicle { public void Turn(Direction direction) { // code here } } public class Car : Vehicle { } public class Motorcycle : Vehicle { } public enum Direction { Left, Right } } 总结：这个重构要根据具体情况使用，如果不是每个子类都有这个方法的话，可以考虑使用接口或者其他方式。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:3:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"4. 降低方法 概念：本文中的降低方法和前篇的提升方法整好相反，也就是把个别子类使用到的方法从基类移到子类里面去。 正文：如下代码所示，Animal 类中的方法Bark只有在其子类Dog 中使用，所以最好的方案就是把这个方法移到子类Dog 中。 重构后的代码如下，同时如果在父类Animal 中如果没有其他的字段或者公用方法的话，可以考虑把Bark方法做成一个接口，从而去掉Animal 类。 namespace LosTechies.DaysOfRefactoring.PushDownMethod.Before { public abstract class Animal { public void Bark() { // code to bark } } public class Dog : Animal { } public class Cat : Animal { } } namespace LosTechies.DaysOfRefactoring.PushDownMethod.After { public abstract class Animal { } public class Dog : Animal { public void Bark() { // code to bark } } public class Cat : Animal { } } 总结：面向对象三大特征（继承、封装、多态）很多时候可以帮助我们，但同时也可能会造成使用过度或者使用不当，所以如何把握好设计，这个就变得至关重要。在什么时候使用继承的方式，在什么时候使用组合和聚合，接口和继承类的选择等久成了我们的重点。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:4:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"5. 提升字段 概念：本文中的提升字段和前面的提升方法颇为相似，就是把子类公用的字段提升到基类中，从而达到公用的目的。 正文：如下代码所示， Account 的两个子类CheckingAccount 和SavingsAccount 都有minimumCheckingBalance 字段，所以可以考虑把这个字段提到基类中。 重构后的代码如下，这样提的前提是这些子类有一个基类或者有很多相似的字段和方法，不然为了一个字段而单独建立一个抽象类是不可取的，所以这个就需要具体权衡。 using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace LosTechies.DaysOfRefactoring.PullUpField.Before { public abstract class Account { } public class CheckingAccount : Account { private decimal _minimumCheckingBalance = 5m; } public class SavingsAccount : Account { private decimal _minimumSavingsBalance = 5m; } } using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace LosTechies.DaysOfRefactoring.PullUpField.After { public abstract class Account { protected decimal _minimumBalance = 5m; } public class CheckingAccount : Account { } public class SavingsAccount : Account { } } 总结：这个重构的策略比较简单，同时也是比较常用的一些做法，最主要就是要注意权衡是否真的有这个必要，看这样做究竟有没有什么好处（比如只需要改一个地方，维护简便了，同时代码量也更少了等）。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:5:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"6. 降低字段 概念：本文中的降低字段和前篇的提升字段正好相反，就是把基类中只有某些少数类用到的字段降低到使用它们的子类中。 正文：如下代码所示，基类Task 类中的_resolution字段只会在子类BugTask 中用到，所以就考虑把它放到BugTask 类中。 重构后的代码如下所示，这样做的好处可以简化基类，同时让其他没有使用它的子类也变得更加简单，如果这样的字段比较多的话，使用此重构也能节约一部分内存。 namespace LosTechies.DaysOfRefactoring.PushDownField.Before { public abstract class Task { protected string _resolution; } public class BugTask : Task { } public class FeatureTask : Task { } } namespace LosTechies.DaysOfRefactoring.PushDownField.After { public abstract class Task { } public class BugTask : Task { private string _resolution; } public class FeatureTask : Task { } } 总结：此重构也是一个非常简单的重构，在很多时候我们都会不自觉的使用它。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:6:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"7. 重命名（方法，类，参数） 概念：本文中的改名（方法，类，参数）是指在写代码的时候对类、方法、参数、委托、事件等等元素取一个有意义的名称。 正文：如下代码所示，加入一个公司建立一个员工的类，类中有一个员工名字的字段和一个按照小时计算员工收入的方法，那么下面代码的取名就显得很难理解了，所以我们会重构名称。 重构后代码如下所示，这样看起来就非常清晰，如果有新进项目组的成员，也会变得很乐意看这个代码。 namespace LosTechies.DaysOfRefactoring.Rename.Before { public class Person { public string FN { get; set; } public decimal ClcHrlyPR() { // code to calculate hourly payrate return 0m; } } } namespace LosTechies.DaysOfRefactoring.Rename.After { // Changed the class name to Employee public class Employee { public string FirstName { get; set; } public decimal CalculateHourlyPay() { // code to calculate hourly payrate return 0m; } } } 总结：此重构经常被广大程序员所忽视，但是带来的隐患是不可估量的，也许老板要修改功能，那我们来看这段没有重构的代码（就算是自己写的，但由于时间和项目多等关系，我们也很难理解了），然后就会变得焦头烂额。相反重构后的代码就会觉得一目了然、赏心悦目。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:7:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"8. 使用委派代替继承 概念：本文中的“使用委派代替继承”是指在根本没有父子关系的类中使用继承是不合理的，可以用委派的方式来代替。 如下代码所示，Child 和Sanitation（公共设施）是没有逻辑上的父子关系，因为小孩不可能是一个公共设施吧！所以我们为了完成这个功能可以考虑使用委派的方式。 重构后的代码如下，把Sanitation 委派到Child 类中，从而可以使用WashHands这个方法，这种方式我们经常会用到，其实IOC也使用到了这个原理，可以通过构造注入和方法注入等。 namespace LosTechies.DaysOfRefactoring.ReplaceInheritance.Before { public class Sanitation { public string WashHands() { return \"Cleaned!\"; } } public class Child : Sanitation { } } namespace LosTechies.DaysOfRefactoring.ReplaceInheritance.After { public class Sanitation { public string WashHands() { return \"Cleaned!\"; } } public class Child { private Sanitation Sanitation { get; set; } public Child() { Sanitation = new Sanitation(); } public string WashHands() { return Sanitation.WashHands(); } } } 总结：这个重构是一个很好的重构，在很大程度上解决了滥用继承的情况，很多设计模式也用到了这种思想（比如桥接模式、适配器模式、策略模式等）。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:8:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"9. 提取接口 概念：本文中的“提取接口” 是指超过一个的类要使用某一个类中部分方法时，我们应该解开它们之间的依赖，让调用者使用接口，这很容易实现也可以降低代码的耦合性。 正文：如下代码所示，RegistrationProcessor 类只使用到了ClassRegistration 类中的Create方法和Total 字段，所以可以考虑把他们做成接口给RegistrationProcessor 调用。 重构后的代码如下，我们提取了一个IClassRegistration 接口，同时让ClassRegistration 继承此接口，然后调用端RegistrationProcessor 就可以直接通过IClassRegistration 接口进行调用。 namespace LosTechies.DaysOfRefactoring.ExtractInterface.Before { public class ClassRegistration { public void Create() { // create registration code } public void Transfer() { // class transfer code } public decimal Total { get; private set; } } public class RegistrationProcessor { public decimal ProcessRegistration(ClassRegistration registration) { registration.Create(); return registration.Total; } } } namespace LosTechies.DaysOfRefactoring.ExtractInterface.After { public interface IClassRegistration { void Create(); decimal Total { get; } } public class ClassRegistration : IClassRegistration { public void Create() { // create registration code } public void Transfer() { // class transfer code } public decimal Total { get; private set; } } public class RegistrationProcessor { public decimal ProcessRegistration(IClassRegistration registration) { registration.Create(); return registration.Total; } } } 总结：这个重构策略也是一个常见的运用，很多设计模式也会在其中运用此思想（如简单工程、抽象工厂等都会通过接口来解开依赖）。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:9:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"10. 提取方法 概念：本文中的把某些计算复杂的过程按照功能提取成各个小方法，这样就可以使代码的可读性、维护性得到提高。 正文：如下代码所示，CalculateGrandTotal方法里面包含了多个逻辑，第一计算subTotal的总和，第二subTotal 要循环减去discount，也就是计算Discounts，第三就是计算Tax。所以我们可以根据功能把他们拆分成三个小方法。 重构后的代码如下，然后CalculateGrandTotal方法就直接调用CalculateSubTotal、CalculateDiscounts、CalculateTax，从而是整个逻辑看起来更加清晰，并且可读性和维护性也得到了大大提高。 using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.ExtractMethod.Before { public class Receipt { private IList\u003cdecimal\u003e Discounts { get; set; } private IList\u003cdecimal\u003e ItemTotals { get; set; } public decimal CalculateGrandTotal() { decimal subTotal = 0m; foreach (decimal itemTotal in ItemTotals) subTotal += itemTotal; if (Discounts.Count \u003e 0) { foreach (decimal discount in Discounts) subTotal -= discount; } decimal tax = subTotal * 0.065m; subTotal += tax; return subTotal; } } } using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.ExtractMethod.After { public class Receipt { private IList\u003cdecimal\u003e Discounts { get; set; } private IList\u003cdecimal\u003e ItemTotals { get; set; } public decimal CalculateGrandTotal() { decimal subTotal = CalculateSubTotal(); subTotal = CalculateDiscounts(subTotal); subTotal = CalculateTax(subTotal); return subTotal; } private decimal CalculateTax(decimal subTotal) { decimal tax = subTotal * 0.065m; subTotal += tax; return subTotal; } private decimal CalculateDiscounts(decimal subTotal) { if (Discounts.Count \u003e 0) { foreach (decimal discount in Discounts) subTotal -= discount; } return subTotal; } private decimal CalculateSubTotal() { decimal subTotal = 0m; foreach (decimal itemTotal in ItemTotals) subTotal += itemTotal; return subTotal; } } } 总结：这个重构在很多公司都有一些的代码规范作为参考，比如一个类不能超过多少行代码，一个方法里面不能超过多少行代码，这在一定程度上也能使程序员把这些复杂的逻辑剥离成意义很清楚的小方法。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:10:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"11. 使用策略类 概念：本文中的“使用策略类” 是指用设计模式中的策略模式来替换原来的switch case和if else语句，这样可以解开耦合，同时也使维护性和系统的可扩展性大大增强。 正文：如下面代码所示，ClientCode 类会更加枚举State的值来调用ShippingInfo 的不同方法，但是这样就会产生很多的判断语句，如果代码量加大，类变得很大了的话，维护中改动也会变得很大，每次改动一个地方，都要对整个结构进行编译（假如是多个工程），所以我们想到了对它进行重构，剥开耦合。 重构后的代码如下所示，抽象出一个IShippingCalculation 接口，然后把ShippingInfo 类里面的GetAlaskaShippingAmount、GetNewYorkShippingAmount、GetFloridaShippingAmount三个方法分别提炼成三个类，然后继承自IShippingCalculation 接口，这样在调用的时候就可以通过IEnumerable\u003cIShippingCalculation\u003e 来解除之前的switch case语句，这和IOC的做法颇为相似。 namespace LosTechies.DaysOfRefactoring.SwitchToStrategy.Before { public class ClientCode { public decimal CalculateShipping() { ShippingInfo shippingInfo = new ShippingInfo(); return shippingInfo.CalculateShippingAmount(State.Alaska); } } public enum State { Alaska, NewYork, Florida } public class ShippingInfo { public decimal CalculateShippingAmount(State shipToState) { switch (shipToState) { case State.Alaska: return GetAlaskaShippingAmount(); case State.NewYork: return GetNewYorkShippingAmount(); case State.Florida: return GetFloridaShippingAmount(); default: return 0m; } } private decimal GetAlaskaShippingAmount() { return 15m; } private decimal GetNewYorkShippingAmount() { return 10m; } private decimal GetFloridaShippingAmount() { return 3m; } } } using System; using System.Collections.Generic; using System.Linq; namespace LosTechies.DaysOfRefactoring.SwitchToStrategy.After_WithIoC { public interface IShippingInfo { decimal CalculateShippingAmount(State state); } public class ClientCode { [Inject] public IShippingInfo ShippingInfo { get; set; } public decimal CalculateShipping() { return ShippingInfo.CalculateShippingAmount(State.Alaska); } } public enum State { Alaska, NewYork, Florida } public class ShippingInfo : IShippingInfo { private IDictionary\u003cState, IShippingCalculation\u003e ShippingCalculations { get; set; } public ShippingInfo(IEnumerable\u003cIShippingCalculation\u003e shippingCalculations) { ShippingCalculations = shippingCalculations.ToDictionary(calc =\u003e calc.State); } public decimal CalculateShippingAmount(State shipToState) { return ShippingCalculations[shipToState].Calculate(); } } public interface IShippingCalculation { State State { get; } decimal Calculate(); } public class AlaskShippingCalculation : IShippingCalculation { public State State { get { return State.Alaska; } } public decimal Calculate() { return 15m; } } public class NewYorkShippingCalculation : IShippingCalculation { public State State { get { return State.NewYork; } } public decimal Calculate() { return 10m; } } public class FloridaShippingCalculation : IShippingCalculation { public State State { get { return State.Florida; } } public decimal Calculate() { return 3m; } } } 总结：这种重构在设计模式当中把它单独取了一个名字——策略模式，这样做的好处就是可以隔开耦合，以注入的形式实现功能，这使增加功能变得更加容易和简便，同样也增强了整个系统的稳定性和健壮性。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:11:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"12. 分解依赖 概念：本文中的“分解依赖” 是指对部分不满足我们要求的类和方法进行依赖分解，通过装饰器来达到我们需要的功能。 正文：正如下面代码所示，如果你要在你的代码中加入单元测试但有一部分代码是你不想测试的，那么你应用使用这个的重构。下面的例子中我们应用静态类来完成某些工作，但问题是在单元测试时我们无法mock静态类，所以我们只能引入静态类的装饰接口来分解对静态类的依赖。从而我们使我们的调用类只需要依赖于装饰接口就能完成这个操作。 重构后代码如下，我们添加一个接口和一个实现类，在实现类中调用静态类的方法，所以说具体做什么事情没有改变，改变的只是形式，但这样做的一个好处是增加了了代码的可测试性。在应用了分解依赖模式后，我们就可以在单元测试的时候mock一个IFeederService对象并通过AnimalFeedingService的构造函数传递给它。这样就可以完成我们需要的功能。 namespace LosTechies.DaysOfRefactoring.BreakDependencies.Before { public class AnimalFeedingService { private bool FoodBowlEmpty { get; set; } public void Feed() { if (FoodBowlEmpty) Feeder.ReplenishFood(); // more code to feed the animal } } public static class Feeder { public static void ReplenishFood() { // fill up bowl } } } namespace LosTechies.DaysOfRefactoring.BreakDependencies.After { public class AnimalFeedingService { public IFeederService FeederService { get; set; } public AnimalFeedingService(IFeederService feederService) { FeederService = feederService; } private bool FoodBowlEmpty { get; set; } public void Feed() { if (FoodBowlEmpty) FeederService.ReplenishFood(); // more code to feed the animal } } public interface IFeederService { void ReplenishFood(); } public class FeederService : IFeederService { public void ReplenishFood() { Feeder.ReplenishFood(); } } public static class Feeder { public static void ReplenishFood() { // fill up bowl } } } 总结：这个重构在很多时候和设计模式中的一些思想类似，使用中间的装饰接口来分解两个类之间的依赖，对类进行装饰，然后使它满足我们所需要的功能。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:12:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"13. 提取方法对象 概念：本文中的“提取方法对象”是指当你发现一个方法中存在过多的局部变量时，你可以通过使用“提取方法对象”重构来引入一些方法，每个方法完成任务的一个步骤，这样可以使得程序变得更具有可读性。 正文：如下代码所示，Order 类中的Calculate方法要完成很多功能，在之前我们用“提取方法”来进行重构，现在我们采取“提取方法对象”来完成重构。 正如下代码所示，我们引入了OrderCalculator类，该类实现了所有的计算方法，Order类将自身传递给 OrderCalculator类并调用Calculate方法完成计算过程。 using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.ExtractMethodObject.Before { public class OrderLineItem { public decimal Price { get; private set; } } public class Order { private IList\u003cOrderLineItem\u003e OrderLineItems { get; set; } private IList\u003cdecimal\u003e Discounts { get; set; } private decimal Tax { get; set; } public decimal Calculate() { decimal subTotal = 0m; // Total up line items foreach (OrderLineItem lineItem in OrderLineItems) { subTotal += lineItem.Price; } // Subtract Discounts foreach (decimal discount in Discounts) subTotal -= discount; // Calculate Tax decimal tax = subTotal * Tax; // Calculate GrandTotal decimal grandTotal = subTotal + tax; return grandTotal; } } } using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.ExtractMethodObject.After { public class OrderLineItem { public decimal Price { get; private set; } } public class Order { public IEnumerable\u003cOrderLineItem\u003e OrderLineItems { get; private set; } public IEnumerable\u003cdecimal\u003e Discounts { get; private set; } public decimal Tax { get; private set; } public decimal Calculate() { return new OrderCalculator(this).Calculate(); } } public class OrderCalculator { private decimal SubTotal { get; set; } private IEnumerable\u003cOrderLineItem\u003e OrderLineItems { get; set; } private IEnumerable\u003cdecimal\u003e Discounts { get; set; } private decimal Tax { get; set; } public OrderCalculator(Order order) { OrderLineItems = order.OrderLineItems; Discounts = order.Discounts; Tax = order.Tax; } public decimal Calculate() { CalculateSubTotal(); SubtractDiscounts(); CalculateTax(); return SubTotal; } private void CalculateSubTotal() { // Total up line items foreach (OrderLineItem lineItem in OrderLineItems) SubTotal += lineItem.Price; } private void SubtractDiscounts() { // Subtract Discounts foreach (decimal discount in Discounts) SubTotal -= discount; } private void CalculateTax() { // Calculate Tax SubTotal += SubTotal * Tax; } } } 总结：本文的重构方法在有的时候还是比较有用，但这样会造成字段的增加，同时也会带来一些维护的不便，它和“提取方法”最大的区别就是一个通过方法返回需要的数据，另一个则是通过字段来存储方法的结果值，所以在很大程度上我们都会选择“提取方法”。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:13:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"14. 分离职责 概念：本文中的“分离职责”是指当一个类有许多职责时，将部分职责分离到独立的类中，这样也符合面向对象的五大特征之一的单一职责原则，同时也可以使代码的结构更加清晰，维护性更高。 正文：如下代码所示，Video类有两个职责，一个是处理video rental，另一个是计算每个客户的总租金。我们可以将这两个职责分离出来，因为计算每个客户的总租金可以在Customer计算，这也比较符合常理。 重构后的代码如下，这样Video 的职责就变得很清晰，同时也使代码维护性更好。 using System.Collections.Generic; using System.Linq; namespace LosTechies.DaysOfRefactoring.BreakResponsibilities.Before { public class Video { public void PayFee(decimal fee) { } public void RentVideo(Video video, Customer customer) { customer.Videos.Add(video); } public decimal CalculateBalance(Customer customer) { returncustomer.LateFees.Sum(); } } public class Customer { public IList\u003cdecimal\u003e LateFees { get; set; } public IList\u003cVideo\u003e Videos { get; set; } } } using System.Collections.Generic; using System.Linq; namespace LosTechies.DaysOfRefactoring.BreakResponsibilities.After { public class Video { public void RentVideo(Video video, Customer customer) { customer.Videos.Add(video); } } public class Customer { public IList\u003cdecimal\u003e LateFees { get; set; } public IList\u003cVideo\u003e Videos { get; set; } public void PayFee(decimal fee) { } public decimal CalculateBalance(Customer customer) { return customer.LateFees.Sum(); } } } 总结：这个重构经常会用到，它和之前的“移动方法”有几分相似之处，让方法放在合适的类中，并且简化类的职责，同时这也是面向对象五大原则之一和设计模式中的重要思想。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:14:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"15.移除重复内容 概念：本文中的“移除重复内容”是指把一些很多地方都用到的逻辑提炼出来，然后提供给调用者统一调用。 正文：如下代码所示，ArchiveRecord和CloseRecord都会用到Archived = true; 和DateArchived = DateTime.Now; 这两条语句，所以我们就可以对它进行重构。 重构后的代码如下所示，我们提炼了SwitchToArchived方法来封装公用的操作，然后给ArchiveRecord和CloseRecord统一调用。 using System; namespace LosTechies.DaysOfRefactoring.RemoveDuplication.Before { public class MedicalRecord { public DateTime DateArchived { get; private set; } public bool Archived { get; private set; } public void ArchiveRecord() { Archived = true; DateArchived = DateTime.Now; } public void CloseRecord() { Archived = true; DateArchived = DateTime.Now; } } } sing System; namespace LosTechies.DaysOfRefactoring.RemoveDuplication.After { public class MedicalRecord { public DateTime DateArchived { get; private set; } public bool Archived { get; private set; } public void ArchiveRecord() { SwitchToArchived(); } public void CloseRecord() { SwitchToArchived(); } private void SwitchToArchived() { Archived = true; DateArchived = DateTime.Now; } } } 总结：这个重构很简单，绝大多数程序员都会使用这种重构方法，但有时由于习惯、时间、赶进度等原因而忽略它，所以会使得整个系统杂乱无章，到处都是Ctrl+C和Ctrl+V的痕迹。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:15:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"16. 封装条件 概念：本文中的“封装条件”是指条件关系比较复杂时，代码的可读性会比较差，所以这时我们应当根据条件表达式是否需要参数将条件表达式提取成可读性更好的属性或者方法，如果条件表达式不需要参数则可以提取成属性，如果条件表达式需要参数则可以提取成方法。 正文：如下代码所示，PerformCoolFunction里面的if条件判断比较复杂，看起来有点杂乱，所以就把它提出来。 如下代码所示，我们把条件表达式封装成HasExtraFunctions属性，这样先前的条件判断就成了if (HasExtraFunctions) ，所以这样就在很大程度上提高了可读性。 using System; namespace LosTechies.DaysOfRefactoring.EncapsulateConditional.Before { public class RemoteControl { private string[] Functions { get; set; } private string Name { get; set; } private int CreatedYear { get; set; } public string PerformCoolFunction(string buttonPressed) { // Determine if we are controlling some extra function // that requires special conditions if (Functions.Length \u003e 1 \u0026\u0026 Name == \"RCA\" \u0026\u0026 CreatedYear \u003e DateTime.Now.Year - 2) return \"doSomething\"; } } } using System; namespace LosTechies.DaysOfRefactoring.EncapsulateConditional.After { public class RemoteControl { private string[] Functions { get; set; } private string Name { get; set; } private int CreatedYear { get; set; } private bool HasExtraFunctions { get { return Functions.Length \u003e 1 \u0026\u0026 Name == \"RCA\" \u0026\u0026 CreatedYear \u003e DateTime.Now.Year - 2; } } public string PerformCoolFunction(string buttonPressed) { // Determine if we are controlling some extra function // that requires special conditions if (HasExtraFunctions) return \"doSomething\"; } } } 总结：这个重构在很大程度上能改善代码的可读性，尤其是在一个逻辑很复杂的应用中，把这些条件判断封装成一个有意义的名字，这样很复杂的逻辑也会立刻变得简单起来。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:16:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"17. 提取父类 正文：Dog 类中的EatFood和Groom有可能被其他类用到，因为他们都是动物的一些公有性质，所以这个时候我们就会考虑对它进行提炼。 代码如下所示，提取了Animal 方法来封装公用的EatFood和Groom类，从而使其他继承了Animal 类的子类都可以使用这两个方法了。 namespace LosTechies.DaysOfRefactoring.ExtractSuperclass.Before { public class Dog { public void EatFood() { // eat some food } public void Groom() { // perform grooming } } } namespace LosTechies.DaysOfRefactoring.ExtractSuperclass.After { public class Animal { public void EatFood() { // eat some food } public void Groom() { // perform grooming } } public class Dog : Animal { } } 总结：这个重构是典型的继承用法，很多程序员都会选择这样做，但是要注意正确的使用，不要造成过度使用了继承，如果过度使用了，请考虑用接口、组合和聚合来实现。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:17:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"18.使用条件判断代替异常 概念：本文中的“使用条件判断代替异常”是指把没有必要使用异常做判断的条件尽量改为条件判断。 正文：如下代码所示，在日常的编码中我们经常需要用到异常来控制程序流，Start方法里面用try catch 做条件判断，我们知道这里没有必要使用这种方式，因为你不需要做类型不可控的类型转换，也不需要处理异常行为，所以我们应该对它进行重构。 重构后的代码如下所示，try catch做条件判断的语句改成了if return的方式，这样在很多程度上统一了代码的书写，同时也提高了性能。 } namespace LosTechies.DaysOfRefactoring.ReplaceException.Before { public class Microwave { private IMicrowaveMotor Motor { get; set; } public bool Start(object food) { bool foodCooked = false; try { Motor.Cook(food); foodCooked = true; } catch (InUseException) { foodcooked = false; } return foodCooked; } } } namespace LosTechies.DaysOfRefactoring.ReplaceException.After { public class Microwave { private IMicrowaveMotor Motor { get; set; } public bool Start(object food) { if (Motor.IsInUse) return false; Motor.Cook(food); return true; } } } 总结： 这个重构在项目代码中也经常用到，因为对于一部分程序员，是很难把握什么时候用try catch ，什么地方该用try catch。记得之前大家还专门讨论过这些，比如如何用好以及在大中型项目中应该把它放在哪一个组件中等。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:18:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"19.提取工厂类 概念：本文中的“提取工厂类”是指如果要创建的对象很多，则代码会变的很复杂。一种很好的方法就是提取工厂类。 正文：一般来说我们需要在代码中设置一些对象，以便获得它们的状态，从而使用对象，所谓的设置通常来说就是创建对象的实例并调用对象的方法。有时如果要创建的对象很多，则代码会变的很复杂。这便是工厂模式发挥作用的情形。工厂模式的复杂应用是使用抽象工厂创建对象集，但我们在这里只是使用基本的工厂类创建对象的一个简单应用。 如下代码所示，New方法包含创建类的整个逻辑，如果现在要创建的类比较多而且逻辑比较复杂的话（如根据不同条件创建对象，什么时候创建对象），我们的New方法逻辑会变得很大，同时代码也变得很难维护。所以我们就会采用提取工厂类的方式进行提炼。 那么重构后的代码如下，New方法变得很简单了，指需要调用实现接IPoliceCarFactory 接口的PoliceCarFactory 类就可以返回对象，这样就隔开了创建对象的逻辑，如果需求现在变为根据不同的条件创建不同的对象，什么时候创建对象等都变成了比较简单的事情，在后期可以把对象都配置在XML里面，使用反射的方式实现IOC注入创建。 namespace LosTechies.DaysOfRefactoring.ExtractServiceClass.Before { public class PoliceCarController { public PoliceCar New(int mileage, bool serviceRequired) { PoliceCar policeCar = new PoliceCar(); policeCar.ServiceRequired = serviceRequired; policeCar.Mileage = mileage; return policeCar; } } } namespace LosTechies.DaysOfRefactoring.ExtractServiceClass.After { public interface IPoliceCarFactory { PoliceCar Create(int mileage, bool serviceRequired); } public class PoliceCarFactory : IPoliceCarFactory { public PoliceCar Create(int mileage, bool serviceRequired) { PoliceCar policeCar = new PoliceCar(); policeCar.ReadForService = serviceRequired; policeCar.Mileage = mileage; return policeCar; } } public class PoliceCarController { public IPoliceCarFactory PoliceCarFactory { get; set; } public PoliceCarController(IPoliceCarFactory policeCarFactory) { PoliceCarFactory = policeCarFactory; } public PoliceCar New(int mileage, bool serviceRequired) { return PoliceCarFactory.Create(mileage, serviceRequired); } } } 总结：这个重构经常会在项目中使用，如果要创建的对象是一个，你可以采用简单工厂，但是这种方式还是会存在很多依赖，维护起来也比较不方便。所以推荐使用工厂方法模式，把实例化延迟到子类。如果你要创建一系列的对象，那么就推荐你使用抽象工厂模式，但是要注意不要过度设计，只要能满足不断变化的需求和给以后的维护和重构带来方便即可。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:19:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"20.提取子类 概念：本文中的”提取子类”是指把基类中的一些不是所有子类都需要访问的方法调整到子类中。 正文：当你的基类中存在一些方法不是所有的子类都需要访问，你想将它们调整到子类中时，这个重构会变得很有用了。如下代码所示，我们需要一个 Registration类用来处理学生选课的信息。但是当Registration类开始工作后，我们意识到我们会在两种不同的上下文中使用 Registration类，NonRegistrationAction和Notes只有在我们处理未注册情况下才用到。 所以我们将NonRegistration和Notes提到单独的NonRegistration类中。 重构后的代码如下所示，这样也满足面向对象五大原则之一的单一职责。同时也让类的结构变得更加清晰，增强了可维护性。 using System; namespace LosTechies.DaysOfRefactoring.SampleCode.ExtractSubclass.Before { public class Registration { public NonRegistrationAction Action { get; set; } public decimal RegistrationTotal { get; set; } public string Notes { get; set; } public string Description { get; set; } public DateTime RegistrationDate { get; set; } } } using System; namespace LosTechies.DaysOfRefactoring.SampleCode.ExtractSubclass.After { public class Registration { public decimal RegistrationTotal { get; set; } public string Description { get; set; } public DateTime RegistrationDate { get; set; } } public class NonRegistration : Registration { public NonRegistrationAction Action { get; set; } public string Notes { get; set; } } } 总结：这个重构方法经常用来规范类的职责，和之前的一些重构方法也有些类似。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:20:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"21.合并继承 概念：本文中的”合并继承”是指如果子类的属性和方法也适合于基类，那么就可以移除子类，从而减少依赖关系。 正文：上一篇我们讲到“提取子类”重构是指当基类中的一个责任不被所有的子类所需要时，将这些责任提取到合适的子类中。而我们今天所要讲的的“合并继承”重构一般用在当我们觉得不需要子类的时候。 如下代码所示，StudentWebSite子类除了有一个属性用来说明网站是否是活动的外没有别的责任，在这种情形下我们意识到IsActive属性可以应用到所有的网站，所以我们可以将IsActive属性上移到基类中，并去掉StudentWebSite类。 重构后的代码如下： using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.SampleCode.CollapseHierarchy.Before { public class Website { public string Title { get; set; } public string Description { get; set; } public IEnumerable\u003cWebpage\u003e Pages { get; set; } } public class StudentWebsite : Website { public bool IsActive { get; set; } } } using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.SampleCode.CollapseHierarchy.After { public class Website { public string Title { get; set; } public string Description { get; set; } public IEnumerable\u003cWebpage\u003e Pages { get; set; } public bool IsActive { get; set; } } } 总结： 这篇和上篇其实最主要论述了子类和父类的继承关系以及如何判断什么时候需要使用继承，一般我们都能处理好这些关系，所以相对比较简单。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:21:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"22.分解方法 概念：本文中的”分解方法”是指把我们所做的这个功能不停的分解方法，直到将一个大方法分解为名字有意义且可读性更好的若干个小方法。 正文：如下代码所示，因为现实中AcceptPayment方法不会做这么多的事情。，所以我们通过几次分解将 AcceptPayment拆分成若干个名字有意义且可读性更好的小方法。 重构后的代码如下，我们把AcceptPayment的内部逻辑拆分成了CalculateSubtotal、SubtractDiscounts、AddTax、SubtractFromCustomerBalance四个功能明确且可读性更好的小方法。 using System.Collections.Generic; using System.Linq; namespace LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.Before { public class CashRegister { public CashRegister() { Tax = 0.06m; } private decimal Tax { get; set; } public void AcceptPayment(Customer customer, IEnumerable\u003cProduct\u003e products, decimal payment) { decimal subTotal = 0m; foreach (Product product in products) { subTotal += product.Price; } foreach (Product product in products) { subTotal -= product.AvailableDiscounts; } decimal grandTotal = subTotal * Tax; customer.DeductFromAccountBalance(grandTotal); } } public class Customer { public void DeductFromAccountBalance(decimal amount) { // deduct from balance } } public class Product { public decimal Price { get; set; } public decimal AvailableDiscounts { get; set; } } } using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After { public class CashRegister { public CashRegister() { Tax = 0.06m; } private decimal Tax { get; set; } private IEnumerable\u003cProduct\u003e Products { get; set; } public void AcceptPayment(Customer customer, IEnumerable\u003cProduct\u003e products, decimal payment) { decimal subTotal = CalculateSubtotal(); subTotal = SubtractDiscounts(subTotal); decimal grandTotal = AddTax(subTotal); SubtractFromCustomerBalance(customer, grandTotal); } private void SubtractFromCustomerBalance(Customer customer, decimal grandTotal) { customer.DeductFromAccountBalance(grandTotal); } private decimal AddTax(decimal subTotal) { return subTotal * Tax; } private decimal SubtractDiscounts(decimal subTotal) { foreach (Product product in Products) { subTotal -= product.AvailableDiscounts; } return subTotal; } private decimal CalculateSubtotal() { decimal subTotal = 0m; foreach (Product product in Products) { subTotal += product.Price; } return subTotal; } } public class Customer { public void DeductFromAccountBalance(decimal amount) { // deduct from balance } } public class Product { public decimal Price { get; set; } public decimal AvailableDiscounts { get; set; } } } 总结：其实这个重构和我们前面讲的“提取方法”和“提取方法对象”如出一辙，尤其是“提取方法”，所以大家只要知道用这种思想重构就行。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:22:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"23.引入参数对象 概念：本文中的“引入参数对象”是指当一个方法的参数过多或者过为复杂时，可以考虑把这些参数封装成一个单独的类。 正文：如果一个方法所需要的参数大于5个，理解该方法的签名就变得比较困难，因为这样感觉参数很长、样式不好并且没有分类，所以我们有必要把参数进行封装。 通常这种情形下创建一个用户传递参数的类是很有帮助的，这会使得代码更容易明白也更灵活，因为当你需要增加参数时，只需要给参数类添加一个属性即可。请注意只有当你发现方法的参数比较多时才应该应用该重构，如果方法的参数比较少，就没有必要应用此重构，因为该重构会增加系统中类的数量，同时也会加大维护负担。所以要看参数情况而定。 重构后的代码如下： namespace LosTechies.DaysOfRefactoring.SampleCode.ParameterObject.Before { public class Registration { public void Create(decimal amount, Student student, IEnumerable\u003cCourse\u003e courses, decimal credits) { // do work } } } using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.SampleCode.ParameterObject.After { public class RegistrationContext { public decimal Amount { get; set; } public Student Student { get; set; } public IEnumerable\u003cCourse\u003e Courses { get; set; } public decimal Credits { get; set; } } public class Registration { public void Create(RegistrationContext registrationContext) { // do work } } } 总结：这种重构很重要，尤其是当一个方法的参数比较多的时候，不管是大中型项目还是小型项目，都会遇到这种场景，所以建议大家多使用这个重构。这种封装的思想在SOA 里面也经常运用到，封装输入Message，封装输出Message，消息来和消息去以及消息间的交互就构成了整个应用体系。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:23:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"24.分解复杂判断 概念：本文中的”分解复杂判断”是指把原来复杂的条件判断等语句用尽快返回等方式简化代码。 正文：简单的来说，当你的代码中有很深的嵌套条件时，花括号就会在代码中形成一个长长的箭头。我们经常在不同的代码中看到这种情况，并且这种情况也会扰乱代码的可读性。 如下代码所示，HasAccess方法里面包含一些嵌套条件，如果再加一些条件或者增加复杂度，那么代码就很可能出现几个问题：1，可读性差。 2，很容易出现异常。 3，性能较差。 那么重构上面的代码也很简单，如果有可能的话，尽量将条件从方法中移除，我们让代码在做处理任务之前先检查条件，如果条件不满足就尽快返回，不继续执行。下面是重构后的代码： using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace LosTechies.DaysOfRefactoring.SampleCode.ArrowheadAntipattern.Before { public class Security { public ISecurityChecker SecurityChecker { get; set; } public Security(ISecurityChecker securityChecker) { SecurityChecker = securityChecker; } public bool HasAccess(User user, Permission permission, IEnumerable\u003cPermission\u003e exemptions) { bool hasPermission = false; if (user != null) { if (permission != null) { if (exemptions.Count() == 0) { if (SecurityChecker.CheckPermission(user, permission) || exemptions.Contains(permission)) { hasPermission = true; } } } } return hasPermission; } } } using System.Collections.Generic; using System.Linq; namespace LosTechies.DaysOfRefactoring.SampleCode.ArrowheadAntipattern.After { public class Security { public ISecurityChecker SecurityChecker { get; set; } public Security(ISecurityChecker securityChecker) { SecurityChecker = securityChecker; } public bool HasAccess(User user, Permission permission, IEnumerable\u003cPermission\u003e exemptions) { if (user == null || permission == null) return false; if (exemptions.Contains(permission)) return true; return SecurityChecker.CheckPermission(user, permission); } } } 总结：这个重构很重要，它和后面讲的”尽快返回“有些类似，我们在做复杂的处理过程时，要经常考虑这个重构，用好了它，会对我们的帮助很大。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:24:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"25.引入契约式设计 概念：本文中的”引入契约式设计”是指我们应该对应该对输入和输出进行验证，以确保系统不会出现我们所想象不到的异常和得不到我们想要的结果。 正文：契约式设计规定方法应该对输入和输出进行验证，这样你便可以保证你得到的数据是可以工作的，一切都是按预期进行的，如果不是按预期进行，异常或是错误就应该被返回，下面我们举的例子中，我们方法中的参数可能会值为null的情况，在这种情况下由于我们没有验证，NullReferenceException异常会报出。另外在方法的结尾处我们也没有保证会返回一个正确的decimal值给调用方法的对象。 对上面的代码重构是很简单的，首先我们处理不会有一个null值的customer对象，检查我们最少会有一个product对象。在返回订单总和 之前先确保我们会返回一个有意义的值。如果上面说的检查有任何一个失败，我们就抛出对应的异常，并在异常里说明错误的详细信息，而不是直接抛出 NullReferenceException。 上面的代码中添加了额外的代码来进行验证，虽然看起来代码复杂度增加了，但我认为这是非常值得做的，因为当NullReferenceException发生时去追查异常的详细信息真是很令人讨厌的事情。 using System;using System.Collections.Generic; using System.Linq;using System.Text; namespace LosTechies.DaysOfRefactoring.SampleCode.Day25_DesignByContract { public class CashRegister { public decimal TotalOrder(IEnumerable\u003cProduct\u003e products, Customer customer) { decimal orderTotal = products.Sum(product =\u003e product.Price); customer.Balance += orderTotal; return orderTotal; } } } using System; using System.Collections.Generic; using System.Linq; using System.Text; using Microsoft.Contracts; namespace LosTechies.DaysOfRefactoring.SampleCode.DesignByContract.After { public class CashRegister { public decimal TotalOrder(IEnumerable\u003cProduct\u003e products, Customer customer) { if (customer == null) throw new ArgumentNullException(\"customer\", \"Customer cannot be null\"); if (products.Count() == 0) throw new ArgumentException(\"Must have at least one product to total\", \"products\"); decimal orderTotal = products.Sum(product =\u003e product.Price); customer.Balance += orderTotal; if (orderTotal == 0) throw new ArgumentOutOfRangeException(\"orderTotal\", \"Order Total should not be zero\"); return orderTotal; } } } 总结：微软在处理代码乃至产品的时候，很喜欢应用此重构，你如果认真看它的代码库，认真看一下WCF的设计，就不难发现了。这个重构建议大家经常使用，这会增强整个系统的稳定性和健壮性。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:25:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"26.避免双重否定 概念：本文中的”避免双重否定”是指把代码中的双重否定语句修改成简单的肯定语句，这样即让代码可读，同时也给维护带来了方便。 正文：避免双重否定重构本身非常容易实现，但我们却在太多的代码中见过因为双重否定降低了代码的可读性以致于非常让人容易误解真正意图。存在双重否定的代码具有非常大的危害性，因为这种类型的代码容易引起错误的假设，错误的假设又会导致书写出错误的维护代码，最终会导致bug产生。具 体可以看下面的代码： 如上代码中的双重否定可读性非常低，因为我们很难搞明白双重否定的正确值。要重构它也非常容易，如下是重构后的代码： using System.Collections.Generic; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; namespace LosTechies.DaysOfRefactoring.SampleCode.DoubleNegative.Before { public class Order { public void Checkout(IEnumerable\u003cProduct\u003e products, Customer customer) { if (!customer.IsNotFlagged) { // the customer account is flagged // log some errors and return return; } // normal order processing } } public class Customer { public decimal Balance { get; private set; } public bool IsNotFlagged { get { return Balance \u003c 30m; } } } } using System.Collections.Generic; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; namespace LosTechies.DaysOfRefactoring.SampleCode.DoubleNegative.After { public class Order { public void Checkout(IEnumerable\u003cProduct\u003e products, Customer customer) { if (customer.IsFlagged) { // the customer account is flagged // log some errors and return return; } // normal order processing } } public class Customer { public decimal Balance { get; private set; } public bool IsFlagged { get { return Balance \u003e= 30m; } } } } 总结： ”双重否定“很容易让人产生错误的判断，也很难让人理解你的代码，所以这个重构在我们的代码中是很重要的，尤其是在判断条件很多且业务复杂的时候。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:26:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"27.去除上帝类 概念：本文中的”去除上帝类”是指把一个看似功能很强且很难维护的类，按照职责把自己的属性或方法分派到各自的类中或分解成功能明确的类，从而去掉上帝类。 正文：我们经常可以在一些原来的代码中见到一些类明确违反了SRP原则（单一原则），这些类通常以“Utils”或“Manager”后缀 结尾，但有时这些类也没有这些特征，它仅仅是多个类多个方法的组合。另一个关于上帝类的特征是通常这些类中的方法被用注释分隔为不同的分组。那么久而久之，这些类被转换为那些没有人愿意进行归并到合适类的方法的聚集地，对这些类进行重构是将类中的代码按照职责分派到各自的类中，这样就解除了上帝类，也减轻了维护的负担。 我们看到要重构上面的代码是很简单的，只要将相关的方法按职责分派到对应的类中即可，带来的好处就是这会降低代码的颗粒度并减少未来维护代码的成本。下面是重构后的代码，它将上面的代码按照职责分为了两个不同的类。 using System.Collections.Generic; using LosTechies.DaysOfRefactoring.EncapsulateCollection.After; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; using Customer = LosTechies.DaysOfRefactoring.BreakResponsibilities.After.Customer; namespace LosTechies.DaysOfRefactoring.SampleCode.RemoveGodClasses.Before { public class CustomerService { public decimal CalculateOrderDiscount(IEnumerable\u003cProduct\u003e products, Customer customer) {$$ // do work } public bool CustomerIsValid(Customer customer, Order order) { // do work } public IEnumerable\u003cstring\u003e GatherOrderErrors(IEnumerable\u003cProduct\u003e products, Customer customer) { // do work } public void Register(Customer customer) { // do work } public void ForgotPassword(Customer customer) { // do work } } } using System.Collections.Generic; using LosTechies.DaysOfRefactoring.EncapsulateCollection.After; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; using Customer = LosTechies.DaysOfRefactoring.BreakResponsibilities.After.Customer; namespace LosTechies.DaysOfRefactoring.SampleCode.RemoveGodClasses.After { public class CustomerOrderService { public decimal CalculateOrderDiscount(IEnumerable\u003cProduct\u003e products, Customer customer) { // do work } public bool CustomerIsValid(Customer customer, Order order) { // do work } public IEnumerable\u003cstring\u003e GatherOrderErrors(IEnumerable\u003cProduct\u003e products, Customer customer) { // do work } } public class CustomerRegistrationService { public void Register(Customer customer) { // do work } public void ForgotPassword(Customer customer) { // do work } } } 总结： ”去除上帝类“是我们经常容易造成的，第一是因为简便，看到有一个现成的类，大家都会喜欢把代码往里面写，最后导致越写越大，并且声明功能都有，这样即降低了可读性，也造成了维护的负担。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:27:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"28.为布尔方法命名 概念：本文中的”为布尔方法命名”是指如果一个方法带有大量的bool 参数时，可以根据bool 参数的数量，提取出若干个独立的方法来简化参数。 正文：我们现在要说的重构并不是普通字面意义上的重构，它有很多值得讨论的地方。当一个方法带有大量的bool 参数时，会导致方法很容易被误解并产生非预期的行为， 根据布尔型参数的数量，我们可以决定提取出若干个独立的方法来。具体代码如下： 我们可以将上面的bool参数以独立方法的形式暴露给调用端以提高代码的可读性，同时我们还需要将原来的方法改为private以限制其可访问性。显然我们关于要 提取的独立方法会有一个很大的排列组合，这是一大缺点，所以我们可以考虑引入”参数对象“重构。 using LosTechies.DaysOfRefactoring.BreakResponsibilities.After; namespace LosTechies.DaysOfRefactoring.SampleCode.RenameBooleanMethod.Before { public class BankAccount { public void CreateAccount(Customer customer, bool withChecking, bool withSavings, bool withStocks) { // do work } } } using LosTechies.DaysOfRefactoring.BreakResponsibilities.After; namespace LosTechies.DaysOfRefactoring.SampleCode.RenameBooleanMethod.After { public class BankAccount { public void CreateAccountWithChecking(Customer customer) { CreateAccount(customer, true, false); } public void CreateAccountWithCheckingAndSavings(Customer customer) { CreateAccount(customer, true, true); } private void CreateAccount(Customer customer, bool withChecking, bool withSavings) { // do work } } } 总结： ”为布尔方法命名“这个重构在很多时候都不常用，如果用户的参数可枚举，我们一般会枚举它的值，不过使用这种重构也有好处，就是分解开来以后，方法多了，参数少了，代码维护起来方便了一些。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:28:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"29.去除中间人对象 概念：本文中的”去除中间人对象”是指把在中间关联而不起任何其他作用的类移除，让有关系的两个类直接进行交互。 正文：有些时候在我们的代码会存在一些”幽灵类“，设计模式大师Fowler称它们为“中间人”类，“中间人”类除了调用别的对象之外不做任何事情，所以“中间人”类没有存在的必要，我们可以将它们从代码中删除，从而让交互的两个类直接关联。 如下代码所示，Consumer 类要得到AccountDataProvider 的数据，但中间介入了没起任何作用的AccountManager 类来关联，所以我们应当移除。 重构后的代码如下所示，Consumer 和AccountDataProvider 直接进行关联，这样代码就简单了。 using LosTechies.DaysOfRefactoring.PullUpField.After; namespace LosTechies.DaysOfRefactoring.SampleCode.RemoveMiddleMan.Before { public class Consumer { public AccountManager AccountManager { get; set; } public Consumer(AccountManager accountManager) { AccountManager = accountManager; } public void Get(int id) { Account account = AccountManager.GetAccount(id); } } public class AccountManager { public AccountDataProvider DataProvider { get; set; } public AccountManager(AccountDataProvider dataProvider) { DataProvider = dataProvider; } public Account GetAccount(int id) { return DataProvider.GetAccount(id); } } public class AccountDataProvider { public Account GetAccount(int id) { // get account } } } using LosTechies.DaysOfRefactoring.PullUpField.After; namespace LosTechies.DaysOfRefactoring.SampleCode.RemoveMiddleMan.After { public class Consumer { public AccountDataProvider AccountDataProvider { get; set; } public Consumer(AccountDataProvider dataProvider) { AccountDataProvider = dataProvider; } public void Get(int id) { Account account = AccountDataProvider.GetAccount(id); } } public class AccountDataProvider { public Account GetAccount(int id) { // get account } } } 总结： ”去除中间人对象“很多时候都会很有作用，尤其是在误用设计模式的代码中最容易见到，设计模式中的适配器模式和代理模式等都用中间的类是两者进行关联，这是比较合理的，因为中间类做了很多事情，而对于没有任何作用的中间类应该移除。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:29:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"30.尽快返回 概念： 本文中的”尽快返回”是指把原来复杂的条件判断等语句用尽快返回的方式简化代码。 正文：如首先声明的是前面讲的”分解复杂判断“，简单的来说，当你的代码中有很深的嵌套条件时，花括号就会在代码中形成一个长长的箭头。我们经常在不同的代码中看到这种情况，并且这种情况也会扰乱代码的可读性。下代码所示，HasAccess方法里面包含一些嵌套条件，如果再加一些条件或者增加复杂度，那么代码就很可能出现几个问题：1，可读性差 2，很容易出现异常 3，性能较差 那么重构上面的代码也很简单，如果有可能的话，尽量将条件判断从方法中移除，我们让代码在做处理任务之前先检查条件，如果条件不满足就尽快返回，不继续执行。 下面是重构后的代码： using System.Collections.Generic; using System.Linq; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; using Customer = LosTechies.DaysOfRefactoring.BreakResponsibilities.After.Customer; namespace LosTechies.DaysOfRefactoring.SampleCode.ReturnASAP.Before { public class Order { public Customer Customer { get; private set; } public decimal CalculateOrder(Customer customer, IEnumerable\u003cProduct\u003e products, decimal discounts) { Customer = customer; decimal orderTotal = 0m; if (products.Count() \u003e 0) { orderTotal = products.Sum(p =\u003e p.Price); if (discounts \u003e 0) { orderTotal -= discounts; } } return orderTotal; } } } using System.Collections.Generic; using System.Linq; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; using Customer = LosTechies.DaysOfRefactoring.BreakResponsibilities.After.Customer; namespace LosTechies.DaysOfRefactoring.SampleCode.ReturnASAP.After { public class Order { public Customer Customer { get; private set; } public decimal CalculateOrder(Customer customer, IEnumerable\u003cProduct\u003e products, decimal discounts) { if (products.Count() == 0) return 0; Customer = customer; decimal orderTotal = products.Sum(p =\u003e p.Price); if (discounts == 0) return orderTotal; orderTotal -= discounts; return orderTotal; } } } 总结： 总结：这个重构很重要，它和前面讲的”分解复杂判断“有些类似，我们在做复杂的处理过程时，要经常考虑这个重构，用好了它，会对我们的帮助很大。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:30:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"31.使用多态代替条件判断 概念：本文中的”使用多态代替条件判断”是指如果你需要检查对象的类型或者根据类型执行一些操作时，一种很好的办法就是将算法封装到类中，并利用多态性进行抽象调用。 正文：本文展示了面向对象编程的基础之一“多态性”， 有时你需要检查对象的类型或者根据类型执行一些操作时，一种很好的办法就是将算法封装到类中，并利用多态性进行抽象调用。 如下代码所示，OrderProcessor 类的ProcessOrder方法根据Customer 的类型分别执行一些操作，正如上面所讲的那样，我们最好将OrderProcessor 类中这些算法（数据或操作）封装在特定的Customer 子类中。 重构后的代码如下，每个Customer 子类都封装自己的算法，然后OrderProcessor 类的ProcessOrder方法的逻辑也变得简单并且清晰了。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; namespace LosTechies.DaysOfRefactoring.SampleCode.ReplaceWithPolymorphism.Before { public abstract class Customer { } public class Employee : Customer { } public class NonEmployee : Customer { } public class OrderProcessor { public decimal ProcessOrder(Customer customer, IEnumerable\u003cProduct\u003e products) { // do some processing of order decimal orderTotal = products.Sum(p =\u003e p.Price); Type customerType = customer.GetType(); if (customerType == typeof(Employee)) { orderTotal -= orderTotal * 0.15m; } else if (customerType == typeof(NonEmployee)) { orderTotal -= orderTotal * 0.05m; } return orderTotal; } } } using System; using System.Collections.Generic; using System.Linq; using System.Text; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; namespace LosTechies.DaysOfRefactoring.SampleCode.ReplaceWithPolymorphism.After { public abstract class Customer { public abstract decimal DiscountPercentage { get; } } public class Employee : Customer { public override decimal DiscountPercentage { get { return 0.15m; } } } public class NonEmployee : Customer { public override decimal DiscountPercentage { get { return 0.05m; } } } public class OrderProcessor { public decimal ProcessOrder(Customer customer, IEnumerable\u003cProduct\u003e products) { // do some processing of order decimal orderTotal = products.Sum(p =\u003e p.Price); orderTotal -= orderTotal * customer.DiscountPercentage; return orderTotal; } } } 总结： ”使用多态代替条件判断“这个重构在很多时候会出现设计模式中（常见的工厂家族、策略模式等都可以看到它的影子），因为运用它可以省去很多的条件判断，同时也能简化代码、规范类和对象之间的职责。 版权声明：本文为CSDN博主「kunlong0909」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/kunlong0909/article/details/47606791 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:31:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["架构艺术"],"content":"概述 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"什么是Redis Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。 Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。 与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis有哪些优缺点 优点 读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。 支持数据持久化，支持AOF和RDB两种持久化方式。 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。 数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。 缺点 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。 Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"为什么要用 Redis /为什么要用缓存 主要从“高性能”和“高并发”这两点来看待这个问题。 高性能： 假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！ 高并发： 直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"为什么要用 Redis 而不用 map/guava 做缓存? 缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。 使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis为什么这么快 1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)； 2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的； 3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 4、使用多路 I/O 复用模型，非阻塞 IO； 5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"数据类型 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:2:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis有哪些数据类型 Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求 数据类型 可以存储的值 操作 应用场景 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作, 对整数和浮点数执行自增或者自减操作 做简单的键值对缓存 LIST 列表 从两端压入或者弹出元素,对单个或者多个元素进行修剪;只保留一个范围内的元素 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据 SET 无序集合 添加、获取、移除单个元素;检查一个元素是否存在于集合中;计算交集、并集、差集; 从集合里面随机获取元素 交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对;获取所有键值对;检查某个键是否存在 结构化的数据，比如一个对象 ZSET 有序集合 添加、获取、删除元素;根据分值范围或者成员来获取元素;计算一个键的排名 去重但可以排序，如获取排名前几名的用户 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:2:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis的应用场景 总结一 计数器: 可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 缓存: 将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 会话缓存: 可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。 全页缓存（FPC）: 除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 查找表: 例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 消息队列(发布/订阅功能): List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。 分布式锁实现: 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。 其它: Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。 总结二 Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。 数据类型说明string字符串，最简单的k-v存储hashhash格式，value为field和value，适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有序的set 其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。 string——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。 hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。 list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。 set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。 Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。 如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用Redis的性能。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:2:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"持久化 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"什么是Redis持久化？ 持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis 的持久化机制是什么？各自的优缺点？ Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制: RDB：是Redis DataBase缩写快照 RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。 优点： 1、只有一个文件 dump.rdb，方便持久化。 2、容灾性好，一个文件可以保存到安全的磁盘。 3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能 4.相对于数据集大时，比 AOF 的启动效率更高。 缺点： 1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候) 2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。 AOF：持久化 AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。 当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。 优点： 1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。 2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。 3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）) 缺点： 1、AOF 文件比 RDB 文件大，且恢复速度慢。 2、数据集大的时候，比 rdb 启动效率低。 优缺点是什么？ AOF文件比RDB更新频率高，优先使用AOF还原数据。 AOF比RDB更安全也更大 RDB性能比AOF好 如果两个都配了优先加载AOF ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"如何选择合适的持久化方式 一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。 有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。 如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis持久化数据和缓存怎么做扩容？ 如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。 如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"过期键的删除策略 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:4:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis的过期键的删除策略 我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。 过期策略通常有以下三种： 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。) Redis中同时使用了惰性过期和定期过期两种过期策略。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:4:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis key的过期时间和永久有效分别怎么设置？ EXPIRE和PERSIST命令。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:4:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢? 除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种： 定时去清理过期的缓存； 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:4:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"内存相关 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据 redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis的内存淘汰策略有哪些 Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。 全局的键空间选择性移除 noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的） allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。 设置过期时间的键空间选择性移除 volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。 volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。 volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。 总结 Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis主要消耗什么物理资源？ 内存。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis的内存用完了会发生什么？ 如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis如何做内存优化？ 可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"线程模型 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:6:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis线程模型 Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。 虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。 参考：https://www.cnblogs.com/barrywxx/p/8570821.html ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:6:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"事务 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"什么是事务？ 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis事务的概念 Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。 总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis事务的三个阶段 事务开始 MULTI 命令入队 事务执行 EXEC 事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis事务相关命令 Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。 redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。 如果在一个事务中的命令出现错误，那么所有的命令都不会执行； 如果在一个事务中出现运行错误，那么正确的命令会被执行。 WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。 MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。 EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。 UNWATCH命令可以取消watch对所有key的监控。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"事务管理（ACID）概述 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务前后数据的完整性必须保持一致。 隔离性（Isolation） 多个事务并发执行时，一个事务的执行不应影响其他事务的执行 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在_AOF_持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis事务支持隔离性吗 Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:6","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis事务保证原子性吗，支持回滚吗 Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:7","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis事务其他实现 基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行， 其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完 基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:8","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"集群方案 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"哨兵模式 哨兵的介绍 sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能： 集群监控：负责监控 redis master 和 slave 进程是否正常工作。 消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。 哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。 故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。 哨兵的核心知识 哨兵至少需要 3 个实例，来保证自己的健壮性。 哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。 对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"官方Redis Cluster 方案(服务端路由查询) redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？ 简介 Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行 方案说明 通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位 每份数据分片会存储在多个互为主从的多节点上 数据写入先写主节点，再同步到从节点(支持配置为阻塞同步) 同一分片多个节点间的数据不保持一致性 读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点 扩容时时需要需要把旧节点的数据迁移一部分到新节点 在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。 16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。 节点间的内部通信机制 基本通信原理 集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。 分布式寻址算法 hash 算法（大量缓存重建） 一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡） redis cluster 的 hash slot 算法 优点 无中心架构，支持动态扩容，对业务透明 具备Sentinel的监控和自动Failover(故障转移)能力 客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可 高性能，客户端直连redis服务，免去了proxy代理的损耗 缺点 运维也很复杂，数据迁移需要人工干预 只能使用0号数据库 不支持批量操作(pipeline管道操作) 分布式逻辑和存储模块耦合等 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"基于客户端分配 简介 Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool 优点 优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强 缺点 由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。 客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"基于代理服务器分片 简介 客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端 特征 透明接入，业务程序不用关心后端Redis实例，切换成本低 Proxy 的逻辑和存储的逻辑是隔离的 代理层多了一次转发，性能有所损耗 业界开源方案 Twtter开源的Twemproxy 豌豆荚开源的Codis ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis 主从架构 单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。 redis replication -\u003e 主从架构 -\u003e 读写分离 -\u003e 水平扩容支撑读高并发 redis replication 的核心机制 redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量； 一个 master node 是可以配置多个 slave node 的； slave node 也可以连接其他的 slave node； slave node 做复制的时候，不会 block master node 的正常工作； slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了； slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。 注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。 另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。 redis 主从复制的核心原理 当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。 如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件， 同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中， 接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。 slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。 过程原理 当从库和主库建立MS关系后，会向主数据库发送SYNC命令 主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来 当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis 从Redis接收到后，会载入快照文件并且执行收到的缓存的命令 之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致 缺点 所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis集群的主从复制模型是怎样的？ 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:6","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"生产环境中的 redis 是怎么部署的？ redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。 机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。 5 台机器对外提供读写，一共有 50g 内存。 因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。 你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。 其实大型的公司，会有基础架构的 team 负责缓存集群的运维。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:7","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"说说Redis哈希槽的概念？ Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:8","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis集群会有写操作丢失吗？为什么？ Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:9","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis集群之间是如何复制的？ 异步复制 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:10","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis集群最大节点个数是多少？ 16384个 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:11","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis集群如何选择数据库？ Redis集群目前无法做数据库选择，默认在0数据库。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:12","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"分区 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis是单线程的，如何提高多核CPU的利用率？ 可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"为什么要做Redis分区？ 分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"你知道有哪些Redis分区实现方案？ 客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。 代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy 查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis分区有什么缺点？ 涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。 同时操作多个key,则不能使用Redis事务. 分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set） 当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。 分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"分布式问题 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis实现分布式锁 Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。 当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作 SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。 返回值：设置成功，返回 1 。设置失败，返回 0 。 使用SETNX完成同步锁的流程及事项如下： 使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功 为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间 释放锁，使用DEL命令将锁数据删除 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"如何解决 Redis 的并发竞争 Key 问题 所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！ 推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能） 基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。 在实践中，当然是从以可靠性为主。所以首推Zookeeper。 参考：https://www.jianshu.com/p/8bddd381de06 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"分布式Redis是前期做还是后期规模上来了再做好？为什么？ 既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。 一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。 这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"什么是 RedLock Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性： 安全特性：互斥访问，即永远只有一个 client 能拿到锁 避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区 容错性：只要大部分 Redis 节点存活就可以正常提供服务 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存异常 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存雪崩 缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。 解决方案 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。 给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存穿透 缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。 解决方案 接口层增加校验，如用户鉴权校验，id做基础校验，id\u003c=0的直接拦截； 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力 附加 对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。 Bitmap： 典型的就是哈希表 缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。 布隆过滤器（推荐） 就是引入了k(k\u003e1)k(k\u003e1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。 Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。 Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。 Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存击穿 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 解决方案 设置热点数据永远不过期。 加互斥锁，互斥锁 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存预热 缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 解决方案 直接写个缓存刷新页面，上线时手工操作一下； 数据量不大，可以在项目启动的时候自动进行加载； 定时刷新缓存； ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存降级 当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。 在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案： 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警； 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。 服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"热点数据和冷数据 热点数据，缓存才有价值 对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存 对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。 数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。 那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:6","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存热点key 缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 解决方案 对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:7","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"常用工具 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:12:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis支持的Java客户端都有哪些？官方推荐用哪个？ Redisson、Jedis、lettuce等等，官方推荐使用Redisson。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:12:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis和Redisson有什么关系？ Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:12:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Jedis与Redisson对比有什么优缺点？ Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:12:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"其他问题 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis与Memcached的区别 两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同： 对比参数 Redis Memcached 类型 1. 支持内存 2. 非关系型数据库 1. 支持内存 2. 键值对形式 3. 缓存形式 数据存储类型 1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】 1. 文本型 2. 二进制类型 查询【操作】类型 1. 批量操作 2. 事务支持 3. 每个类型不同的CRUD 1.常用的CRUD 2. 少量的其他命令 附加功能 1. 发布/订阅模式 2. 主从分区 3. 序列化支持 4. 脚本支持【Lua脚本】 1. 多线程服务支持 网络IO模型 1. 单线程的多路 IO 复用模型 1. 多线程，非阻塞IO模式 事件库 自封转简易事件库AeEvent 贵族血统的LibEvent事件库 持久化支持 1. RDB 2. AOF 不支持 集群模式 原生支持 cluster 模式，可以实现主从复制，读写分离 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据 内存管理机制 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘 Memcached 的数据则会一直在内存中，Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 适用场景 复杂数据结构，有持久化，高可用需求，value存储内容较大 纯key-value，数据量非常大，并发量非常大的业务 (1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 (2) redis的速度比memcached快很多 (3) redis可以持久化其数据 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"如何保证缓存与数据库双写时的数据一致性？ 你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？ 一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况 串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。 还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后再删除缓存。 问题场景 描述 解决 先写缓存，再写数据库，缓存写成功，数据库写失败 缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读 这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存 先写数据库，再写缓存，数据库写成功，缓存写失败 写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据 缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现 需要缓存异步刷新 指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候 确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis常见性能问题和解决方案？ Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。 如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。 为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。 尽量避免在压力较大的主库上增加从库 Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。 为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master\u003c–Slave1\u003c–Slave2\u003c–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis官方为什么不提供Windows版本？ 因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"一个字符串类型的值能存储最大容量是多少？ 512M ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis如何做大量数据插入？ Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:6","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？ 使用keys指令可以扫出指定模式的key列表。 对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？ 这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:7","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"使用Redis做过异步队列吗，是如何实现的 使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:8","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis如何实现延时队列 使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:9","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis回收进程如何工作的？ 一个客户端运行了新的命令，添加了新的数据。 Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。 一个新的命令被执行，等等。 所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。 如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:10","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis回收使用的是什么算法？ LRU算法 版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/ThinkWon/article/details/103522351 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:11","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"为什么使用MQ？MQ的优点 简答 异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。 流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。 日志处理 - 解决大量日志传输。 消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。 详答 主要是：解耦、异步、削峰。 解耦：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。 就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。 异步：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。 削峰：减少高峰时期对服务器压力。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:1:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息队列有什么优缺点？RabbitMQ有什么优缺点？ 优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。 缺点有以下几个： 系统可用性降低 本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低； 系统复杂度提高 加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。 一致性问题 A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。 所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:2:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"你们公司生产环境用的是什么消息中间件？ 这个首先你可以说下你们公司选用的是什么消息中间件，比如用的是RabbitMQ，然后可以初步给一些你对不同MQ中间件技术的选型分析。 举个例子：比如说ActiveMQ是老牌的消息中间件，国内很多公司过去运用的还是非常广泛的，功能很强大。 但是问题在于没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企业，用ActiveMQ做异步调用和系统解耦。 然后你可以说说RabbitMQ，他的好处在于可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。 另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。 而且经过调研，国内各大互联网公司落地大规模RabbitMQ集群支撑自身业务的case较多，国内各种中小型互联网公司使用RabbitMQ的实践也比较多。 除此之外，RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化，因此综合考虑过后，公司采取了RabbitMQ。 但是RabbitMQ也有一点缺陷，就是他自身是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以。 然后可以聊聊RocketMQ，是阿里开源的，经过阿里的生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。 而且RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。 另外就是Kafka。Kafka提供的消息中间件的功能明显较少一些，相对上述几款MQ中间件要少很多。 但是Kafka的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。 因此Kafka在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:3:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？ ActiveMQ RabbitMQ RocketMQ Kafka ZeroMQ 单机吞吐量 比RabbitMQ低 2.6w/s（消息做持久化） 11.6w/s 17.3w/s 29w/s 开发语言 Java Erlang Java Scala/Java C 主要维护者 Apache Mozilla/Spring Alibaba Apache iMatix，创始人已去世 成熟度 成熟 成熟 开源版本不够成熟 比较成熟 只有C、PHP等版本成熟 订阅形式 点对点(p2p)、广播（发布-订阅） 提供了4种：direct, topic ,Headers和fanout。fanout就是广播模式 基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式 基于topic以及按照topic进行正则匹配的发布订阅模式 点对点(p2p) 持久化 支持少量堆积 支持少量堆积 支持大量堆积 支持大量堆积 不支持 顺序消息 不支持 不支持 支持 支持 不支持 性能稳定性 好 好 一般 较差 很好 集群方式 支持简单集群模式，比如’主-备’，对高级集群模式支持不好。 支持简单集群，‘复制’模式，对高级集群模式支持不好。 常用 多对’Master-Slave’ 模式，开源版本需手动切换Slave变成Master 天然的‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave 不支持 管理界面 一般 较好 一般 无 无 综上，各种对比之后，有如下建议： 一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了； 后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高； 不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。 所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。 如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:4:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"MQ 有哪些常见问题？如何解决这些问题？ MQ 的常见问题有： 消息的顺序问题 消息的重复问题 消息的顺序问题 消息有序指的是可以按照消息的发送顺序来消费。 假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？ 解决方案： （1）保证生产者 - MQServer - 消费者是一对一对一的关系 缺陷： 并行度就会成为消息系统的瓶颈（吞吐量不够） 更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。 （2）通过合理的设计或者将问题分解来规避。 不关注乱序的应用实际大量存在 队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。 消息的重复问题 造成消息重复的根本原因是：网络不可达。 所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？ 消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:5:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"什么是RabbitMQ？ RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:6:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"rabbitmq 的使用场景 （1）服务间异步通信 （2）顺序消费 （3）定时任务 （4）请求削峰 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:7:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"RabbitMQ基本概念 Broker： 简单来说就是消息队列服务器实体 Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 Routing Key： 路由关键字，exchange根据这个关键字进行消息投递 VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。 Producer： 消息生产者，就是投递消息的程序 Consumer： 消息消费者，就是接受消息的程序 Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务 由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:8:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"RabbitMQ的工作模式 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"一.simple模式（即最简单的收发模式） 1.消息产生消息，将消息放入队列 2.消息的消费者(consumer) 监听 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失，这里可以设置成手动的ack,但如果设置成手动ack，处理完后要及时发送ack消息给队列，否则会造成内存溢出)。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:1","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"二.work工作模式(资源的竞争) 1.消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2同时监听同一个队列,消息被消费。C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用)。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:2","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"三.publish/subscribe发布订阅(共享资源) 1、每个消费者监听自己的队列； 2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:3","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"四.routing路由模式 1.消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息; 2.根据业务功能定义路由字符串 3.从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中。 4.业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误; ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:4","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"五.topic 主题模式(路由模式的一种) 1.星号井号代表通配符 2.星号代表多个单词,井号代表一个单词 3.路由功能添加模糊匹配 4.消息产生者产生消息,把消息交给交换机 5.交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费 （在我的理解看来就是routing查询的一种模糊匹配，就类似sql的模糊查询方式） ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:5","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证RabbitMQ消息的顺序性？ 拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:10:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息如何分发？ 若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:11:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息怎么路由？ 消息提供方-\u003e路由-\u003e一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）； 常用的交换器主要分为一下三种： fanout：如果交换器收到消息，将会广播到所有绑定的队列上 direct：如果路由键完全匹配，消息就被投递到相应的队列 topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:12:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息基于什么传输？ 由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:13:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？ 先说为什么会重复消费：正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除； 但是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。 针对以上问题，一个解决思路是：保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；保证消息等幂性； 比如：在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过； 假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:14:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？ 发送方确认模式 将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。 一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。 如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（notacknowledged，未确认）消息。 发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。 接收方确认机制 消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。 这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性； 下面罗列几种特殊情况 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重） 如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:15:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证RabbitMQ消息的可靠传输？ 消息不可靠的情况可能是消息丢失，劫持等原因； 丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息； 生产者丢失消息：从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息； transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降； confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后； rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了； 如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。 消息队列丢数据：消息持久化。 处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。 这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。 这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。 那么如何持久化呢？ 这里顺便说一下吧，其实也很容易，就下面两步 将queue的持久化标识durable设置为true,则代表是一个持久的队列 发送消息的时候将deliveryMode=2 这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据 消费者丢失消息：消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！ 消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息； 如果这时处理消息失败，就会丢失该消息； 解决方案：处理消息成功后，手动回复确认消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:16:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"为什么不应该对所有的 message 都使用持久化机制？ 首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多，message 的吞吐量可能有 10 倍的差距。 其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现“坑爹”问题。矛盾点在于，若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed ；若 message 设置了 persistent 属性，同时 queue 也设置了 durable 属性，那么当 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在这段时间内发送给该 queue 的 message 将被 blackholed 。 所以，是否要对 message 进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条/秒以上的消息吞吐量（单 RabbitMQ 服务器），则要么使用其他的方式来确保 message 的可靠 delivery ，要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。另外一种处理原则是：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:17:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证高可用的？RabbitMQ 的集群 RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。 单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式 普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。 镜像集群模式：这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:18:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？ 消息积压处理办法：临时紧急扩容： 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。 MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。 mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:19:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"设计MQ思路 比如说这个消息队列系统，我们从以下几个角度来考虑一下： 首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -\u003e topic -\u003e partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？ 其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。 其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -\u003e leader \u0026 follower -\u003e broker 挂了重新选举 leader 即可对外服务。 能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。 版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/ThinkWon/article/details/104588612 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:20:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"1 软件架构概述 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:0","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"1.1 软件架构的定义 架构是对系统的抽象，由多个架构组成，任何软件都存在架构，元素与其行为的集合构成架构内容，架构具有“基础性”，架构隐含有“决策”。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:1","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"1.2 软件架构重要性 项目关系人之间交流平台； 早期设计决策； 在较高层面上实现软件复用； 架构对开发的指导与规范意义不容忽略。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:2","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"1.3 架构的模型 结构模型；框架模型；动态模型；过程模型；功能模型； 逻辑视图，开发视图，进程视图，物理视图，场景。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:3","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"2 架构需求与软件质量属性 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:2:0","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"2.1 软件质量属性 功能性；可靠性；易用性；效率；可维护性；可移植性； 1 运行期质量属性 性能；安全性；易用性；可伸缩性；互操作性；可靠性；持续可用性；鲁棒性； 2 开发期质量属性 易理解性；可扩展性；可重用性；可测试性；可维护性； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:2:1","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"2.2 六个质量属性与实现 质量属性：可用性；可修改性；性能；安全性；可测试性；易用性； 质量属性场景组件：刺激源；刺激；环境；制品；响应；响应度量； 1 可用性与其实现战术 可用性描述 可用性战术 错误检测：命令/响应；心跳；异常； 错误恢复 表决；主动冗余；被动冗余；备件；状态再同步；检查点/回滚； 错误预防 从服务中删除；事务；进程监视器； 2 可修改性与其实现战术 可修改性描述 可修改性战术 局部化修改；(维持语义的一致性；预期期望的变更；泛化该模块；限制可能的选择) 防止连锁反应；（信息隐藏；维持现有的接口；限制通信路径；仲裁者的使用） 推迟绑定时间；（运行时注册；配置文件；多态；构件更换；） 3 性能与其实现技术 性能描述 性能战术 资源消耗：闭锁时间； 资源需求：减少处理事件流所需的资源；减少所处理事件的数量；控制资源的使用； 资源管理：引入并发；维持数据或计算的多个副本；增加可用资源； 资源仲裁：先进先出；固定优先级调度；动态优先级调度；静态调度； 4 安全性与其实现技术 安全性描述 安全性战术 抵抗攻击：对用户进行身份验证；对用户进行授权；维护数据的机密性；维护完整性；限制暴露的信息；限制访问； 检测攻击 从攻击中恢复：恢复；识别攻击者； 5 可测试性与其实现战术 可测试性描述 可测试性战术 输入/输出：记录回放；将接口与现实分离；优化访问线路 内部监控 6 易用性与实现战术 易用性描述 易用性战术 运行时战术：任务的模型；用户的模型；系统的模型； 设计时战术 支持用户主动操作 常见的六个质量属性:可用性、可修改性、性能、安全性、可测试性、易用性。 质量属性场景是一种面向特定的质量属性的需求，由6部分组成：刺激源、刺激、环境、制品、响应、响应度量。 以《淘宝网》为例： (1)可用性: 场景：天猫双十一购物狂欢节 刺激源：海量用户 刺激：过多用户涌入抢购，系统出现崩溃的状态 制品：处理系统崩溃的处理器 环境：正常操作 响应：淘宝网监控系统记录，处理人员进行紧急处理 响应度量：短时间内恢复系统正常运行 （2）可修改性： 场景：系统进行升级 刺激源：开发人员 刺激：改变页面的形态，增加少许功能、 制品：升级完后的系统 环境：设计时 响应：修改了用户的操作页面，未产生副作用 响应度量：在15分钟左右完成升级更改 （3）性能： 场景：天猫双十一购物狂欢节 刺激源：用户 刺激：进行疯狂购物交易 制品：系统 环境：在正常操作下 响应：大量的交易同时被处理 响应度量：每个交易平均等待时间为3s (4)安全性: 场景：黑客想要盗窃用户信息 刺激源：黑客 刺激：试图通过某些手段窃取用户的信息 制品：淘宝用户信息 环境：用户不在线时 响应：对访问者进行身份上的验证 响应度量：淘宝安全系统阻止黑客访问用户信息 （5）可测试性： 场景：一个马上要执行的系统功能 刺激源：系统测试人员 刺激：对系统功能执行测试 制品：系统的某个功能 环境：功能要部署时 响应：提供对状态值的访问、提供所要计算的值，准备测试环境 响应度量：3个小时测试了85% （6）易用性： 场景：用户误将某物品移入到购物车 刺激源：用户 刺激：用户想要将物品移出 制品：系统 环境；系统运行时 响应：希望快速完成操作 响应度量：在1s内完成撤销操作 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:2:2","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3 软件架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:0","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.1 软件架构风格分类 数据流风格：批处理序列；管道\\过滤器； 调用/返回风格：主程序、子程序；面型对象风格；层次结构； 独立构件风格：进程通信；事件系统； 虚拟机风格：解释器；基于规则的系统； 仓库风格：数据库系统；超文本系统；黑板系统； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:1","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.2 数据流风格 批处理序列：批处理风格的每一步处理都是独立的，并且每一步都是顺序的。 管道和过滤器：每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。 好处：良好的隐蔽性；高内聚低耦合；简单合成；支持重用；性能简单；允许死锁分析；支持并行执行； 弊端：导致进程成为批处理；不适合处理交互式应用； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:2","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.3 调用/返回风格 主程序/子程序 面向对象风格：对负责维护其表示的完整性；对象的表示对其他对象而言是隐蔽的； 层次结构风格：支持基于抽象程度递增的系统设计；支持功能增强；支持重用； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:3","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.4 独立构件风格 进程通信架构风格：构件是独立的过程，连接件是消息传递 事件系统风格：为软件重用提供了强大的支持；为还进系统带来了方便 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:4","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.5 虚拟机风格 解释器：包括完成解释工作的解释引擎，一个包含将被解释的代码储存区，一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的 规划为中心：基于规则的系统包括规则集、规则解释器，规则/数据选择器及工作内存 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:5","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.6 仓库风格 数据库系统、超文本系统、黑板风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:6","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4 层次系统架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:0","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.1 二层及三层C/S架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:1","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.2 B/S架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:2","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.3 MVC架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:3","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.4 MVP架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:4","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5 面向服务的架构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:0","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.1 SOA概述 5.1.1 服务基本结构 5.1.2 SOA设计原则 明确定义的接口、自包含和模块化、粗粒度、松耦合、互操作性。 5.1.3 服务构件和传统构件 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:1","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.2 SOA关键技术 UUDI（统一描述、发现集成） 数据模型、API、注册服务 WSDL（web服务描述语言） 服务实现定义：服务、端口 服务接口定义：绑定、端口类型、消息、类型 SOAP（简单对象访问协议） 封装；编码规则；RPC表示；绑定； SOAP消息：封装；SOAP头；SOAP体； REST（表述性状态转移） 网络上的所有事物都被抽象为资源 每个资源对应一个唯一资源标识 通过通用链接件接口对资源进行操作 对资源各种操作不会改变资源标识 所有操作都是无状态的 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:2","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.3 SOA的实现方法 Web Service 架构：服务提供者，服务请求者，服务注册者。 操作：发布，查找，绑定。 层次：底层传输层，服务通信协议层，服务描述层，服务层，业务流程层，服务注册层 服务注册表 服务注册，服务位置，服务绑定。 企业服务总线 功能： 支持异构环境中的服务，消息和基于事件的交互，并且具有适当的服务级别和可管理级别。 可以在几乎不更改代码的情况下，以一种无缝的非入侵方式使现有系统具有全新的服务接口，并能够在部署环境中支持任何标准 充当缓冲器的ESB于服务逻辑和分离，从而使不同的系统可以同时使用同一服务，不用在系统或数据变化时改动服务代码 ESB还提供服务代码和协议转换等功能，多种传输方式，发现和使用企业服务或界面提供基础设施。 提供可配置的消息转换翻译机制和基于消息内容的消息路由服务，传输消息到不同的目的地 提供安全和拥有者机制，保证消息和服务使用的认证，授权和完整性。 优势: 扩展的、基于标准的连接。 灵活的、服务导向的应用组合。 提高复用率。 减少市场的反应时间。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:3","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.4 微服务 优势： 技术异构性，弹性，扩展，简单部署，与组织结构相匹配，可组合性，对可替代的优化。 挑战： 分布式系统的复杂度，运维成本，部署自动化，DEVOPS与组织结构，服务间的依赖测试，服务间的依赖管理 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:4","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"6 架构设计 演变交付生命周期 属性驱动设计法ADD 按架构组织开发团队 开发骨架系统 利用商业构件进行开发 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:6:0","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"7 软件架构文档化 架构文档的使用者 合理的编写规则 从读者角度编写文档，避免出现不必要的重复，避免歧义，使用标准结构，记录基本原理，文档保持更新但注意频率，针对目标的适宜性对文档进行评审 视图编档 视图概述，元素目录，上下文图，可变性指南，架构背景，术语表，其他信息。 跨视图文档 UML 软件架构重构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:7:0","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8 软件架构评估 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:0","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8.1 软件架构评估方法 基于调查问卷 基于场景 基于度量 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:1","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8.2 架构的权衡分析法ATAM 一个简洁的架构表述 表达清楚的业务目标 用场景集合捕获质量需求 架构决策到质量需求的映射 所确定的敏感点与权衡点的集合 有风险决策和无风险决策 风险主题集合 产生一些附属结果 产生一些无形的结果 步骤： ATAM方法表述 商业动机表述 架构表述 对架构方法进行分类 生成质量属性效用树 分析架构方法 集体讨论并确定场景优先级 分析架构方法 结果的表述 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:2","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8.3 成本效益分析法CBAM 步骤： 整理场景，对场景进行求精，确定场景优先级，分配效用，策略-场景-响应，质量属性响应级别效用，各架构策略的总收益， ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:3","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9 构件及其复用 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:0","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9.1 商用构件标准规范 CORBA，J2EE，DNA 2000 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:1","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9.2 应用系统簇与构件系统 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:2","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9.3 基于服用开发的组织结构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:3","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10 产品线及系统演化 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:0","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.1 复用与产品线 需求，架构设计，元素，建模与分析，测试，项目规划，过程、方法和工具，人员，样本系统，缺陷消除 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:1","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.2 基于产品线的架构 三个方面：确定变化点，支持变化点，对产品线架构的适宜性进行评估 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:2","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.3 产品线的开发模型 前瞻性产品线，反应性模型 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:3","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.4 特定领域软件架构 领域模型为需求定义率领域知识和领域词汇 软件界面的设计往往和领域模型关系密切 领域模型的合理性将严重影响软件系统的可扩展性 在分层架构指导下，领域模型精华后即成为业务层骨架 领域模型也是其数据模型的基础 领域模型是团队交流的基础 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:4","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.4 架构及系统演化 需求变动归类，制订架构演化计划，修改增加删除构件，更新构件的互相作用，构架组装和测试，技术评审，产生演化后的架构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:5","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11 软件架构视图 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:0","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.1 软件视图分类 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:1","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.2 模块视图类型及其风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:2","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.3 C\u0026C视图类型及其风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:3","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.4 分配视图类型及其风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:4","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.5 各视图类型间的映射关系 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:5","tags":["架构","系统架构师"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["概要"],"content":"自定义扩展 ","date":"2021-05-26","objectID":"https://blog.gethin.online/second-post/:1:0","tags":[],"title":"自定义扩展功能测试","uri":"https://blog.gethin.online/second-post/"},{"categories":["概要"],"content":"脑图测试 Root l1 l11 l12 l2 l12 l121 l122 l13 l3 l31 l313 l323 Test1 ABC 2021 function non0plural(number, name) { if (number == 0) { return \"\" } if (number == 1 || number == -1) { return number + \" \" +name } return number + \" \" + name + \"s\" } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2021-05-01\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 let years = 0 if (months Test 11 months ABC 2020 ","date":"2021-05-26","objectID":"https://blog.gethin.online/second-post/:1:1","tags":[],"title":"自定义扩展功能测试","uri":"https://blog.gethin.online/second-post/"},{"categories":["概要"],"content":"网站功能 文章加密 自定义域名 网站分析 脑图 时间轴 评论的优化 关于页面的优化 版权声明 运行时间 赞赏 网站流量统计 ","date":"2021-05-22","objectID":"https://blog.gethin.online/blog-todo/:1:0","tags":["待办事项"],"title":"博客代办事项","uri":"https://blog.gethin.online/blog-todo/"},{"categories":["概要"],"content":"编辑 新文章头部模板 ","date":"2021-05-22","objectID":"https://blog.gethin.online/blog-todo/:2:0","tags":["待办事项"],"title":"博客代办事项","uri":"https://blog.gethin.online/blog-todo/"},{"categories":["语言与平台"],"content":"自然拼读 ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:0","tags":["english"],"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["语言与平台"],"content":"元音 a am pam sam ad dad at cat rat an van man ran ap cap nap lap ab cab lab tab ag bag rag wag ack jack back sack pack ant pant Kant rant ang bang hang sang ank bank rank sank tank amp lamp camp ramp e ed Ted red en ten hen ell bell sell eg egg meg leg beg et jet get wet ess Bess less mess end bend mend send ent Kent bent sent went tent est best pest nest test west eck neck peck deck i id Sid kid ig pig dig ill Jill hill kill it sit fit hit pit im Tim Jim Kim dim in fin win tin pin ing ding ring king sing ink pink sink link ish fish dish wish ick pick kick sick tick Rick o ox fox box ot pot hot op hop top ob Bob job rob od nod pod rod og hog jog log om Tom mom ock rock sock lock u ug bug mug un run sun ut hut nut ub cub rub tub um gum hum mum uck duck luck tunk ump bump hump jump unch lunch munch punch ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:1","tags":["english"],"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["语言与平台"],"content":"辅音 辅音 bl black blink block blush cl clock clap click club class fl flag flex flip flop flush gl glass glad glob pl plan plane plant plot plum br Brad brick bring brush cr crab crack crash crop dr dress drip drop drum fr frog frank fresh Fred gr grass grab grand grid tr track trap trick truck sk skip skin skill sl sled slam slip slot sp spot spell spin spill st stand step stop stick sw swim swing swell ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:2","tags":["english"],"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["语言与平台"],"content":"元音组合 元音组合 ead read bead lead ean jean dean lean clean eat heat meat neat treat eal meal seal deal real oa goat toad oat coat goat boat moat oad road toad load oap soap oak soak oast toast roast coast boast oal goal oaf loaf ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:3","tags":["english"],"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["概要"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容。 此文章用于测试。 以下内容仅用于测试主题功能 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:0:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"LoveIt 的文章列表参考如下 hugoloveit https://hugoloveit.com/zh-cn/posts/ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:0:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"1 内容组织 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:1:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"2 前置参数 ---title:\"我的第一篇文章\"subtitle:\"\"# 文章副标题date:2020-03-04T15:58:26+08:00# 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置.lastmod:2020-03-04T15:58:26+08:00# 上次修改内容的日期时间.draft:true# 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染.author:\"\"# 文章作者.authorLink:\"\"# 文章作者的链接.description:\"\"# 文章内容的描述.license:\"\"# 这篇文章特殊的许可.images:[]# 页面图片, 用于 Open Graph 和 Twitter Cards.tags:[]# 文章的标签.categories:[]# 文章所属的类别.featuredImage:\"\"# 文章的特色图片.featuredImagePreview:\"\"# 用在主页预览的文章特色图片.hiddenFromHomePage:false# 如果设为 true, 这篇文章将不会显示在主页上.hiddenFromSearch:false# 如果设为 true, 这篇文章将不会显示在搜索结果中.twemoji:false# 如果设为 true, 这篇文章会使用 twemoji.lightgallery:true# 如果设为 true, 文章中的图片将可以按照画廊形式呈现.ruby:true# 如果设为 true, 这篇文章会使用 上标注释扩展语法.fraction:true# 如果设为 true, 这篇文章会使用 分数扩展语法.fontawesome:true# 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法.linkToMarkdown:true# 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接.rssFullText:false# 如果设为 true, 在 RSS 中将会显示全文内容.toc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位于 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位于 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...## featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法.resources:- name:featured-imagesrc:featured-image.jpg- name:featured-image-previewsrc:featured-image-preview.jpg--- ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:2:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3 内容摘要 文章摘要预览文章摘要预览 \" 文章摘要预览 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.1 自动摘要拆分 网站设置 summaryLength ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.2 手动摘要拆分 添加 \u003c!--more--\u003e ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.3 前置参数摘要 前置参数 summary ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.4 使用文章描述作为摘要 前置参数 description ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"4 Markdown 基本语法 ignore ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:4:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5 Markdown 扩展语法 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.1 Emoji 支持 https://hugoloveit.com/zh-cn/emoji-support/ 😀,😄,😆,🤣,😅,😂 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.2 数学公式 $$ c = \\pm\\sqrt{a^2 + b^2} $$ $$ c = \\pm\\sqrt{a^2 + b^2} $$ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.3 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\) $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.4 mhchem $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.5 字符注音或者注释 [Hugo]^(一个开源的静态网站生成工具) Hugo一个开源的静态网站生成工具 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:5","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.6 分数 [99]/[100] 99/100 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:6","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.7 Font Awesome 真开心! :(far fa-grin-tears): 真开心! ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:7","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.8 转义字符 {?:}joy: :joy: ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:8","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6 内置 Shortcodes https://hugoloveit.com/zh-cn/theme-documentation-built-in-shortcodes/ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.1 figure {{\u003c figure src=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.2 gist {{\u003c gist spf13 7896402 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.3 highlight {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.4 instagram instagram 的文档 {{\u003c instagram BWNjjyYFxVx hidecaption \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.5 param param 的文档 {{\u003c param description \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:5","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.6 ref 和 relref ref 和 relref 的文档 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:6","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.7 tweet tweet 的文档 {{\u003c tweet 877500564405444608 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:7","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.8 vimeo vimeo 的文档 {{\u003c vimeo 146022717 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:8","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.9 youtube youtube 的文档 {{\u003c youtube w7Ft2ymGmfc \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:9","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7 扩展shortcodes ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.1 style {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} This is a right-aligned paragraph. ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.2 link href [必需] content [可选] title [可选] rel [可选] class [可选] {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} Upstage ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.3 image src [必需] 图片的 URL. alt [可选] 图片无法显示时的替代文本, 默认值是 src 参数的值. caption [可选] 图片标题. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} lighthouse (image)\" lighthouse (image) ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.4 admonition 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] admonition 横幅的类型, 默认值是 note. title [可选] admonition 横幅的标题, 默认值是 type 参数的值. open [可选] 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.5 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 7.5.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:5","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.5.8 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:6","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.6 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:7","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.7 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. 7.7.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"music/wind.mp3\" name=起风了 artist=买辣椒也用券 cover=\"images/wind.png\" \u003e}} 呈现的输出效果如下: 7.7.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: 7.7.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] [netease, tencent, kugou, xiami, baidu]音乐平台. type [必需] [song, playlist, album, search, artist]音乐类型. id [必需] 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: 7.7.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme *[可选]*音乐播放器的主题色, 默认值是 #448aff. fixed *[可选]*是否开启固定模式, 默认值是 false. mini *[可选]*是否开启迷你模式, 默认值是 false. autoplay *[可选]*是否自动播放音乐, 默认值是 false. volume *[可选]*第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex *[可选]*是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选][all, one, none]音乐列表的循环模式, 默认值是 none. order [可选][list, random]音乐列表的播放顺序, 默认值是 list. list-folded *[可选]*初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height *[可选]*音乐列表的最大高度, 默认值是 340px. ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:8","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.8 bilibili {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:9","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.9 typeit typeit shortcode 基于 TypeIt 提供了打字动画. {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:10","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.10 script {{\u003c script \u003e}} console.log('Hello LoveIt!'); {{\u003c /script \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:11","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["语言与平台"],"content":" 声明：本文仅用做复习整理知识，在下列文章中进行二次加工，大部分内容整理自： https://www.cnblogs.com/edisonchou/p/4787775.html https://zhuanlan.zhihu.com/p/38799766 .NET 本质论 .NET中所有类型的基类是什么 值类型和引用类型的区别 装箱和拆箱的原理 struct和class的区别，struct适用于哪些场合 C#中方法的参数传递有哪几种方式 浅复制和深复制的区别 .NET中栈和堆的差异 执行string abc=\"aaa\"+\"bbb\"+\"ccc\"共分配了多少内存 托管堆内存分配 简要说说.NET中GC的运行机制 GC机制中如何判断一个对象仍然在被使用（如何标记） GC中代（Generation）是什么，分为几代（如何移动） GC有什么问题 托管与非托管资源是什么 托管资源 非托管资源 Dispose和Finalize方法在何时被调用（非托管资源回收方法） .NET中的托管堆中是否可能出现内存泄露的现象 大对象的分配 不恰当地保存根引用 不正确的Finalize方法 .NET 本质论 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:0:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":".NET中所有类型的基类是什么 System.Object ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:1:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"值类型和引用类型的区别 所有继承自System.ValueType的类型是值类型，而其他类型都是引用类型。 常用的值类型包括：结构、枚举、整数型、浮点型、布尔型等等。 赋值时的区别 值类型的变量直接将获得一个真实的数据副本，而对引用类型的赋值仅仅是把对象的引用赋给变量，这样就可能导致多个变量引用到一个对象实例上。 内存分配的区别 引用类型的对象将会在堆上分配内存，而值类型的对象则会在堆栈上分配内存 继承结构的区别 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:2:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"装箱和拆箱的原理 装箱：CLR需要做额外的工作把堆栈上的值类型移动到堆上，这个操作就被称为装箱。 拆箱：装箱操作的反操作，把堆中的对象复制到堆栈中，并且返回其值。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:3:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"struct和class的区别，struct适用于哪些场合 struct（结构）是值类型，而class（类）是引用类型。 struct与class相比，不具备继承的特性 struct不能有无参数的构造方法（class默认就有），也不能为成员变量定义初始值。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:4:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"C#中方法的参数传递有哪几种方式 ref关键字：引用传递参数，需要在传递前初始化；（ref 要求参数在传入前被初始化） out关键字：引用传递参数，需要在返回前初始化；（out 要求参数在方法返回前被初始化） params关键字：允许方法在定义时不确定参数的数量。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:5:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"浅复制和深复制的区别 浅复制：复制一个对象的时候，仅仅复制原始对象中所有的非静态类型成员和所有的引用类型成员的引用。（新对象和原对象将共享所有引用类型成员的实际对象） 深复制：复制一个对象的时候，不仅复制所有非静态类型成员，还要复制所有引用类型成员的实际对象。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:6:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":".NET中栈和堆的差异 .NET 中的栈 堆栈用来存储值类型的对象和引用类型对象的引用（地址），其分配的是一块连续的地址，堆栈上的地址从高位向低位分配内存。 .NET 中的堆 托管堆的分配也是连续的（从低位到高位），但是堆中却存在着暂时不能被分配却已经无用的对象内存块。 当一个引用类型对象被初始时，会通过指向堆上可用空间的指针分配一块连续的内存，然后使堆栈上的引用指向堆上刚刚分配的这块内存块。 .NET中的非托管堆 非托管的堆需要程序员用指针手动地分配和释放内存，.NET中的GC和内存管理不适用于非托管堆。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:7:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"执行string abc=\"aaa\"+\"bbb\"+\"ccc\"共分配了多少内存 string是引用类型，其内存分配会遵照引用类型的规范。字符串具有不可变性。 string first = \"aaa\" + \"bbb\" + \"ccc\"; string second = \"aaabbbccc\"; int num = 1; string str = \"aaa\" + num.ToString(); Console.WriteLine(str); string str = \"aaa\"; str += \"bbb\"; str += \"ccc\"; Console.WriteLine(str) ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:8:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"托管堆内存分配 CLR在进程中分配一块保留地址控件-即托管堆 托管堆有分为多个区域-垃圾回收堆（GC Heap）和加载堆（Loader Heap）[High-Frequency Heap、Low-Frequency Heap和Stub Heap] Loader Heap最重要的信息就是元数据相关的信息 每个Type在Loader Heap上体现一个Method Table，而Method Table中则记录了存储的元数据信息 Loader Heap不受GC控制。 TypeHandle：类型句柄，指向对应实例的方法表，每个对象创建时都包含该附加成员，并占用4个字节的内存空间。 SyncBlockIndex：用于线程同步，每个对象创建时也包含该附加成员la。它指向一块呗称为Synchronization Block的内存块，用于管理对象同步，同样占用4个字节的内存空间。 NextObjPtr:由托管堆维护的一个指针，用于标识下一个新建对象分配时在托管堆中所处的位置。CLR初始化时，NextObjPtr位于托管堆的及地址。 首先，将声明一个引用类型变量aUser：（堆栈4字节） VIPUser aUser;; 它仅是一个引用（指针），保存在线程的堆栈上，占用4Byte的内存空间，将用于保存VIPUser对象的有效地址，其执行过程正是上文描述的在线程栈上的分配过程。此时aUser未指向任何有效的实例，因此被自行初始化为null，试图对aUser的任何操作将抛出NullReferenceException异常。 然后，通过new操作执行对象创建：（GC托管堆20字节） aUser = new VIPUser(); 如上文所言，该操作对应于执行newobj指令，其执行过程又可细分为以下几步： 1、CLR按照其继承层次进行搜索，计算类型及其所有父类的字段，该搜索将一直递归到System.Object类型，并返回字节总数，以本例而言类型VIPUser需要的字节总数为 15 Bytes，具体计算为：VIPUser类型本身字段isVip（bool型）为 1 Bytes；父类User类型的字段id（Int32型）为 4 Bytes，字段user保存了指向UserInfo型的引用，因此占 4 Bytes，而同时还要为UserInfo分配 6 Bytes字节的内存。 2、实例对象所占的字节总数还要加上对象附加成员所需的字节总数，其中附加成员包括TypeHandle和SyncBlockIndex，共计 8 Bytes（在32位CPU平台下）。因此，需要在托管堆上分配的字节总数为 23 Bytes，而堆上的内存块总是按照 4 Bytes的倍数进行分配，因此本例中将分配 24 Bytes的地址空间。 3、CLR在当前AppDomain对应的托管堆上搜索，找到一个未使用的 20 Bytes 的连续空间，并为其分配该内存地址。事实上，GC使用了非常高效的算法来满足该请求，NextObjPtr指针只需要向前推进 20 Bytes，并清零原NextObjPtr指针和当前NextObjPtr指针之间的字节，然后返回原NextObjPtr指针地址即可，该地址正是新创建对象的托管堆地址，也就是aUser引用指向的实例地址。而此时的NextObjPtr仍指向下一个新建对象的位置。注意，栈的分配是向低地址扩展，而堆的分配是向高地址扩展。 最后，调用对象构造器，进行对象初始化操作，完成创建过程。该构造过程，又可细分为以下几个环节： （a）构造VIPUser类型的Type对象，主要包括静态字段、方法表、实现的接口等，并将其分配在上文提到托管堆的Loader Heap上。 （b）初始化aUser的两个附加成员：TypeHandle 和 SyncBlockIndex。 （解析类型）将TypeHandle指针指向Loader Heap上的MethodTable，CLR将根据TypeHandle来定位具体的Type； （实现对象实例同步）将SyncBlockIndex指针指向Synchronization Block的内存块，用于在多线程环境下对实例对象的同步操作。 （c）调用VIPUser的构造器，进行实例字段的初始化。 实例初始化时，会首先向上递归执行父类初始化，直到完成System.Object类型的初始化，然后再返回执行子类的初始化，直到执行VIPUser类为止。 以本例而言，初始化过程为首先执行System.Object类，再执行User类，最后才是VIPUser类。最终，newobj分配的托管堆的内存地址，被传递给VIPUser的this参数，并将其引用传给栈上声明的aUser。(System.Object-\u003eUser-\u003eVIPUser-\u003e封装成aUser-\u003e地址丢给线程堆栈) ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:9:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"简要说说.NET中GC的运行机制 GC是垃圾回收（Garbage Collect）的缩写,.NET中的垃圾回收是指清理托管堆上不会再被使用的对象内存，并且移动仍在被使用的对象使它们紧靠托管堆的一边。 标记：找到所有不再被使用的对象：对象A和对象C，并标记为垃圾； 移动：移动仍在被使用的对象：对象B和对象D; 通常情况下，我们不需要手动干预垃圾回收的执行，不过CLR仍然提供了一个手动执行垃圾回收的方法：GC.Collect()。当我们需要在某一批对象不再使用并且及时释放内存的时候可以调用该方法来实现。But，垃圾回收的运行成本较高（涉及到了对象块的移动、遍历找到不再被使用的对象、很多状态变量的设置以及Finalize方法的调用等等），对性能影响也较大，因此我们在编写程序时，应该避免不必要的内存分配，也尽量减少或避免使用GC.Collect()来执行垃圾回收。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:10:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"GC机制中如何判断一个对象仍然在被使用（如何标记） Mark-Compact 标记压缩算法 在.NET中引用类型对象实例通常通过引用来访问，而GC判断堆中的对象是否仍然在被使用的依据也是引用。简单地说：当没有任何引用指向堆中的某个对象实例时，这个对象就被视为不再使用。 在GC执行垃圾回收时，会把引用分为以下两类： （1）根引用：往往指那些静态字段的引用，或者存活的局部变量的引用； （2）非根引用：指那些不属于根引用的引用，往往是对象实例中的字段。 垃圾回收时，GC从所有仍在被使用的根引用出发遍历所有的对象实例，那些不能被遍历到的对象将被视为不再被使用而进行回收。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:11:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"GC中代（Generation）是什么，分为几代（如何移动） GC会把所有托管堆内的对象按照其已经不再被使用的可能性分为三类，并且从最有可能不被使用的类别开始扫描，.NET对这样的分类类别有一个称呼：代（Generation）。 第0代，新近分配在堆上的对象，从来没有被垃圾收集过。任何一个新对象，当它第一次被分配在托管堆上时，就是第0代。 第1代，经历过一次垃圾回收后，依然保留在堆上的对象。 第2代，经历过两次或以上垃圾回收后，依然保留在堆上的对象。如果第2代对象在进行完垃圾回收后空间仍然不够用，则会抛出OutOfMemoryException异常。 并不是每次垃圾回收都会同时回收3个代的所有对象，越小的代拥有着越多被释放的机会。 CLR对于代的基本算法是：每执行N次0代的回收，才会执行一次1代的回收，而每执行N次1代的回收，才会执行一次2代的回收。 根据.NET的垃圾回收机制，0代、1代和2代的初始分配空间分别为256KB、2M和10M。 一个对象实例存活的时间越长，那么它就具有更大的机率去存活更长的时间。 因为一次GC回收之后仍然被使用的对象会被移动到更高的代上，因此我们需要避免保留已经不再被使用的对象引用，将对象的引用置为null是告诉.NET该对象不需要再使用的最直接的方法。 在前面我们提到Finalize方法会大幅影响性能，通过结合对代的理解，我们可以知道：在带有Finalize方法的对象被回收时，该对象会被视为正在被使用从而被留在托管堆中，且至少要等一个GC循环才能被释放（为什么是至少一个？因为这取决于执行Finalize方法的线程的执行速度）。很明显，需要执行Finalize方法的那些对象实例，被真正释放时最乐观的情况下也已经位于1代的位置上了，而如果它们是在1代上才开始释放或者执行Finalize方法的线程运行得慢了一点，那该对象就在第2代上才被释放，相对于0代，这样的对象实例在堆中存留的时间将长很多。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:12:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"GC有什么问题 首先，GC并不是能释放所有的资源。它不能自动释放非托管资源。 第二，GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。 GC并不是实时性的，这会造成系统性能上的瓶颈和不确定性。所以有了IDisposable接口，IDisposable接口定义了Dispose方法，这个方法用来供程序员显式调用以释放非托管资源。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:13:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"托管与非托管资源是什么 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:14:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"托管资源 .NET中的所有类型都是（直接或间接）从System.Object类型派生的。.NET中超过80%的资源都是托管资源。 CTS中的类型被分成两大类——引用类型（reference type，又叫托管类型[managed type]），分配在内存堆上；值类型（value type），分配在堆栈上。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:14:1","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"非托管资源 ApplicationContext, Brush, Component, ComponentDesigner, Container, Context, Cursor, FileStream, Font, Icon, Image, Matrix, Object, OdbcDataReader, OleDBDataReader, Pen, Regex, Socket, StreamWriter, Timer, Tooltip, 文件句柄, GDI资源, 数据库连接等等资源。可能在使用的时候很多都没有注意到！ ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:14:2","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"Dispose和Finalize方法在何时被调用（非托管资源回收方法） Dispose方法 我们会在Dispose方法中实现一些托管对象和非托管对象的释放以及业绩业务逻辑的结束工作等等。 But，即使我们实现了Dispose方法，也不能得到任何有关释放的保证，Dispose方法的调用依赖于类型的使用者，当类型被不恰当地使用，Dispose方法将不会被调用,我们一般会借助using等语法来帮助Dispose方法被正确调用。 Finalize方法 Finalize在GC执行垃圾回收时被调用 ①当每个包含Finalize方法的类型的实例对象被分配时，.NET会在一张特定的表结构中添加一个引用并且指向这个实例对象，暂且称该表为“带析构方法的对象表”； ②当GC执行并且检测到一个不被使用的对象时，需要进一步检查“带析构方法的对象表”来查询该对象类型是否含有Finalize方法，如果没有则将该对象视为垃圾，如果存在则将该对象的引用移动到另外一张表，暂且称其为“待析构的对象表”，并且该对象实例仍然被视为在被使用。 ③CLR将有一个单独的线程负责处理“待析构的对象表”，其执行方法内部就是依次通过调用其中每个对象的Finalize方法，然后删除引用，这时托管堆中的对象实例就被视为不再被使用。 ④下一个GC执行时，将释放已经被调用Finalize方法的那些对象实例。 结合使用Dispose和Finalize方法：标准Dispose模式 Finalize方法由于有CLR保证调用，因此比Dispose方法更加安全（这里的安全是相对的，Dispose需要类型使用者的及时调用），但在性能方面Finalize方法却要差很多。因此，我们在类型设计时一般都会使用标准Dispose模式：Finalize方法作为Dispose方法的后备，只有在使用者没有调用Dispose方法的情况下，Finalize方法才被视为需要执行。这一模式保证了对象能够被高效和安全地释放，已经被广泛使用。 标准dispose模式模板 public class BaseTemplate : IDisposable { // 标记对象是否已经被释放 private bool isDisposed = false; // Finalize方法 ~BaseTemplate() { Dispose(false); } // 实现IDisposable接口的Dispose方法 public void Dispose() { Dispose(true); // 告诉GC此对象的Finalize方法不再需要被调用 GC.SuppressFinalize(this); } // 虚方法的Dispose方法做实际的析构工作 protected virtual void Dispose(bool isDisposing) { // 当对象已经被析构，则不必再继续执行 if(isDisposed) { return; } if(isDisposing) { // Step1:在这里释放托管资源 } // Step2:在这里释放非托管资源 // Step3:最后标记对象已被释放 isDisposed = true; } public void MethodA() { if(isDisposed) { throw new ObjectDisposedException(\"对象已经释放\"); } // Put the logic code of MethodA } public void MethodB() { if (isDisposed) { throw new ObjectDisposedException(\"对象已经释放\"); } // Put the logic code of MethodB } } public sealed class SubTemplate : BaseTemplate { // 标记子类对象是否已经被释放 private bool disposed = false; protected override void Dispose(bool isDisposing) { // 验证是否已被释放，确保只被释放一次 if(disposed) { return; } if(isDisposing) { // Step1:在这里释放托管的并且在这个子类型中申明的资源 } // Step2:在这里释放非托管的并且这个子类型中申明的资源 // Step3:调用父类的Dispose方法来释放父类中的资源 base.Dispose(isDisposing); // Step4:设置子类的释放标识 disposed = true; } } 真正做释放工作的只是受保护的虚方法Dispose，它接收一个bool参数，主要用于区分调用者是类型的使用者还是.NET的GC机制。两者的区别在于通过Finalize方法释放资源时不能再释放或使用对象中的托管资源，这是因为这时的对象已经处于不被使用的状态，很有可能其中的托管资源已经被释放掉了。在Dispose方法中GC.SuppressFinalize(this)告诉GC此对象在被回收时不需要调用Finalize方法，这一句是改善性能的关键，记住实现Dispose方法的本质目的就在于避免所有释放工作在Finalize方法中进行。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:15:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":".NET中的托管堆中是否可能出现内存泄露的现象 首先，必须明确一点：即使在拥有垃圾回收机制的.NET托管堆上，仍然是有可能发生内存泄露现象的。 其次，什么是内存泄露？内存泄露是指内存空间上产生了不再被实际使用却又不能被分配的内存空间，其意义很广泛，像内存碎片、不彻底的对象释放等都属于内存泄露现象。内存泄露将导致主机的内存随着程序的运行而逐渐减少，无论其表现形式怎样，它的危害是很大的，因此我们需要努力地避免。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"大对象的分配 NET中所有的大对象（这里主要是指对象的大小超过指定数值[85000字节]）将分配在托管堆内一个特殊的区域内，暂且将其称为“大对象堆”（这也算是CLR对于GC的一个优化策略）。大对象堆中最重要的一个特点就是：没有代级的概念，所有对象都被视为第2代。在回收大对象堆内的对象时，其他的大对象不会被移动，这是考虑到大规模地移动对象需要耗费过多的资源。这样，在程序过多地分配和释放大对象之后，就会产生很多内存碎片。 随着对象的分配和释放不断进行，在不进行对象移动的大对象堆内，将不可避免地产生小的内存碎片。我们所需要做的就是尽量减少大对象的分配次数，尤其是那些作为局部变量的，将被大规模分配和释放的大对象，典型的例子就是String类型。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:1","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"不恰当地保存根引用 最简单的一个错误例子就是不恰当地把一个对象申明为公共静态变量，一个公共的静态变量将一直被GC视为一个在使用的根引用。更糟糕的是：当这个对象内部还包含更多的对象引用时，这些对象同样不会被释放。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:2","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"不正确的Finalize方法 不正确的Finalize方法将导致Finalize方法不能被正确执行。如果系统中所有的Finalize方法不能被正确执行，包含它们的对象也只能驻留在托管堆内不能被释放，这样的情况将会导致严重的后果。 Finalize方法应该只致力于快速而简单地释放非托管资源，并且尽可能快地返回。相反，不正确的Finalize方法则可能包含： 1. 没有保护地写文件日志； 2. 访问数据库； 3. 访问网络； 4. 把当前对象赋给某个存活的引用； 例如，当Finalize方法试图访问文件系统、数据库或者网络时，将会有资源争用和等待的潜在危险。试想一个不断尝试访问离线数据库的Finalize方法，将会在长时间内不会返回，这不仅影响了对象的释放，也使得排在Finalize方法队列中的所有后续对象得不到释放，这个连锁反应将会导致很快地造成内存耗尽。此外，如果在Finalize方法中把对象自身又赋给了另外一个存活的引用，这时对象内的一部分资源已经被释放掉了，而另外一部分还没有，当这样一个对象被激活后，将导致不可预知的后果。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:3","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["概要"],"content":" 个人技术蓝图 计算机基础 [the-basics-of-computer-science] 计算机的组成原理 [principles-of-computer-composition] 操作系统原理 [principle-operating-system] 编译原理 [principle-of-compiling] 数据库系统 [database-system] 计算机网络 [network-of-computer] TCP HTTP 语言与平台 [language-and-platform] C# \u0026 .NET 5 [chsarp-and-dotnet5] .NET 本质论 [dotnet-essentialism] C# 基础语法 [csharp-basic-syntax] C# 高级用法 [professional-csharp] 新一代的 .NET [new-generation-dotnet] Swift \u0026 IOS [swift-ios] Python [python] Python 基础语法 [python-basic-syntax] Python 高级语法 [professional-python] Python 的应用 [python-application] JS,ES,TS \u0026 Vue,React (Gatsby) [js-es-ts-vue-react] 前端框架 [front-end] 网页基础 [website-basic] 数据与算法[data-and-algorithmic] 数据结构 [data-structure] 常用算法 [algorithm] 重构 [refactoring] 软件工程 [software-engineering] 开发方法 [software-development-methodologies] 系统分析与设计 [system-analysis-and-design] 软件开发的生命周期 [software-development-lifecycle] 架构艺术 [architecture-art] 架构模式 [architecture-pattern] 设计模式 [design-pattern] 常用组件 [common-components] Redis [redis] RabbitMQ [rabbitmq] Elastic Search [elastic-search] 云上漫谈 [cloud-native] 基础架构篇 [cloud-infrastructure] 软件架构篇 [cloud-software-architecture] DEVOPS [devops] 个人技术蓝图 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:0:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"计算机基础 [the-basics-of-computer-science] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"计算机的组成原理 [principles-of-computer-composition] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"操作系统原理 [principle-operating-system] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"编译原理 [principle-of-compiling] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"数据库系统 [database-system] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:4","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"计算机网络 [network-of-computer] TCP HTTP ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:5","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"语言与平台 [language-and-platform] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"C# \u0026 .NET 5 [chsarp-and-dotnet5] .NET 本质论 [dotnet-essentialism] dotnet-essentialism C# 基础语法 [csharp-basic-syntax] C# 高级用法 [professional-csharp] 新一代的 .NET [new-generation-dotnet] dotnet-core ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"Swift \u0026 IOS [swift-ios] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"Python [python] Python 基础语法 [python-basic-syntax] python-learning-notes python-learning-intermediate-notes Python 高级语法 [professional-python] python-quick-grammar Python 的应用 [python-application] jupyter-notebook-shortcuts ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"JS,ES,TS \u0026 Vue,React (Gatsby) [js-es-ts-vue-react] 前端框架 [front-end] Gatsby 网页基础 [website-basic] HTML CSS ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:4","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"数据与算法[data-and-algorithmic] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"数据结构 [data-structure] 算法-数据结构 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"常用算法 [algorithm] 算法-思想 [转载]五大算法设计思想 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"重构 [refactoring] [转载]C#重构经典全面汇总 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"软件工程 [software-engineering] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"开发方法 [software-development-methodologies] 软件开发方法笔记 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"系统分析与设计 [system-analysis-and-design] 系统分析与设计 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"软件开发的生命周期 [software-development-lifecycle] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"架构艺术 [architecture-art] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"架构模式 [architecture-pattern] 软件架构设计 软件架构模式 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"设计模式 [design-pattern] UML设计 设计模式 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"常用组件 [common-components] Redis [redis] [转载]Redis面试题 RabbitMQ [rabbitmq] [转载]消息中间件MQ与RabbitMQ面试题 Elastic Search [elastic-search] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"云上漫谈 [cloud-native] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"基础架构篇 [cloud-infrastructure] introduce-microservice-infrastructure-on-cloud how-to-setup-kubernetes-on-azure ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"软件架构篇 [cloud-software-architecture] [转载]微服务架构的设计模式 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"DEVOPS [devops] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["软件工程"],"content":" Software Development Methodologies ","date":"2021-02-08","objectID":"https://blog.gethin.online/development-methodologies/:0:0","tags":["软件工程","系统架构师"],"title":"开发方法","uri":"https://blog.gethin.online/development-methodologies/"},{"categories":["软件工程"],"content":"开发方法 ","date":"2021-02-08","objectID":"https://blog.gethin.online/development-methodologies/:1:0","tags":["软件工程","系统架构师"],"title":"开发方法","uri":"https://blog.gethin.online/development-methodologies/"},{"categories":["软件工程"],"content":"软件的生命周期 可行性研究与计划-\u003e需求分析-\u003e概要设计-\u003e详细设计-\u003e实现-\u003e集成测试-\u003e确认测试-\u003e使用与维护 ","date":"2021-02-08","objectID":"https://blog.gethin.online/development-methodologies/:1:1","tags":["软件工程","系统架构师"],"title":"开发方法","uri":"https://blog.gethin.online/development-methodologies/"},{"categories":["软件工程"],"content":"软件开发模型 瀑布模型 演化模型 螺旋模型 增量模型 构建组装模型 ","date":"2021-02-08","objectID":"https://blog.gethin.online/development-methodologies/:1:2","tags":["软件工程","系统架构师"],"title":"开发方法","uri":"https://blog.gethin.online/development-methodologies/"},{"categories":["软件工程"],"content":"统一过程 UP的9个核心工作流 业务建模，需求，分析设计，实施，测试，部署，配置与变更管理，项目管理，环境 UP的生命周期 目标里程碑，架构里程碑，能力里程碑，发布里程碑 UP的特点 UP不但给出类迭代的生命周期，还给出了生命周期每一阶段的迭代指南 采用不同迭代方式的UP可以演变为演化模型或增量模型 迭代特点使得更容易控制软件开发的风险 UP本身并不属于敏捷 实际应用中可以根据具体问题对UP进行剪裁 架构师在UP中的活动 同需求人员和项目管理人员密切协作 细化软件架构 保持整个架构的概念完整性 ","date":"2021-02-08","objectID":"https://blog.gethin.online/development-methodologies/:1:3","tags":["软件工程","系统架构师"],"title":"开发方法","uri":"https://blog.gethin.online/development-methodologies/"},{"categories":["软件工程"],"content":"敏捷方法 极限编程 XP是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方式。 在更短的周期内，更早的提供具体、持续的反馈信息 迭代的进行计划编制 依赖自动测试程序来监控开发进度，并及早捕获缺陷 依赖口头交流、测试和源程序进行沟通 倡导持续的、演化式的设计 依赖与开发团队内部的紧密协作 尽可能达到程序员短期利益和项目长期利益的平衡 四大价值观 沟通，简单，反馈，勇气，（尊重） 十二个最佳实践 计划游戏，小型发布，隐喻，简单设计，测试先行，重构，结对编程，集体代码所有制，持续集成，每周工作40小时，现场客户，编码标准 特性驱动开发 FDD也是一个迭代开发模型，FDD每一步都强调质量，不断的交付可运行的软件，并以很小的开发提供精准的项目进度报告和状态信息。 FDD角色定义 项目经理，首席架构设计师，开发经理，主程序员，程序员，领域专家 核心过程 开发整体对象模型、构造特征列表、计划特征开发、特征设计、特征构建 最佳实践 领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管 Scrum Scrum是一个用于开发和维护复杂产品的框架，是一个增量的、迭代的开发过程。 Scrum 的五个活动 产品待办事项列表梳理、Sprint计划会议、每日Scrum会议、Sprint评审会议、Sprint回顾会议 Scrum的5大价值观 承诺、专注、开放、尊重、勇气 水晶方法 Crystal 是发展一种提倡“机动性“的方法，包括共有的核心元素，每个都含有独特的角色，过程模式，工作产品和实践。 7大体系特征：经常交付，反思改进，渗透式交流，个人安全，焦点，与专家用户建立方便的联系，配有自动测试、配置管理和经常集成功能的技术环境 ","date":"2021-02-08","objectID":"https://blog.gethin.online/development-methodologies/:1:4","tags":["软件工程","系统架构师"],"title":"开发方法","uri":"https://blog.gethin.online/development-methodologies/"},{"categories":["软件工程"],"content":"软件重用 软件重用 源代码重用，架构重用，应用框架重用，业务建模重用，文档及过程的重用，软构件重用，软件服务重用 ","date":"2021-02-08","objectID":"https://blog.gethin.online/development-methodologies/:1:5","tags":["软件工程","系统架构师"],"title":"开发方法","uri":"https://blog.gethin.online/development-methodologies/"},{"categories":["软件工程"],"content":"基于架构的软件设计 ABSD方法于生命周期 ABSD：分解功能，通过选择架构风格来事先质量和业务需求，软件模版的使用 抽象功能需求，包括变化的需求和通用的需求 用例（实际功能需求） 抽象的质量和业务需求 架构选项 质量场景 约束 基于架构的软件开发模型(ABSDM) 架构需求 需求获取，标识构件（生成类图，对类分组，打包构件），需求评审 架构设计 提出软件架构模型，把已标识的构件映射到软件架构中，分析构件的互相作用，产生软件架构，设计评审 架构文档化 输出：架构需求规格说明，测试架构需求的质量设计说明 架构复审 架构实现 架构演化 需求变动归类，制定架构演化计划，修改、增加或删除构件，更新构件的互相作用，构件组装与测试，技术评审 ","date":"2021-02-08","objectID":"https://blog.gethin.online/development-methodologies/:1:6","tags":["软件工程","系统架构师"],"title":"开发方法","uri":"https://blog.gethin.online/development-methodologies/"},{"categories":["语言与平台"],"content":"Python Quick Grammar ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:0","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"1. 变量互换 a=1 b=2 a,b=b,a a,b (2, 1) ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:1","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"2. 连续赋值 a=b=c=50 a,b,c (50, 50, 50) ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:2","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"3. 自动解包 a,b,c=[1,2,3] a,b,c (1, 2, 3) a,*others=[1,2,3,4] print(a) print(*others) 1 2 3 4 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:3","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"4. 链式比较 a=10 if(5\u003ca\u003c15): print(a) 10 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:4","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"5. 重复列表 [5,2]*4 [5, 2, 5, 2, 5, 2, 5, 2] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:5","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"6. 重复字符串 \"hello\"*3 'hellohellohello' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:6","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"7. 三目运算 age = 30 slogon = \"牛逼\" if age == 30 else \"niubility\" print(slogon) 牛逼 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:7","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"8. 字典合并 a={\"a\":1} b={\"b\":2} {**a,**b} {'a': 1, 'b': 2} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:8","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"9. 字符串反转 s = \"i love python\" s[::-1] 'nohtyp evol i' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:9","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"10. 列表转字符串 s = [\"i\", \"love\", \"python\"] \" \". join(s) 'i love python' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:10","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"11. for else 语句 foo=[2,3,4,5] for i in foo: if i == 0: break else: print(\"未发现\") 未发现 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:11","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"12. 字典推导式 m = {x: x**2 for x in range(5)} m {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:12","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"13. 用Counter查找列表中出现最多的元素 content = [\"a\", \"b\", \"c\", \"a\", \"d\", \"c\", \"a\"] from collections import Counter c = Counter(content) c. most_common(1) [('a', 3)] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:13","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"14. 默认值字典 from collections import defaultdict d = defaultdict(list) d['a']. append(1) d['a'] [1] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:14","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"15. 赋值表达式 import re data = \"hello123world\" if match:=re. search(\"(\\d+)\", data): num = match. group(1) else: num=None num '123' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:15","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"16. isinstance x=1 b=isinstance(x, (int, float)) b True ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:16","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"17. 用 http.server 共享文件 #python3 -m http. server ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:17","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"18. zip 函数实现字典键值对互换 lang = {\"python\":\". py\", \"java\":\". java\"} dict(zip(lang. values(), lang. keys())) {'. py': 'python', '. java': 'java'} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:18","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"19. 查找列表中出现次数最多的数字 test = [1, 2, 3, 4, 2, 2, 3, 1, 4, 4, 4, 5] max(set(test), key=test. count) 4 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:19","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"20. 使用 slots 节省内存 class MyClass(object): def __init__(self, name, identifier): self. name = name self. identifier = identifier self. set_up() print(sys. getsizeof(MyClass)) class MyClass(object): __slots__ = ['name', 'identifier'] def __init__(self, name, identifier): self. name = name self. identifier = identifier self. set_up() print(sys. getsizeof(MyClass)) 1064 896 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:20","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"21. 扩展列表 i = ['a','b','c'] i. extend(['e','f','g']) i ['a', 'b', 'c', 'e', 'f', 'g'] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:21","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"22. 列表负数索引 a = [ 1, 2, 3] a[-1] 3 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:22","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"23. 列表切片 a = [0,1,2,3,4,5,6,7,8,9] a[3:6] # 第3个到第6个之间的元素 a[:5] # 前5个元素 a[5:] # 后5个元素 a[::] # 所有元素（拷贝列表） a[::2] # 偶数项 a[1::2] # 奇数项 a[::-1] # 反转列表 [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:23","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"24. 二维数组变一维数组 import itertools a = [[1, 2], [3, 4], [5, 6]] i = itertools. chain(*a) list(i) [1, 2, 3, 4, 5, 6] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:24","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"25. 有索引的迭代 a = ['Merry', 'Christmas ', 'Day'] for i, x in enumerate(a): print ('{}: {}'. format(i, x)) 0: Merry 1: Christmas 2: Day ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:25","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"26. 列表推导式 le = [x*2 for x in range(10)] le # 每个数取平方 le = [x for x in range(10) if x%2 == 0] le # 获取偶数项 [0, 2, 4, 6, 8] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:26","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"27. 生成器表达式 ge = (x*2 for x in range(10)) print(ge) print(next(ge)) print(next(ge)) print(next(ge)) \u003cgenerator object \u003cgenexpr\u003e at 0x000001D693764190\u003e 0 2 4 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:27","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"28. 集合推导式 nums = {n**2 for n in range(10)} nums {0, 1, 4, 9, 16, 25, 36, 49, 64, 81} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:28","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"29. 判断key是否存在字典中 d = {\"1\":\"a\"} print('1' in d) print(d['1']) print(d. get(\"1\")) print(d. get(\"2\")) True a a None ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:29","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"30. 装饰器 from functools import wraps def tags(tag_name): def tags_decorator(func): @wraps(func) def func_wrapper(name): return \"\u003c{0}\u003e{1}\u003c/{0}\u003e\". format(tag_name, func(name)) return func_wrapper return tags_decorator @tags(\"p\") def get_text(name): \"\"\"returns some text\"\"\" return \"Hello \" + name print(get_text(\"Python\")) \u003cp\u003eHello Python\u003c/p\u003e ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:30","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"31. 字典子集 def sub_dicts(d, keys): return {k:v for k, v in d. items() if k in keys} sub_dicts({1:\"a\", 2:\"b\", 3:\"c\"}, [1,2]) {1: 'a', 2: 'b'} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:31","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"32. 反转字典 d = {'a': 1, 'b': 2, 'c': 3, 'd': 4} zip(d. values(), d. keys()) z = zip(d. values(), d. keys()) dict(z) {1: 'a', 2: 'b', 3: 'c', 4: 'd'} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:32","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"33. 具名元组 from collections import namedtuple Point = namedtuple(\"Point\", \"x,y\") p = Point(x=1, y=2) print(p. x) print(p[0]) print(p. y) print(p[1]) 1 1 2 2 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:33","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"34. 设置字典默认值 d = dict() if 'a' not in d: d['a'] = [] d['a']. append(1) d d. setdefault('b',[]). append(2) d {'a': [1], 'b': [2]} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:34","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"35. 有序字典 from collections import OrderedDict m = OrderedDict((str(x), x) for x in range(10)) m. keys() # key 按照插入的顺序排列 odict_keys(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']) ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:35","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"36. 列表中最大最小的前n个数 import heapq a = [51, 95, 14, 65, 86, 35, 85, 32, 8, 98] heapq. nlargest(5,a) heapq. nsmallest(5,a) [8, 14, 32, 35, 51] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:36","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"37. 打开文件 import os with open('foo. txt', 'w') as f: f. write(\"hello\") os. remove(\"foo. txt\") ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:37","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"38. 两个列表组合成字典 list_1 = [\"One\",\"Two\",\"Three\"] list_2 = [1,2,3] dictionary = dict(zip(list_1, list_2)) print(dictionary) {'One': 1, 'Two': 2, 'Three': 3} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:38","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"39. 去除列表中重复元素 my_list = [1,4,1,8,2,8,4,5] my_list = list(set(my_list)) print(my_list) [1, 2, 4, 5, 8] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:39","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"40. 打印日历 import calendar print(calendar. month(2021, 1)) January 2021 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:40","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"41. 匿名函数 add = lambda a,b:a+b add(1,2) 3 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:41","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":" Python Learning Notes - Intermediate ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:0:0","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4. 序列 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:0","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.1 序列 1 索引 abc=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] print(abc[1]) 2 切片（slicing） sname[start🔚step] print(abc[1:5]) print(abc[0:5:2]) 3 序列相加 bcd=[\"b\",\"c\",\"d\"] print(abc+bcd) 4 乘法 print(bcd*5) 5 检查元素 print(\"b\" in bcd) 6 计算序列长度、最大值和最小值 print(len(abc)) print(max(abc)) print(min(abc)) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:1","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.2 列表(list) 1 创建和删除 lisa=[1,2,3,4,5,6] lisb=['a',\"b\",[\"a\",'''bcd''']] lise=[] lisr=list(range(1,10,2)) print(lisa,lisb,lise,lisr) del lisr print(lisr) 2 遍历 for i in lisa: print(i) for i,item in enumerate(lisb): print(i,item) 3 添加、修改和删除列表元素 lisa.append(7) print(lisa) lisa[5] = 7 print(lisa) del lisa[5] print(lisa) 4 统计 c=lisa.count(1) print(c) i=lisa.index(1) print(i) s=sum(lisa) print(s) lisa.sort(reverse=True) print(lisa) sort=sorted(lisa) print(sort) k=[x for x in lisa if x\u003e3] print(k) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:2","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.3 元组（tuple） 1 元组的基本操作 t=('a',12,(\"abc\",\"b\"),[\"ggg\",99]) print(t) t=tuple(range(10,20,2)) print(t) t=('人生苦短',28,'我用PYTHON',[123,456,789]) print(t[0]) print(t[:3]) 2 元组推导式 import random randomnumber=(random.randint(10,100) for i in range(10)) print(randomnumber) randomnumber=tuple(randomnumber) print(randomnumber) a=(1,2,3) print(a) a=(2,3,4) print(a) a=a+(5,6) print(a) 遍历后原生成器对象已经不存在了，如下： number=(i for i in range(3)) print(number.__next__()) print(number.__next__()) number=tuple(number) print(number) 元组和列表区别 列表属于可变序列，它的元素可以随时修改或者删除，而元组属于不可变序列，其中元素不可修改，除非整体替换 列表可以使用append(),extend(),insert(),remove()和pop()等方法实现添加和修改列表元素，而元组则没有这几个方法，因为不能向原则添加和修改元素，同样也不能删除元素 列表可以使用切片访问和修改列表中元素，元素也支持切片，但是它只支持通过切片访问元素中的元素，不支持修改 元组比列表的访问和处理速度快，所以如果只需要对其中元素进行访问，而不进行任何修改，建议使用元组而不使用列表 列表不能座位字典的键，而元组则可以 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:3","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.4 字典(dictionary) 字典的特性： 通过键而不是通过索引来读取 字典式任意对象的无序集合 字典是可变的，并且可以任意嵌套 字典中的键必须是唯一 字典中的键必须不可变 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:4","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5. 字符串和正则表达式 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:0","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5.1 字串常用操作 # 拼接 a='abc'+'bc'+'CD'+str(123)+'@' print(a) # 计算长度 print(len(a)) # 截取字符串【string[start🔚step]】 sub=a[2:7:2] print(sub) # 分割字符串【str.splite(sep,maxsplit)】 li=a.split('b') print(li) li=a.split('b',1) print(li) # 检索字符串count find index startswith endswith print(a.count('b')) print(a.find('b')) print(a.index('b')) print(a.startswith('abc')) print(a.endswith('123')) # 字母大小写 print(a.upper()) print(a.lower()) # 去特殊字符 print(a.strip('@')) 格式化字符串 常用格式化字符 s 字符串（采用str() 显示） r 字符串（采用repr() 显示） c 单个字符串 o 八进制整数 d 十进制整数 e 指数 x 十六进制整数 f 浮点数 % 字符串% template= '{:0\u003e9s}\\tname:{:s}\\ttitle:sr.{:s}' print(template.format('1','hello','wang')) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:1","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5.2 正则表达式基础 行定位符 ^tm$ 元字符 \\w\\s\\d\\b 限定符 ? + * {n} {n,} {n,m} 字符类 abc 排除字符 ^abc 选择字符 | 转义字符 \\ 分组 () ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:2","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5.3 使用re模块实现正则表达式 # re.match(pattern.string,[flags]) # re.search(pattern,string,[flags]) # re.findall(pattern,string,[flags]) # re.sub(pattern,repl.string,count,flags) # re.split(pattern,string,[maxsplite],[flags]) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:3","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["软件工程"],"content":" Scrum Learning Notes Scrum 学习笔记 理论与价值观 敏捷宣言 5 个价值观 8 大价值观 12 个原则 3 个角色 3 个工件 5 个活动 估算与计划 计划失败的原因 估算大小的策略 为价值制定计划 确定优先级因素 确定渴望度优先级 分解用户故事 用户故事的六个特性 - INVEST 确定经济优先级 会议与实战 Product Bocklog Refinement 框架 Skeleton 备忘录 Cheat Sheet Sprint Planning PART I PART II Spint Review 框架 Sprint Retrospective 发布计划策略 迭代计划策略 估算速度策略 有效原因与指导原则 敏捷计划有效原因 敏捷估算和计划的 12 条指导原则 Scrum 学习笔记 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:0:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"理论与价值观 在有限的时间（TimeBox）里 团队一起合作（Work Together），我们彼此信任（Trust）并发挥自我最大的能力和优势（Do The Best），持续不断的交付（CI，CD）可用、有价值（Usable，Valuable）的软件，赢得客户的满意。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"敏捷宣言 个体和互动 高于 流程和工具 （合作，信赖） 工作的软件 高于 详尽的文档 （产品增量） 客户合作 高于 合同谈判（同一组织） 响应变化 高于 遵循计划（公开，透明） ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"5 个价值观 专注 - 由于我们在一段时间内只能专注于少数几件事情，所以我们可以很好的合作并获得优质的产出，我们能够更快的交付有价值的事项。 公开 - 在团队合作中大家都会表达我们做的如何，以及遇到的障碍。我们发现将担忧说出来是一件好事，因为只有这样才能让这些担忧及时得到解决。 尊重 - 因为我们在一起工作，分享和成功失败，这有助培养并加深互相之间的尊重，并帮助彼此成为值得尊重的人。 承诺 - 由于对自己的命运有更大的掌控，我们会有更坚定的信念去获得成功。 勇气 - 因为我们不是单打独斗，我们能够感受到支持，而且掌握更多资源。这一切赋予我们勇气去迎接更大的挑战。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"8 大价值观 诚实，开放，勇气，尊重，专注，信任，授权，合作 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:3","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"12 个原则 我们最重要的目标，是通过及早和持续不断地交付有价值的软件使客户满意。 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。 业务人员和开发人员必须相互合作，项目中的每一天都不例外。 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。 可工作的软件是进度的首要度量标准。 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。(稳定的速度) 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。 以简洁为本，它是极力减少不必要工作量的艺术。 最好的架构、需求和设计出自自组织团队。 团队定期地反思如何能提高成效，并依此调整自身的行为表现。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:4","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"3 个角色 PO Scurm Master Team ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:5","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"3 个工件 Product Backlog Sprint Backlog Burndown chart ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:6","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"5 个活动 产品待办事项列表梳理 Sprint 计划 每⽇ Scrum 站会 Sprint 评审 Sprint 回顾 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:7","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"估算与计划 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"计划失败的原因 基于活动而不是基于特性 活动不会提前完成 延误沿着计划表向下传递 活动不是互相独立的 基于活动的计划分散了我们对特性的专注，而特性才是衡量客户价值的单元。解决策略：使用 FDD 策略。 多任务处理导致更多的延迟 - 每个人都达到 100%负荷，这和让高速公路保持 100%负荷结果相同，谁都无法取得任何进展。解决策略：专注 feature，合理估算 不按优先级开发特性 - 传统计划假设所有任务都会完成，但这样会造成如果无法完成会舍弃一些特性，而这些特性可能会比交付的更有价值。解决策略：明确优先级。 忽视不确定性 - 最明显的效果就是造成 delay。 解决策略：迭代。 把估算当作承诺 - 估算只是一个可能性，而对一个可能性做出承诺是不可能的。解决策略：对特性承诺而非时间。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"估算大小的策略 故事点的优势 故事点有助于驱动跨功能行为 故事点估算不会过期 故事点是纯粹对大小进行度量 故事点估算通常更快 我的理想人天不等于你的理想人天 理想人天 理想人天在团队以外更容易解释 理想人天估算更容易开始 理想人天便于预测速度 使用模糊的故事点产生的不舒服感觉是非常短暂的。 公司让实际人天接近于理想人天的压力会带来负面影响。 使用故事点估算更有说服力。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"为价值制定计划 确定优先级因素 价值 估算经济回报是一件很困难的工作，常常需要一种替代方案对价值估算 ** 确定渴望度的优先级 成本 确定经济优先级 新知识 关于产品的知识 关于技术的知识 风险 进度风险 成本风险 功能风险 确定渴望度优先级 客户满意度的 Kano 模型 作为阈值的特性 线性特性 兴奋点和惊喜点 Kano 模型 5 个度量点: 我希望这样; 我预期就是这样; 我没有意见; 我可以忍受这样; 我不希望这样; ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:3","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"分解用户故事 用户故事的六个特性 - INVEST 独立性 Independent、可协商性 Negotiable、有价值 Valuable、可以估算 Estimable、短小 Small、可测试性 Testable 何时分解用户故事 用户故事太大，不能放进单次迭代的时候 大型故事分解有助于作出更准确的估算 按照数据边界分解 按照用户故事所支持数据的边界来分解大型用户故事 按照操作边界分解 CURD 去除横切考虑 例如：日志 忽略满足性能限制 考虑把功能性和非功能性需求隔离到不同的用户故事，从而分解大型用户故事 分解具有混合优先级的用户故事 如果大型用户故事中的小故事具有不同的优先级，则可以对它们进行分解 不要把故事分解成任务 不要把大型用户分解成任务，而是寻找一种方法来让一颗曳光弹穿过整个故事 避免相关变化的诱惑 避免在具有适当大小的特性中增加相关变化而把事情弄糟，除非这些变化具有相同的优先级 组合用户故事 对于2周一次的迭代周期工作的团队来说，合适的做法是把特性分解成 2-5 天的用户故事 组合小故事 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:4","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"确定经济优先级 收入来源 新收入 增量收入 促进现有客户购买更多许可 包含了可以独立出售的可选，附加模块 包含允许提高收费的功能 促进对咨询服务的使用 留存收入 如果不开发项目或主题，公司会损失的收入 操作效率 需要或者在公司成长后需要很长时间的事 部门之间更好的集成和交流 减少人员更替 对新人缩短培训时间 任何对时间敏感的过程 综合多个过程 任何可以提高准确性和减少返工的工作 经济指标 1 金钱的时间价值 2 净现值 NPV 3 内部收益率 4 投资回收期 5 折现回收期 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:5","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"会议与实战 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Product Bocklog Refinement 框架 Skeleton 展示现阶段以及中期目标 展示并澄清 Product Backlog 团队估算 PBI PO 按照期望团队交付的顺序为 PBI 排序 分成小组协作对需求建模，切分以及确定验收条件 备忘录 Cheat Sheet 梳理之前是否与利益相关者一起评估确认远景、目标和 backlog 条目 团队和主要的利益相关者在场 会议由 ScurmMaster 或者 PO 引导 预留 sprint 总时间的 5%-10%梳理 backlog PO 把远景、目标和整个 backlog 分享给大家 技术风险是否被确认并创建响应的 spike Product Backlog 是一个有序列表 把所有的反馈、变更、缺陷记录到 Product Backlog 产品 Backlog 包括现景、近景和远景 团队一起对所有的条目估算 排列靠前的条目都有验收条件而且有具体实例 所有不确定的问题被记录下来等待会后继续调研 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Sprint Planning PART I 展示重要的 PBI 澄清 PBI 相关的问题 团队协作梳理新的 PBI 团队按照顺序尝试选择 PBI PART II 重新调整“完成的定义” 计算团队下个 Sprint 可用时间 团队一起讨论可能的实现方案 团队协作创建任务并估算 根据时间或速率向 PO 做出最终承诺 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Spint Review 框架 评估已经完成的 PBI 与承诺的 PBI 和 Sprint 目标 用讲故事的方式演示完成的功能 收集反馈 展示接下来要做的重要 PBI ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:3","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Sprint Retrospective 安全感 How much will each person participate 发现 Big Picture 分析 Continue; Fix; Stop; 计划 Where dowe want to be? How do we get there from here? 收尾 How to ducument; How to execute; ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:4","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"发布计划策略 确定满意条件，（日期驱动，特性驱动） 估算用户故事， 选择迭代周期长度，（官方建议：2 周迭代，压力分摊，6x2+1） 估算速度，（速度策略） 确定用户故事的优先级， 选择用户故事和发布时间 确定最初 1-3 个迭代的具体工作 卡片记录 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:5","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"迭代计划策略 速度驱动的迭代计划（客观） 调整优先级 确定目标速度 确定迭代目标 选择用户故事 把用户故事分解成任务 只包含此项目增加价值的工作 - 如“回复邮件 1 小时”。 尽量明确，直到养成习惯 - 如自动化测试培养。 会议会占据（很多）时间（整体时间：如开会）。 缺陷- 发现 bug 的迭代中就修复它们。 处理依赖性 - 如 mock 数据 难以分解的工作 - 探针策略 对任务进行估算 一部分设计就够了 任务的适合大小 承诺驱动的迭代计划（主观） 要求团队做出承诺(团队主导，承诺特性非任务)“你们可以承诺交付我们已经讨论过的特性么？” 对估算值求和 -实际上大多数团队在计划每天 4-6 个小时的工作量时候能够取得成功 维护与承诺 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:6","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"估算速度策略 如果你在给出对速度的估算前可以进行一次或多测迭代， ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:7","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"有效原因与指导原则 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:4:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"敏捷计划有效原因 经常重新计划 承认不可能建立完美的计划，可以大量减少焦虑，而且可以逐步的消除这种不精确性。 对大小和持续时间的估算时独立的 大小和时间时有关系统的，但很多因素也会影响持续时间。 故事点来估算大小，接下来估算速度，然后规模和速度估算结合起来就可以得到持续时间 在不同层次制定计划 发布计划，迭代计划，每日计划。1.不同的计划是用于不同的目的事实。2.帮助开发团队从不同的角度来看待项目。 基于特性而不是基于任务制定计划 团队可以少做一些关于特定任务的预先考量。让团队思考正在开发的特性。 小故事保持工作流畅 每个迭代都要消除未完成的工作 在团队层次跟踪 不要准备个人燃尽图**而只绘制团队层次的燃尽图 承认不确定性并为之计划 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:4:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"敏捷估算和计划的 12 条指导原则 让整个团队参与 在不同层次上进行计划 使用不同度量单位，让对大小和持续时间的估算保持独立 用功能或者日期来体现不确定性 经常重新计划 跟踪进度并沟通 承认学习的重要性 计划具有适当大小的特性 确定特性优先级 最好的估算和计划来源于事实 保留一些松弛度 通过前瞻性计划协调多个团队 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:4:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["语言与平台"],"content":" Jupyter Notebook Shortcuts ","date":"2020-06-04","objectID":"https://blog.gethin.online/jupyter-notebook-shortcuts/:0:0","tags":["python"],"title":"JUPYTER NOTEBOOK SHORTCUTS","uri":"https://blog.gethin.online/jupyter-notebook-shortcuts/"},{"categories":["语言与平台"],"content":"Command model Key Function 作用 Enter take you into edit mode 转入编辑模式 Shift-Enter run the current cell, select below 运行本单元，选中下个单元 Ctrl-Enter run selected cells 运行本单元 Alt-Enter run the current cell, insert below 运行本单元，在其下插入新单元 Y change the cell type to Code 单元转入代码状态 M change the cell type to Markdown 单元转入 markdown 状态 R change the cell type to Raw 单元转入 raw 状态 1 set level 1 title 设定 1 级标题-仅在 markdown 状态下 2 set level 2 title 设定 2 级标题 3 set level 3 title 设定 3 级标题 4 set level 4 title 设定 4 级标题 5 set level 5 title 设定 5 级标题 6 set level 6 title 设定 6 级标题 Up select cell above 选中上方单元 K select cell above 选中上方单元 Down select cell below 选中下方单元 J select cell above 选中下方单元 Shift-K Move selected cells up 连续选择上方单元 Shift-J Move selected cells down 连续选择下方单元 A insert cell above 在上方插入新单元 B insert cell below 在下方插入新单元 X cut selected cells 剪切选中的单元 C copy selected cells 复制选中的单元 Shift-V paste cells above 粘贴到上方单元 V paste cells below 粘贴到下方单元 Z undo cell deletion 恢复删除的最后一个单元 D,D delete selected cells 删除选中的单元 Shift-M merge cell below 合并选中的单元 Ctrl-S save and checkpoint 保存当前 NoteBook S Save and Checkpoint 保存当前 NoteBook L toggle line numbers 开关行号 O toggle output 转换输出 Shift-O toggle output scrolling 转换输出滚动 Esc close pager 关闭页面 Q close pager 关闭页面 H show all shortcuts 显示快捷键帮助 Shift-Space scroll notebook up 向上滚动 Space scroll notebook down 向下滚动 ","date":"2020-06-04","objectID":"https://blog.gethin.online/jupyter-notebook-shortcuts/:1:0","tags":["python"],"title":"JUPYTER NOTEBOOK SHORTCUTS","uri":"https://blog.gethin.online/jupyter-notebook-shortcuts/"},{"categories":["语言与平台"],"content":"Edit Mode Key Function 作用 Tab code completion or indent 代码补全或缩进 Shift-Tab tooltip 提示 Ctrl-] indent 缩进 Ctrl-[ dedent 解除缩进 Ctrl-A select all 全选 Ctrl-Z undo 撤销 Ctrl-Shift-Z redo 重做 Ctrl-Y redo 重做 Ctrl-Home go to cell start 跳到单元开头 Ctrl-Up go to cell start 跳到单元开头 Ctrl-End go to cell end 跳到单元末尾 Ctrl-Down go to cell end 跳到单元末尾 Ctrl-Left go one word left 跳到左边一个字首 Ctrl-Right go one word right 跳到右边一个字首 Ctrl-Backspace delete word before 删除前面一个字 Ctrl-Delete delete word after 删除后面一个字 Esc command mode 切换到命令模式 Ctrl-M command mode 切换到命令模式 Shift-Enter run cell, select below 运行本单元，选中下一单元 Ctrl-Enter run cell 运行本单元 Alt-Enter run cell, insert below 运行本单元，在下面插入一单元 Ctrl-Shift- - split cell 分割单元 Ctrl-Shift-Subtract split cell 分割单元 Ctrl-S Save and Checkpoint 保存当前 NoteBook Up move cursor up or previous cell 光标上移或转入上一单元 Down move cursor down or next cell 光标下移或转入下一单元 Ctrl-/ toggle comment on current or selected lines 注释整行/撤销注释 Written with StackEdit. ","date":"2020-06-04","objectID":"https://blog.gethin.online/jupyter-notebook-shortcuts/:2:0","tags":["python"],"title":"JUPYTER NOTEBOOK SHORTCUTS","uri":"https://blog.gethin.online/jupyter-notebook-shortcuts/"},{"categories":["语言与平台"],"content":" Python Learning Notes - Junior ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:0:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1. python 入门 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.1. 注释 单行注释 # 注释内容 多行注释 \"\"\"注释内容\"\"\" 中文编码声明注释 # coding=utf-8 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:1","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.2. 代码缩进 采用代码缩进和冒号“：”区分代码之间的层次，python 对代码缩进非常严格，如果不合理缩进会抛出 SyntaxError 异常。 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:2","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.3. 代码规范 1.3.1. 编写规范 每个 import 只导入一个模块 不要再行尾添加分号“；” 仅以每行不超过 80 个字符；如果超过，仅以使用小括号“（）” 使用必要的空行可以提高代码可读性 通常情况下，运算符两侧、函数参数之间、逗号“，”两侧建议使用空格进行分隔 应该避免在循环中使用+和+=运算符累加字符串，推荐做法是将每个字符串加入列表，然后再循环结束后使用 join 方法连接列表。 适当的使用一场处理提高程序容错性 1.3.2. 命名规范 模块名尽量短小，并且全部使用小写字母，可以使用下划线分割多个字母 如：game_main 包名尽量短小，并且全部使用小写字母，不推荐使用下划线，如：com.cr 类名采用单词首字母大写形式，即 Pascal 风格 如：TakeSomething 模块内部的类采用下划线+Pascal 风格的类名组成 如：_TakeSomething 函数、类的属性和方法的命名规则同模块类似，也是全部采用小写字母，多个字母间用下划线_进行分割 常量明明时全部采用大写字母，可以使用下划线 使用单下划线_开头的模块变量或者函数是受保护的，在使用 import * from 语句从模块中导入时这些变量或者函数不能导入 使用双下划线__开头的实例变量或者方法时类私有的 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:3","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.4. 基本输出 使用 print() 函数输出 使用 input() 函数输入 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:4","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2. 变量和数据类型 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.1. 保留字 Python 保留字: and, as, assert, break, class, continue, def, del, elif, else, except, finally, for, form, False, global, if, import, in, is, lambda, nonlocal, not, None, or, pass, raise, return, try, True, while, with, yield ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:1","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.2. 标识符 标识符命名规则：数字，字母，下划线，不能使用保留字 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:2","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.3. 变量 在 python 中，不需要先声明变量名及其类型，直接赋值即可创建各种类型变量。 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:3","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.4. 基本数据类型 2.4.1.数字类型 整数 十进制 八进制 - 必须以 0o/0O 开头 十六进制 - 必须以 0X/0x 开头 二进制 浮点数 复数 2.4.2. 字符串类型 通常使用‘’，“”，‘“’”。单引号双引号必须再一行，三引号可以分布在多行。 转义符：\\（续行符）,\\n（换行符）,\\0（空）,\\t（水平制表符）,\"（双引号）,'（单引号）,\\（一个反斜杠）,\\f（换页）,\\0dd（八进制数，dd 表示字符）,\\xhh（十六进制数，hh 表示字符） 布尔类型 类型转换 int(x) | float(x) | complex(real [,imag]) | str(x) | repr(x) | eval(str) | chr(x) | ord(x) | hex(x) | oct(x) ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:4","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.5. 运算符 2.5.1 数字运算符 +,-,*,/,%(余),//(取整除),**(幂) 2.5.2 赋值运算符 =,+=,-=,*=,/=,%=,//=,**= 2.5.3 比较运算符 \u003e,\u003c,==,!=,\u003e=,\u003c= 2.5.4 逻辑运算符 and,or,not 2.5.5 位运算符 \u0026,|,^,~,\u003c\u003c,\u003e\u003e ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:5","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3. 流程控制 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.1 选择语句 if 表达式: 语句块 if 表达式: 语句块 else: 语句块 if 表达式: 语句块 elif 表达式: 语句块 else: 语句块 if 表达式: if 表达式: 语句块 else: 语句块 else: 语句块 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:1","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.2 条件表达式 a=1 b=a if a\u003e0 else -a ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:2","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.3 循环语句 while 表达式: 循环体 for 迭代变量 in 对象: 循环体 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:3","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.4 跳转语句 break,continue ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:4","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.5 pass 空语句 pass 不做任何事 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:5","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["数据与算法"],"content":"海量数据优化 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:0","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"1. 合理使用索引 索引是数据库中重要的数据结构，它的根本目的就是为了提高查询效率。现在大多数的数据库产品都采用 IBM 最先提出的 ISAM 索引结构。索引的使用要恰到好处，其使用原则如下： 在经常进行连接，但是没有指定为外键的列上建立索引，而不经常连接的字段则由优化器自动生成索引。 在频繁进行排序或分组（即进行 group by 或 order by 操作）的列上建立索引。 在条件表达式中经常用到的不同值较多的列上建立检索，在不同值少的列上不要建立索引。比如在雇员表的“性别”列上只有“男”与“女”两个不同值，因此就无必要建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。 如果待排序的列有多个，可以在这些列上建立复合索引（compound index）。 使用系统工具。如 Informix 数据库有一个 tbcheck 工具，可以在可疑的索引上进行检查。在一些数据库服务器上，索引可能失效或者因为频繁操作而使得读取效率降低，如果一个使用索引的查询不明不白地慢下来，可以试着用 tbcheck 工具检查索引的完整性，必要时进行修复。另外，当数据库表更新大量数据后，删除并重建索引可以提高查询速度。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:1","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"2. 避免或简化排序 应当简化或避免对大型表进行重复的排序。当能够利用索引自动以适当的次序产生输出时，优化器就避免了排序的步骤。以下是一些影响因素： 索引中不包括一个或几个待排序的列； group by 或 order by 子句中列的次序与索引的次序不一样； 排序的列来自不同的表。 为了避免不必要的排序，就要正确地增建索引，合理地合并数据库表（尽管有时可能影响表的规范化，但相对于效率的提高是值得的）。如果排序不可避免，那么应当试图简化它，如缩小排序的列的范围等。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:2","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"3. 消除对大型表行数据的顺序存取 在嵌套查询中，对表的顺序存取对查询效率可能产生致命的影响。比如采用顺序存取策略，一个嵌套 3 层的查询，如果每层都查询 1000 行，那么这个查询就要查询 10 亿行数据。避免这种情况的主要方法就是对连接的列进行索引。 例如，两个表：学生表（学号、姓名、年龄……）和选课表（学号、课程号、成绩）。如果两个表要做连接，就要在“学号”这个连接字段上建立索引。 还可以使用并集来避免顺序存取。尽管在所有的检查列上都有索引，但某些形式的 where 子句强迫优化器使用顺序存取。下面的查询将强迫对 orders 表执行顺序操作： SELECT * FROM orders WHERE (customer_num=104 AND order_num\u003e1001) OR order_num=1008 虽然在 customer_num 和 order_num 上建有索引，但是在上面的语句中优化器还是使用顺序存取路径扫描整个表。因为这个语句要检索的是分离的行的集合，所以应该改为如下语句： SELECT * FROM orders WHERE customer_num=104 AND order_num\u003e1001 UNION SELECT * FROM orders WHERE order_num=1008 这样就能利用索引路径处理查询。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:3","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"4. 避免相关子查询 一个列的标签同时在主查询和 where 子句中的查询中出现，那么很可能当主查询中的列值改变之后，子查询必须重新查询一次。查询嵌套层次越多，效率越低，因此应当尽量避免子查询。如果子查询不可避免，那么要在子查询中过滤掉尽可能多的行。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:4","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"5. 避免困难的正规表达式 MATCHES 和 LIKE 关键字支持通配符匹配，技术上叫正规表达式。但这种匹配特别耗费时间。例如： SELECT * FROM customer WHERE zipcode LIKE “98_ _ _” 即使在 zipcode 字段上建立了索引，在这种情况下也还是采用顺序扫描的方式。如果把语句改为SELECT * FROM customer WHERE zipcode \u003e“98000”，在执行查询时就会利用索引来查询，显然会大大提高速度。 另外，还要避免非开始的子串。例如语句：SELECT * FROM customer WHERE zipcode[2，3] \u003e“80”，在 where 子句中采用了非开始子串，因而这个语句也不会使用索引。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:5","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"6.使用临时表加速查询 把表的一个子集进行排序并创建临时表，有时能加速查询。有助于避免多重排序操作，而且在其他方面还能简化优化器的工作。例如： SELECT cust.name，rcvbles.balance，……other columns FROM cust，rcvbles WHERE cust.customer_id = rcvlbes.customer_id AND rcvblls.balance\u003e0 AND cust.postcode\u003e“98000” ORDER BY cust.name 如果这个查询要被执行多次而不止一次，可以把所有未付款的客户找出来放在一个临时文件中，并按客户的名字进行排序： SELECT cust.name，rcvbles.balance，……other columns FROM cust，rcvbles WHERE cust.customer_id = rcvlbes.customer_id AND rcvblls.balance\u003e0 ORDER BY cust.name INTO TEMP cust_with_balance 然后以下面的方式在临时表中查询： SELECT * FROM cust_with_balance WHERE postcode\u003e“98000” 临时表中的行要比主表中的行少，而且物理顺序就是所要求的顺序，减少了磁盘 I/O，所以查询工作量可以得到大幅减少。 注意：临时表创建后不会反映主表的修改。在主表中数据频繁修改的情况下，注意不要丢失数据。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:6","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"7. 用排序来取代非顺序存取 非顺序磁盘存取是最慢的操作，表现在磁盘存取臂的来回移动。SQL 语句隐藏了这一情况，使得在写应用程序时很容易写出要求存取大量非顺序页的查询。 有些时候，用数据库的排序能力来替代非顺序的存取能改进查询。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:7","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"百万数据查询优化技巧三十则 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询： select id from t where num=0 应尽量避免在 where 子句中使用!=或\u003c\u003e操作符，否则将引擎放弃使用索引而进行全表扫描。 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 下面的查询也将导致全表扫描： select id from t where name like '%abc% 若要提高效率，可以考虑全文检索。 如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)='abc'--name以abc开头的id` select id from t where datediff(day,createdate,'2005-11-30')=0--‘2005-11-30’生成的id 应改为 select id from t where name like 'abc%' select id from t where createdate\u003e='2005-11-30' and createdate\u003c'2005-12-1' 要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(...) 很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段 sex，male、female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 任何地方都不要使用 select * from t，用具体的字段列表代替“*”，不要返回用不到的任何字段。 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 避免频繁创建和删除临时表，以减少系统表资源的消耗。 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 尽量避免大事务操作，提高系统并发能力。 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:2:0","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"常用SQL ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:0","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的存储过程 --select string using in procedure select b.name, a.text from syscomments a left join sysobjects b on b.id=a.id where b.xtype='P' and a.text like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:1","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的列名 --select columns name select b.name as Table1, a.name as Columns1,a.type from syscolumns a left join sysobjects b on b.id=a.id where b.xtype='u' and a.name like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:2","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的表名 --select table name select name from sysobjects where xtype='u' and name like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:3","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的函数名 --select string using in function select b.name, a.text from syscomments a left join sysobjects b on b.id=a.id where b.xtype='fn' and a.text like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:4","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的视图 --select string using in view select b.name, a.text from syscomments a left join sysobjects b on b.id=a.id where b.xtype='V' and a.text like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:5","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询表结构 SELECT table_name=case when a.colorder=1 then d.name else '' end, table_remarks=case when a.colorder=1 then isnull(f.value,'') else '' end, field_no=a.colorder, field_name=a.name, identification=case when COLUMNPROPERTY( a.id,a.name,'IsIdentity')=1 then '√'else '' end, primary_key=case when exists(SELECT 1 FROM sysobjects where xtype='PK' and name in ( SELECT name FROM sysindexes WHERE indid in( SELECT indid FROM sysindexkeys WHERE id = a.id AND colid=a.colid ))) then '√' else '' end, field_type=b.name, bytes=a.length, field_length=COLUMNPROPERTY(a.id,a.name,'PRECISION'), decimal_places=isnull(COLUMNPROPERTY(a.id,a.name,'Scale'),0), is_allow_null=case when a.isnullable=1 then '√'else '' end, default_value=isnull(e.text,''), field_description=isnull(g.[value],'') FROM syscolumns a left join systypes b on a.xtype=b.xusertype inner join sysobjects d on a.id=d.id and d.xtype='U' and d.name\u003c\u003e'dtproperties' left join syscomments e on a.cdefault=e.id left join sys.extended_properties g on a.id=g.major_id and a.colid=g.minor_id left join sys.extended_properties f on d.id=f.major_id and f.minor_id =0 where d.name='table_name' order by a.id desc,a.colorder ; Written with StackEdit. ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:6","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["语言与平台"],"content":" 这篇文章主要是翻译和记录了一些 Gateby 的基础知识，有助于开发者通过这些基础知识进行快速的开发 Refer to the Article: https://mpolinowski.github.io/gatsby-js-knowledgebase ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:0:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"10 添加文件数据(Adding File Data) 使用 Gatsby，您可以使用 GraphQL 直接从文件中查询数据。 Transformer插件将文件节点转换为各种其他类型的数据，例如 gatsby-transformer-json 将 将JSON 文件转换为 JSON 数据节点，而 gatsby-transformer-remark 将 将markdown 文件转换为 MarkdownRemark 节点，您可以从中查询 Markdown 的 的HTML 表示形式。 在这里，我们将使用gatsby-source-filesystem从我们的文件系统创建文件节点。 npm install --save gatsby-source-filesystem 安装后，将插件添加到 gatsby-config.js。 您可以具有此插件的多个实例，以从文件系统上的不同位置读取源节点。 以下设置了 Jekyll 模式：具有 Markdown 文件的页面目录和.json，.yaml，.csv 的数据目录： { resolve: `gatsby-source-filesystem`, options: { name: `pages`, path: `${__dirname}/src/pages/`, }, }, { resolve: `gatsby-source-filesystem`, options: { name: `data`, path: `${__dirname}/src/data/`, }, } 现在，您可以打开 GraphiQL 调试器-在大括号中，当你开始键入 allFiles 时，它应提供自动补全功能。 只需按 Enter 接受，然后再次按 CTRL + ENTER 填写所有页面 ID 的查询： { allFile { edges { node { id } } } } 当你删除 ID 并按 CTRL + SPACE 时，将显示一个包含所有可查询选项的下拉菜单：你可以使用 parent，children 和 和relativePath 属性来创建， 例如 breadcrumb navigation：现在，我们可以在/src/pages/page-2.js 中添加 GraphQL 查询，以遍历我们的所有页面并显示一些数据： export const query = graphql` query MyFilesQuery { allFile { edges { node { relativePath prettySize extension birthTime(fromNow: true) } } } } ` 不要忘记将{data}注入页面组件： const SecondPage = ({data}) =\u003e 现在，我们可以添加一些 JSX 来遍历所有文件，并在\u003ctable\u003e中输出信息 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003erelativePath\u003c/th\u003e \u003cth\u003eprettySize\u003c/th\u003e \u003cth\u003eextension\u003c/th\u003e \u003cth\u003ebirthTime\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e {data.allFile.edges.map(({ node }, index) =\u003e ( \u003ctr key={index}\u003e \u003ctd\u003e {node.relativePath} \u003c/td\u003e \u003ctd\u003e {node.prettySize} \u003c/td\u003e \u003ctd\u003e {node.extension} \u003c/td\u003e \u003ctd\u003e {node.birthTime} \u003c/td\u003e \u003c/tr\u003e ))} \u003c/tbody\u003e \u003c/table\u003e ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:1:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11 使用 Markdown(Working with Markdown) ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.1 添加 Markdown 到 GraphQL 现在，我们可以访问有关我们所有页面的信息。 但是如上所述，在最后一段的开头，我们还可以使用 Gatsby Transformer Plugins 来查找文件并将其内容可以通过 GraphQL 查询。 这里，我们希望使用 Markdown 文件并对其进行转换，以便能够在我们的网站上显示其内容。 为此所需的 Transformer Plugin 是 gatsby-transformer-remark。 首先，我们需要安装插件： npm install --save gatsby-transformer-remark 在 gatsby-config.js 中添加： plugins: [ `gatsby-transformer-remark`, ] 然后在/src/pages/FirstMDpost/index.md 内创建一个 markdown 页面，其中包含一些 FrontMatter（文件开头的元数据，以后可以由 GraphQL 查询）和一些文本： --- path: '/md-posts' title: 'My first Post' date: '2017-10-05' author: 'Mike Polinowski' chapter: 'Index' --- # This is my first mardown Post! 现在我们为 GraphQL 提供了 Markdown -与以前一样，只需开始输入 allMardownRemark（ENTER 自动完成），然后按 CTRL + ENTER 完成查询： ![gatsby_10](https://raw.githubusercontent.com/mpolinowski/gatsby-wiki/master/gatsby_10.png =577x189) 现在，我们可以查询 FrontMatter 以及添加到页面文件夹中的每个 MD 文件的 MD 转换为 HTML 的内容： ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:1","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.2 发布我们的 Markdown 数据模板 这些 Markdown 表示将要被显示的模板，但是现在我们需要创建一个用于此数据的样式模板。让我们先在/src 内添加一个称为templates的文件夹。 现在，向其中添加一个名为post.js的文件，该文件将包含每个帖子条目的结构模板。 该文件包含我们帖子的 JSX markup： import React from 'react' export default function Template({data}) { const {markdownRemark: post} = data return ( \u003cdiv\u003e \u003ch1\u003e{post.frontmatter.title}\u003c/h1\u003e \u003cdiv dangerouslySetInnerHTML={{__html: post.html}} /\u003e \u003c/div\u003e ) } export const postQuery = graphql` query BlogPostByPath($path: String!) { markdownRemark(frontmatter: { path: { eq: $path} }) { html frontmatter { path title } } } ` \u003cTemplate /\u003e组件接收{data}属性，这些属性由 GraphQL 查询检索。 该查询会查找 markdown 中 中frontmatter 里面所有 URL 等于$Path 的帖子，所以如果你在浏览器中键入的这个 URL 是/md-posts，那么路径中带有/md-posts 的文件，就会被调用。 然后，查询使用 markdownRemark 插件将 post markdown 转换为 HTML，并在{data}中提供其前题的路径和标题，并将其传递到组件，然后渲染。 Gatsby 已经配置为将/src/pages 中的所有页面路由为我们网站的页面。 但是现在我们必须注册来自 markdown 文件和 post.js 模板的帖子。 为此，我们必须在应用程序的根目录内创建一个名为 gatsby-node.js 的文件。 我们将使用createPages Gatsby API从我们的帖子模板创建页面： const path = require('path'); exports.createPages = ({boundActionCreators, graphql}) =\u003e { const {createPage} = boundActionCreators; // const createPage = boundActionCreators.createPage; const postTemplate = path.resolve('src/templates/post.js'); return graphql(`{ allMarkdownRemark { edges { node { html id frontmatter { path title } } } } }`) .then(res =\u003e { if(res.errors) { return Promise.reject(res.errors); } res.data.allMarkdownRemark.edges.forEach(({node}) =\u003e { createPage({ path: node.frontmatter.path, component: postTemplate }) }) }) } 保存并重新启动您的应用程序，然后在浏览器中打开 http://localhost:8000/md-posts ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:2","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.3 带有 Markdown 的嵌套路由 要为./src/pages/FirstMDpost/index.md 文件创建子帖子，我们可以简单地向文件夹中添加更多文件，并在其前题中定义嵌套路由 - e.g. ./src/pages/FirstMDpost/myfirstpost.md: --- path: '/md-posts/first-post' title: 'First Blog Post' date: '2017-10-05' author: 'Mike Polinowski' chapter: 'Markdown Posts' --- # This is my first markdown Post! 和 ./src/pages/FirstMDpost/mysecondpost.md: --- path: '/md-posts/second-post' title: 'Second Blog Post' date: '2017-10-05' author: 'Mike Polinowski' chapter: 'Markdown Posts' --- # A dive into Markdown Syntax 它们可以分别通过http://localhost:8000/md-posts/first-post和http://localhost:8000/md-posts/second-post 来访问 ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:3","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.4 创建 Index 页面 现在，我们可以使用 GraphQL 检索所有 Markdown 页面并将过滤它们。 对于此测试，我们将一个表添加到起始页面，显示最后 10 个帖子（到目前为止，我只发表了 3 3个帖子…），我们希望按日期降序排列它们，并且仅显示 chapter: ‘Markdown Posts’的页面 ，并排除我们的 index.md： const IndexPage = ({data}) =\u003e ( \u003cdiv\u003e \u003ch2\u003eMarkdown Index\u003c/h2\u003e \u003cp\u003eThe table below sorts out all Markdown pages that are not inside the \"Markdown Posts\" chapter - as defined inside their frontmatter. It also applies a filter, to only display the latest 10 posts. Click on here to display \u0026nbsp; \u003cLink to=\"/md-posts/\"\u003e all Markdown pages \u003c/Link\u003e .\u003c/p\u003e \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eDate\u003c/th\u003e \u003cth\u003eLink\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e {data.allMarkdownRemark.edges.map(post =\u003e ( \u003ctr key={post.node.id}\u003e \u003ctd\u003e {post.node.frontmatter.date} \u003c/td\u003e \u003ctd\u003e \u003cLink to={post.node.frontmatter.path}\u003e {post.node.frontmatter.title} \u003c/Link\u003e \u003c/td\u003e \u003c/tr\u003e ))} \u003c/tbody\u003e \u003c/table\u003e \u003c/div\u003e ) export const pageQuery = graphql` query IndexQuery { allMarkdownRemark(limit: 10 sort: {fields: [frontmatter___date], order: DESC} filter: { frontmatter: { chapter: {eq: \"Markdown Posts\"} }} ) { edges { node { id frontmatter { path title date } } } } } ` ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:4","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.5 缓存 Markdown 中的链接 一旦开始在 Markdown 文件中添加链接，您会发现单击它们会重新加载您的应用程序-这不是很好 :( 但请放心，这里的gatsby-plugin-catch-links可以助您一臂之力！ 它-安装后，将其添加到./gatsby-config.js 中的 Gatsby 插件中，它就可以正常工作： npm install --save gatsby-plugin-catch-links // In your gatsby-config.js plugins: [ `gatsby-plugin-catch-links`, ] ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:5","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"12 添加 Material-UI 为了使我们的生活更轻松，我们希望包含来自@ Materials-UI 的即用型 material 设计组件。 我们将安装 v.1.0.0 的测试版-它也需要 Roboto Fontface 和 和Material-UI 图标： npm install material-ui@next --save npm install typeface-roboto --save npm install material-ui-icons --save 现在，我们可以轻松地将 Material-UI 组件导入我们的应用程序： import React from 'react' import { render } from 'react-dom' import Button from 'material-ui/Button' import 'typeface-roboto' function AppWithButton() { return ( \u003cButton\u003e Hello World \u003c/Button\u003e ); } render(\u003cAppWithButton /\u003e, document.querySelector('#app')); ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:3:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"13 添加 Elasticsearch 该项目的先决条件之一是，我们需要为我们的 ElasticSearch Index 创建一个闪电般的界面。 我们已经为其构建了ES6 Class component。并将其添加到 Gatsby/Material-UI 中非常简单。 首先，添加./src/pages/search/jsx 并修改 ElasticSearch 组件来配合我们的 UI. import React, { Component } from 'react' import Link from 'gatsby-link' import elasticsearch from 'elasticsearch' import { withStyles } from 'material-ui/styles' import Grid from 'material-ui/Grid' import Button from 'material-ui/Button' import ResultCards from '../components/ResultCards' const connectionString = 'localhost:9200' const _index = 'wiki2_de_2017_09_09' const _type = 'article' let client = new elasticsearch.Client({ host: connectionString, log: \"trace\" }) const rootStyle = { flexGrow: 1, marginTop: 30, } export class Search extends Component { constructor(props) { super(props) this.state = { results: [] }; this.handleChange = this.handleChange.bind(this) } handleChange(event) { const search_query = event.target.value; client.search({ index: _index, type: _type, body: { query: { multi_match: { query: search_query, fields: ['title^100', 'tags^100', 'abstract^20', 'description^10', 'chapter^5', 'title2^10', 'description2^10'], fuzziness: 1, }, }, }, }).then(function(body) { this.setState({ results: body.hits.hits }); }.bind(this), function(error) { console.trace(error.message); } ); } render() { return ( \u003cdiv className=\"container\"\u003e \u003cinput type=\"text\" onChange={this.handleChange} /\u003e \u003cSearchResults results={this.state.results} /\u003e \u003c/div\u003e ); } } const SearchResults = ({results}) =\u003e ( \u003cdiv className=\"search_results\"\u003e \u003cbr/\u003e\u003chr/\u003e \u003cdiv className={rootStyle}\u003e \u003cGrid container spacing={24}\u003e {results.map((result , i) =\u003e \u003cResultCards key={i} image={result._source.image} title={result._source.title2} link={result._source.link} abstract={result._source.abstract}/\u003e )} \u003c/Grid\u003e \u003c/div\u003e \u003cbr/\u003e\u003cbr/\u003e\u003cLink to=\"/\" style={{ textDecoration: 'none' }}\u003e\u003cButton raised color=\"primary\"\u003eGo back to the homepage\u003c/Button\u003e\u003c/Link\u003e \u003c/div\u003e ) export default Search \u003cSearchResults /\u003e组件将遍历\u003cResultCards /\u003e组件内的 Material UI Card： import React from 'react' import Link from 'gatsby-link' import Card, { CardActions, CardContent, CardMedia } from 'material-ui/Card' import Button from 'material-ui/Button' import Typography from 'material-ui/Typography' import Grid from 'material-ui/Grid' const ResultCards = ({image, title, abstract, link}) =\u003e ( \u003cGrid item xs={12} sm={6} lg={4}\u003e \u003cCard style={{ maxWidth: 345 }}\u003e \u003cCardMedia style={{ height: 200 }} image={image} title={abstract} /\u003e \u003cCardContent\u003e \u003cTypography type=\"headline\" component=\"h4\" style={{ minHeight: 60, marginBottom: \"10px\" }}\u003e {title} \u003c/Typography\u003e \u003cTypography component=\"p\" style={{ minHeight: 50, marginBottom: \"10px\" }}\u003e {abstract} \u003c/Typography\u003e \u003c/CardContent\u003e \u003cCardActions\u003e \u003cLink to={link} style={{ textDecoration: 'none' }}\u003e \u003cButton dense color=\"primary\"\u003e Read \u003c/Button\u003e \u003c/Link\u003e \u003cButton dense color=\"primary\"\u003e Learn More \u003c/Button\u003e \u003c/CardActions\u003e \u003c/Card\u003e \u003c/Grid\u003e ) export default ResultCards 组件将添加来自 ElasticSearch JSON Response 的结果，并给我们一个灵活的卡片网格。 ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:4:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":" 这篇文章主要是翻译和记录了一些 Gateby 的基础知识，有助于开发者通过这些基础知识进行快速的开发 Refer to the Article: https://mpolinowski.github.io/gatsby-js-knowledgebase ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:0:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"06 属性传递(Passing down Props) 现在，我们可以从父组件传递属性到Counter组件。例： 我们可以通过显示的页面来更改我们的Counter 标题。 ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"6.1 更改头部 \u003cCounter header=\"This is the Index Counter\" /\u003e 这个header的属性现在可以用在Counter组件中的render方法。现在我们可以通过调用他的父组件来为Counter组件获取不同的标头了。 render() { return \u003cdiv\u003e \u003ch3\u003e{this.props.header}\u003c/h3\u003e \u003cp\u003ecurrent count: {this.state.count}\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003eplus\u003c/button\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count - 1 })}\u003eminus\u003c/button\u003e \u003c/div\u003e } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:1","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"6.2 更改样式 样式也是如此-如果我们希望标题与父组件的配色方案匹配，我们只需要将颜色属性传递给 Counter 组件： \u003cCounter header=\"This is the Index Counter\" color=\"rebeccapurple\" /\u003e 并在组件本身中添加必要的内联样式： render() { return \u003cdiv\u003e \u003ch3 style={{color: this.props.color}}\u003e{this.props.header}\u003c/h3\u003e \u003cp\u003ecurrent count: {this.state.count}\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003eplus\u003c/button\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count - 1 })}\u003eminus\u003c/button\u003e \u003c/div\u003e } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:2","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"6.3 设置默认属性 为了确保localhost:8000/counter URL 仍可以被打开，我们现在必须在Counter 组件内部定义一个默认的属性 - 如果没有父组件传递 props，则标题标记和字体颜色将是未定义的！ 这可以通过 Prop-Types 完成，我们需要安装： npm install --save prop-types 现在，我们可以将其导入到/src/pages/counter.js： import React from \"react\" import PropTypes from \"prop-types\" 并在Counter组件内（在export语句上方）为 header prop 定义一个默认值： Counter.defaultProps = { header: \"Default Counter\", color: \"black\", } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:3","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"07 Gatsby 插件(Gatsby Plugins) 插件是实现 Gatsby API 的 的Node.js 软件包。 它们使您能够轻松解决常见的网站构建问题，例如 设置 Sass，添加 markdown 支持，过程映像等。 ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:2:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"7.1 进度动画 在此示例中，我们要使用 NProgress.js 插件将加载动画添加到我们的网站。 您使用 npm 安装 NProgress 插件： npm install --save gatsby-plugin-nprogress 现在，我们必须告诉 Gatsby 通过编辑（在文件不存在的情况下创建）应用程序根目录内的 gatsby-config.js 文件来使用该插件。 在 在starter 模板中，我们已经安装了 react-helmet 插件（此插件如下所述：Page Layout）。 现在，只需将 gatsby-plugin-nprogress 添加到数组中： module.exports = { siteMetadata: { title: `Gatsby Wiki`, }, plugins: [ `gatsby-plugin-react-helmet`, { { resolve: `gatsby-plugin-nprogress`, options: { // Setting a color is optional. color: `rebeccapurple`, // Disable the loading spinner. showSpinner: false, }, }, ], } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:2:1","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"7.2 离线支持和清单 现在，我们想在网站上添加一个 Serviceworker，以帮助我们缓存应用程序的重要部分，从而为我们提供一定程度的脱机支持-正如 Offline Plugin告诉我们的那样，我们还将安装 Manifest Plugin （请确保它是 在 Offline Plugin 之前列出！）。 npm install --save gatsby-plugin-manifest npm install --save gatsby-plugin-offline 现在，将它们添加到我们的 Gatsby 配置中： module.exports = { siteMetadata: { title: `Gatsby Wiki`, }, plugins: [ `gatsby-plugin-react-helmet`, { resolve: `gatsby-plugin-nprogress`, options: { // Setting a color is optional. color: `rebeccapurple`, // Disable the loading spinner. showSpinner: false, }, }, { resolve: `gatsby-plugin-manifest`, options: { name: \"Gatsby Wiki\", short_name: \"Gatsby Wiki\", start_url: \"/\", background_color: \"white\", theme_color: \"rebeccapurple\", display: \"minimal-ui\", icons: [ { // Everything in /static will be copied to an equivalent // directory in /public during development and build, so // assuming your favicons are in /static/favicons, // you can reference them here src: `/apple-touch-icon.png`, sizes: `180x180`, type: `image/png`, }, { { src: `/favicon.ico`, sizes: `256x256`, type: `image/png`, }, ], }, }, `gatsby-plugin-offline`, ], } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:2:2","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"08 单页面应用(Single-Page-Application) Gatsby 基于他的布局特性提供了一个创建 Single-Page-Applications (SPA’s)的简单方法。 你可以在/src/layout 中找到 JSX 和 和CSS。我们正在使用的 Gatsby Starter，已经提供了头导航栏，该头导航栏已在 index.js 文件中定义（并带有必需的 CSS）。 您可以看到该应用程序已经使用React-Helmet作为 Gatsby 插件。 这个可重用的 React 组件将管理您对文档\u003chead\u003e的所有更改。 Helmet采用纯 HTML 标记并输出纯 HTML 标记。 该布局定义了\u003cHeader /\u003e组件，该组件与\u003cHelmet /\u003e组件一起在\u003cTemplateWrapper /\u003e内部使用。 您到目前为止所创建的页面中的所有内容，都将通过{children}标签注入到 Wrapper 中。 这样，您可以创建顶部导航栏，页眉，侧面导航和页脚，然后将其显示在所有网站上。 ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:3:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"09 GraphQL 我们可以在应用程序的根目录下的 gatsby-config.js 内定义一些全局变量： module.exports = { siteMetadata: { title: `Gatsby Wiki`, author: `Mike Polinowski`, description: `Trying out Gatsby`, }, } 该数据将可用于每个页面，并可使用 GraphQL 查询。 只需将以下 GraphQL 查询添加到/src/pages/index.js，即可保留这些值： export const query = graphql` query FirstQuery { site { siteMetadata { title author description } } } ` 然后，我们需要将此{data}注入父组件\u003cIndexPage /\u003e： const IndexPage = ({data}) =\u003e 现在我们可以查询组件内部的这些数据： \u003ch1\u003e{data.site.siteMetadata.description}\u003c/h1\u003e 为什么是 data.site.siteMetadata？Gatsby 的 的graphql 调试器在 http://localhost:8000/___graphql上运行，您也可以使用它来测试查询并查看结果。 只需打开调试器，然后尝试我们先前的查询： ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:4:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":" 这篇文章主要是翻译和记录了一些 Gateby 的基础知识，有助于开发者通过这些基础知识进行快速的开发 Refer to the Article: https://mpolinowski.github.io/gatsby-js-knowledgebase ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:0:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"00 准备操作 The default Gatsby starter Github 有关项目结构的概述，请参阅Gatsby documentation - Building with Components 从您的 CLI 运行此安装程序（假设已安装 Gatsby）： gatsby new gatsby-wiki ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:1:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"01 开始你的 Gatsby 开发环境(Start your Gatsby development environment) 现在请转到你的站点目录中，并使用 npm 运行你的 Gatsby 开发环境如下： cd gatsby-wiki npm run development 看，你可以访问你的网站了http://localhost:8000 ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:2:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"02 添加内容和链接页面(Adding content and Linking Pages) /src/pages/index.js 文件包含常规的 JSX-在\u003cdiv /\u003e标记内添加任何 HTML，可以让它显示在您的网站内。（Gatsby 使用的热加载） import React from \"react\" import Link from \"gatsby-link\" const IndexPage = () =\u003e ( \u003cdiv\u003e \u003ch1\u003eHi people\u003c/h1\u003e \u003cp\u003eWelcome to your new Gatsby site.\u003c/p\u003e \u003cp\u003eNow go build something great.\u003c/p\u003e \u003cLink to=\"/page-2/\"\u003eGo to page 2\u003c/Link\u003e \u003c/div\u003e ) export default IndexPage 你可以通过import Link from gatsby-link使用 Link 组件并链接到其他页面 \u003cLink to=\"/page-2/\"\u003eGo to page 2\u003c/Link\u003e 链接我们的 index.js 页面到同目录的 page-2 页面。/src /pages 文件夹中的每个 js 文件都会自动被 Gatsby 路由！ ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:3:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"03 样式化 JSX(Styling your JSX) 你可以在组件中使用内联样式如： const IndexPage = () =\u003e ( \u003cdiv style={{ color: \"tomato\", background: \"blue\"}}\u003e \u003ch1\u003eHi people\u003c/h1\u003e \u003cp\u003eWelcome to your new Gatsby site.\u003c/p\u003e \u003cp\u003eNow go build something great.\u003c/p\u003e \u003cLink to=\"/page-2/\"\u003eGo to page 2\u003c/Link\u003e \u003c/div\u003e ) 一些高级样式，请查看 Gatsby 插件 Glamor 或者 Styled Components. 如何安装这些插件请查看Gatsby Plugins。 ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:4:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"04 添加交互式插件(Adding Interactive Components) React 允许你向页面中添加交互 - 我们想添加一个计数器，在加载时将其状态设置为 0，并且有两个使用 onClick 事件增加或减少计数器状态的按钮。 我们可以添加一个新文件/src/pages/counter.js并链接到index页面\u003cLink to=\"/counter/\"\u003eGo to Counter\u003c/Link\u003e。 import React from \"react\" class Counter extends React.Component { constructor() { super() this.state = { count: 0 } } render() { return ( \u003cdiv\u003e \u003ch1\u003eCounter\u003c/h1\u003e \u003cp\u003ecurrent count: {this.state.count}\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003e plus plus\u003c/button\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count - 1 })}\u003e minus minus\u003c/button\u003e \u003c/div\u003e ) } } export default Counter ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:5:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"05 向你的站点导入组件(Importing Components to your Sites) 目前为止，我们将 pages 目录中的每个文件都用作单独的站点。但是 React.js 允许我们采用默认组件-在文件底部导出的默认组件-并将其导入另一个页面。 例如，我们可以将上面的\u003cCounter /\u003e组件添加到索引页面中（而不是仅链接到它）。 我们只需要在/src/pages/index.js开头添加import一行: import React from \"react\" import Link from \"gatsby-link\" import Counter from \"./counter\" 并在 index.js 的 的JSX 代码内引用 Counter，如下所示： const IndexPage = () =\u003e ( \u003cdiv\u003e \u003ch1\u003eHi people\u003c/h1\u003e \u003cp\u003eWelcome to your new Gatsby site.\u003c/p\u003e \u003cp\u003eNow go build something great.\u003c/p\u003e \u003cLink to=\"/page-2/\"\u003eGo to Page 2\u003c/Link\u003e \u003cbr /\u003e \u003cbr /\u003e \u003cCounter /\u003e \u003c/div\u003e ) ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:6:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":null,"content":"自我评价 Hi，我叫GETHIN，是一名主修计算机，有丰富工作经验的软件工程师，擅长全栈开发，主要工作语言是C#，曾就职于多家知名外企和互联网企业，如Honeywell，腾讯文学等，目前就职于GreenDot。 擅长技术体系架构设计与重构，软件项目研究，分析设计与风险识别，爱好云原生架构设计。 熟悉OOP，SOA，AOP，MVC，MVVM，EDA，BDD，DDD，微服务架构，云架构，SPA等架构与编程思想，注重基于SOLID编码规范。熟悉常见的架构风格。熟悉各种UML的使用。 精通C#/.NET开发，熟悉Python，熟练掌握传统.NET相关技术WCF，WEBAPI，MVC，WPF，与现代.NET开发技术.NET Core, RabbitMQ, Azure, K8S, Docker 等。 认证Scrum Master，善于发现和解决敏捷开发中的各种技术和流程问题，熟知软件开发生命周期SDLC。 熟悉手机IOS端开发，Cordova，熟悉react，vue，javascript，jquary等。 了解SQL Server，Oracle，MySQL，存储过程，EF，Redis。 ","date":"0001-01-01","objectID":"https://blog.gethin.online/about/:0:1","tags":null,"title":"关于我","uri":"https://blog.gethin.online/about/"},{"categories":null,"content":"技术蓝图 本人对自己的技术栈做了一些总结，整理出一个六维技术蓝图。 参见： https://blog.gethin.online/blueprint/ ","date":"0001-01-01","objectID":"https://blog.gethin.online/about/:0:2","tags":null,"title":"关于我","uri":"https://blog.gethin.online/about/"},{"categories":null,"content":"电子邮箱 gexu1990@hotmail.com ","date":"0001-01-01","objectID":"https://blog.gethin.online/about/:0:3","tags":null,"title":"关于我","uri":"https://blog.gethin.online/about/"},{"categories":null,"content":"github https://github.com/gethin1990 ","date":"0001-01-01","objectID":"https://blog.gethin.online/about/:0:4","tags":null,"title":"关于我","uri":"https://blog.gethin.online/about/"},{"categories":null,"content":"工作经历 GREEN DOT - Sr. Software Engineer 在 GreenDot 担任 高级软件工程师，主要负责开发维护银行后端系统。如银行转账，信用卡自动还款 等 主要的开发语言是 C#，主要技术有 .NET Core, RabbitMQ, WEB API，K8S，SQLServer 等 主要项目：Eureka 发卡，TMM，BAAS交易，信用卡自动还款 等 2019 function non0plural(number, name) { if (number == 0) { return \"\" } if (number == 1 || number == -1) { return number + \" \" +name } return number + \" \" + name + \"s\" } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2019-05-31\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 let years = 0 if (months Honeywell - Software Engineer 1 years 在 霍尼韦尔 担任 移动端软件工程师，主要负责开发项目手机端应用，如SRS IOS手机端， 工业报警混合应用端 等 主要开发语言是SWIFT，JS。主要技术有 Cordova，Vue，IOS，Hybird 等 主要项目: REF SAAS IOS端应用，工业报警手机混合端应用 2018 GREEN DOT - Software Engineer II 3 years 在 GreenDot 担任 软件工程师，主要负责开发维护银行风险控制项目 主要开发语言是 C#， 主要技术有 .NET，WCF，MVC，WEBAPI 等 主要项目：APPLY PAY CASH风控，MITIK \u0026 IDOLOGY 风控系统集成，银行常规风控项目 等 2015 腾讯文学 - Software Engineer 1 years 在 腾讯文学 担任 软件工程师，主要负责开发维护起点读书的各种功能 在 主要开发语言是 C#，JS， 主要技术有 .NET，MVC，aspx，memchached，Oracle 主要项目：Mobile 端春节打赏活动，端闪屏替换，文章末打赏互动 等 2014 易贸集团 - Software Engineer 1 years 4 months 在 易贸集团 担任 软件工程师，主要负责开发维护集团内部的各种系统 主要开发语言是 C#，JS， 主要技术有 .NET，MVC，WPF，MSMQ 主要项目：会展系统，客服系统 等 2012 南京航空航天大学 - 计算机专业 4 years 南京航空航天大学，计算机专业，优秀毕业论文 2009 ","date":"0001-01-01","objectID":"https://blog.gethin.online/about/:0:5","tags":null,"title":"关于我","uri":"https://blog.gethin.online/about/"},{"categories":null,"content":"友情链如下 ","date":"0001-01-01","objectID":"https://blog.gethin.online/links/:1:0","tags":null,"title":"友情链接","uri":"https://blog.gethin.online/links/"},{"categories":null,"content":"欢迎留言 ","date":"0001-01-01","objectID":"https://blog.gethin.online/message-board/:1:0","tags":null,"title":"留言板","uri":"https://blog.gethin.online/message-board/"},{"categories":null,"content":"此页面用于展示收藏的网站 ","date":"0001-01-01","objectID":"https://blog.gethin.online/websites/:1:0","tags":null,"title":"网站收藏","uri":"https://blog.gethin.online/websites/"},{"categories":null,"content":"网站里程碑 BLOG 3.0 ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:0","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"},{"categories":null,"content":"个人博客3.0 由 hugo \u0026 loveit \u0026 github page 驱动 https://blog.gethin.online 摘要 博客3.0 基于 hugo 建站，主题采用了loveit，github action 作为 CI/CD，托管于github page。 gatsby 始终还是太重了，而且升级难度太大，依赖的包太多。强大也是强大的，折腾也是真折腾。人生有限，所以还是调整了策略，把博客迁移到hugo上，还是站在巨人的肩膀上才能做更多的事情。 摘要 2021-6-3 | 添加赞赏、网站分析、版权等功能 2021-5-28 | 添加时间轴、脑图、文章加密等功能 2021-5-17 | 添加背景图片 2021-5-16 | 添加顶部菜单 2021-5-12 | 添加测试文章 2021-5-11 | 集成搜索自动化 2021-5-10 | 添加评论，搜索 2021-5-6 | 集成Github Action 2021-5-5 | 建站 2021 function non0plural(number, name) { if (number == 0) { return \"\" } if (number == 1 || number == -1) { return number + \" \" +name } return number + \" \" + name + \"s\" } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2021-05-05\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 let years = 0 if (months BLOG 2.0 1 years ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:1","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"},{"categories":null,"content":"个人博客2.0 由 gatsby \u0026 tinacms \u0026 netlify 驱动 https://gethin.online 摘要 博客2.0 基于 gatsby 建站，主题采用了tinacms，netlify 作为 CI/CD，托管于netlify。 之前的基于react gatsby 引擎，依托于aks，个人维护精力有限，实在踩不起 19年 azure k8s 的那些坑。所以决定对网站进行升级，并托管于netlify。目前网站仍然保留。 2020 BLOG 1.0 10 months ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:2","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"},{"categories":null,"content":"个人博客1.0 由 gatsby \u0026 AKS 驱动 https://gethin.online 摘要 博客1.0 基于 gatsby 建站，自建主题，Azure DEVOPS 作为 CI/CD，托管于自建AKS。 2019年底个人博客建站，托管于自建AKS，使用Azure DEVOPS 作为CI/CD。博客用于总结个人技术，专注云原生，kubernetes，python 等技术。 2019 ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:3","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"}]