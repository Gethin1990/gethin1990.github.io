[{"categories":[],"content":"概述 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"什么是Redis Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。 Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。 与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis有哪些优缺点 优点 读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。 支持数据持久化，支持AOF和RDB两种持久化方式。 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。 数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。 缺点 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。 Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"为什么要用 Redis /为什么要用缓存 主要从“高性能”和“高并发”这两点来看待这个问题。 高性能： 假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！ 高并发： 直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"为什么要用 Redis 而不用 map/guava 做缓存? 缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。 使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis为什么这么快 1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)； 2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的； 3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 4、使用多路 I/O 复用模型，非阻塞 IO； 5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"数据类型 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:2:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis有哪些数据类型 Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求 数据类型 可以存储的值 操作 应用场景 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作, 对整数和浮点数执行自增或者自减操作 做简单的键值对缓存 LIST 列表 从两端压入或者弹出元素,对单个或者多个元素进行修剪;只保留一个范围内的元素 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据 SET 无序集合 添加、获取、移除单个元素;检查一个元素是否存在于集合中;计算交集、并集、差集; 从集合里面随机获取元素 交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对;获取所有键值对;检查某个键是否存在 结构化的数据，比如一个对象 ZSET 有序集合 添加、获取、删除元素;根据分值范围或者成员来获取元素;计算一个键的排名 去重但可以排序，如获取排名前几名的用户 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:2:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis的应用场景 总结一 计数器: 可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 缓存: 将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 会话缓存: 可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。 全页缓存（FPC）: 除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 查找表: 例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 消息队列(发布/订阅功能): List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。 分布式锁实现: 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。 其它: Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。 总结二 Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。 数据类型说明string字符串，最简单的k-v存储hashhash格式，value为field和value，适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有序的set 其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。 string——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。 hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。 list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。 set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。 Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。 如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用Redis的性能。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:2:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"持久化 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"什么是Redis持久化？ 持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis 的持久化机制是什么？各自的优缺点？ Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制: RDB：是Redis DataBase缩写快照 RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。 优点： 1、只有一个文件 dump.rdb，方便持久化。 2、容灾性好，一个文件可以保存到安全的磁盘。 3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能 4.相对于数据集大时，比 AOF 的启动效率更高。 缺点： 1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候) 2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。 AOF：持久化 AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。 当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。 优点： 1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。 2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。 3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）) 缺点： 1、AOF 文件比 RDB 文件大，且恢复速度慢。 2、数据集大的时候，比 rdb 启动效率低。 优缺点是什么？ AOF文件比RDB更新频率高，优先使用AOF还原数据。 AOF比RDB更安全也更大 RDB性能比AOF好 如果两个都配了优先加载AOF ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"如何选择合适的持久化方式 一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。 有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。 如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis持久化数据和缓存怎么做扩容？ 如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。 如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"过期键的删除策略 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:4:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis的过期键的删除策略 我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。 过期策略通常有以下三种： 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。) Redis中同时使用了惰性过期和定期过期两种过期策略。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:4:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis key的过期时间和永久有效分别怎么设置？ EXPIRE和PERSIST命令。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:4:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢? 除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种： 定时去清理过期的缓存； 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:4:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"内存相关 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据 redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis的内存淘汰策略有哪些 Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。 全局的键空间选择性移除 noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的） allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。 设置过期时间的键空间选择性移除 volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。 volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。 volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。 总结 Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis主要消耗什么物理资源？ 内存。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis的内存用完了会发生什么？ 如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis如何做内存优化？ 可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"线程模型 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:6:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis线程模型 Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。 虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。 参考：https://www.cnblogs.com/barrywxx/p/8570821.html ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:6:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"事务 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"什么是事务？ 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis事务的概念 Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。 总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis事务的三个阶段 事务开始 MULTI 命令入队 事务执行 EXEC 事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis事务相关命令 Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。 redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。 如果在一个事务中的命令出现错误，那么所有的命令都不会执行； 如果在一个事务中出现运行错误，那么正确的命令会被执行。 WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。 MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。 EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。 UNWATCH命令可以取消watch对所有key的监控。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"事务管理（ACID）概述 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务前后数据的完整性必须保持一致。 隔离性（Isolation） 多个事务并发执行时，一个事务的执行不应影响其他事务的执行 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在_AOF_持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis事务支持隔离性吗 Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:6","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis事务保证原子性吗，支持回滚吗 Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:7","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis事务其他实现 基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行， 其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完 基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:8","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"集群方案 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"哨兵模式 哨兵的介绍 sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能： 集群监控：负责监控 redis master 和 slave 进程是否正常工作。 消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。 哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。 故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。 哨兵的核心知识 哨兵至少需要 3 个实例，来保证自己的健壮性。 哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。 对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"官方Redis Cluster 方案(服务端路由查询) redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？ 简介 Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行 方案说明 通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位 每份数据分片会存储在多个互为主从的多节点上 数据写入先写主节点，再同步到从节点(支持配置为阻塞同步) 同一分片多个节点间的数据不保持一致性 读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点 扩容时时需要需要把旧节点的数据迁移一部分到新节点 在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。 16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。 节点间的内部通信机制 基本通信原理 集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。 分布式寻址算法 hash 算法（大量缓存重建） 一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡） redis cluster 的 hash slot 算法 优点 无中心架构，支持动态扩容，对业务透明 具备Sentinel的监控和自动Failover(故障转移)能力 客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可 高性能，客户端直连redis服务，免去了proxy代理的损耗 缺点 运维也很复杂，数据迁移需要人工干预 只能使用0号数据库 不支持批量操作(pipeline管道操作) 分布式逻辑和存储模块耦合等 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"基于客户端分配 简介 Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool 优点 优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强 缺点 由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。 客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"基于代理服务器分片 简介 客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端 特征 透明接入，业务程序不用关心后端Redis实例，切换成本低 Proxy 的逻辑和存储的逻辑是隔离的 代理层多了一次转发，性能有所损耗 业界开源方案 Twtter开源的Twemproxy 豌豆荚开源的Codis ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis 主从架构 单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。 redis replication -\u003e 主从架构 -\u003e 读写分离 -\u003e 水平扩容支撑读高并发 redis replication 的核心机制 redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量； 一个 master node 是可以配置多个 slave node 的； slave node 也可以连接其他的 slave node； slave node 做复制的时候，不会 block master node 的正常工作； slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了； slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。 注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。 另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。 redis 主从复制的核心原理 当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。 如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件， 同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中， 接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。 slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。 过程原理 当从库和主库建立MS关系后，会向主数据库发送SYNC命令 主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来 当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis 从Redis接收到后，会载入快照文件并且执行收到的缓存的命令 之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致 缺点 所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis集群的主从复制模型是怎样的？ 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:6","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"生产环境中的 redis 是怎么部署的？ redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。 机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。 5 台机器对外提供读写，一共有 50g 内存。 因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。 你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。 其实大型的公司，会有基础架构的 team 负责缓存集群的运维。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:7","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"说说Redis哈希槽的概念？ Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:8","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis集群会有写操作丢失吗？为什么？ Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:9","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis集群之间是如何复制的？ 异步复制 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:10","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis集群最大节点个数是多少？ 16384个 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:11","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis集群如何选择数据库？ Redis集群目前无法做数据库选择，默认在0数据库。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:12","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"分区 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis是单线程的，如何提高多核CPU的利用率？ 可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"为什么要做Redis分区？ 分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"你知道有哪些Redis分区实现方案？ 客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。 代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy 查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis分区有什么缺点？ 涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。 同时操作多个key,则不能使用Redis事务. 分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set） 当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。 分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"分布式问题 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis实现分布式锁 Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。 当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作 SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。 返回值：设置成功，返回 1 。设置失败，返回 0 。 使用SETNX完成同步锁的流程及事项如下： 使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功 为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间 释放锁，使用DEL命令将锁数据删除 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"如何解决 Redis 的并发竞争 Key 问题 所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！ 推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能） 基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。 在实践中，当然是从以可靠性为主。所以首推Zookeeper。 参考：https://www.jianshu.com/p/8bddd381de06 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"分布式Redis是前期做还是后期规模上来了再做好？为什么？ 既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。 一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。 这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"什么是 RedLock Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性： 安全特性：互斥访问，即永远只有一个 client 能拿到锁 避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区 容错性：只要大部分 Redis 节点存活就可以正常提供服务 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"缓存异常 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"缓存雪崩 缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。 解决方案 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。 给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"缓存穿透 缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。 解决方案 接口层增加校验，如用户鉴权校验，id做基础校验，id\u003c=0的直接拦截； 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力 附加 对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。 Bitmap： 典型的就是哈希表 缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。 布隆过滤器（推荐） 就是引入了k(k\u003e1)k(k\u003e1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。 Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。 Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。 Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"缓存击穿 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 解决方案 设置热点数据永远不过期。 加互斥锁，互斥锁 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"缓存预热 缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 解决方案 直接写个缓存刷新页面，上线时手工操作一下； 数据量不大，可以在项目启动的时候自动进行加载； 定时刷新缓存； ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"缓存降级 当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。 在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案： 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警； 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。 服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"热点数据和冷数据 热点数据，缓存才有价值 对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存 对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。 数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。 那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:6","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"缓存热点key 缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 解决方案 对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:7","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"常用工具 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:12:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis支持的Java客户端都有哪些？官方推荐用哪个？ Redisson、Jedis、lettuce等等，官方推荐使用Redisson。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:12:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis和Redisson有什么关系？ Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:12:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Jedis与Redisson对比有什么优缺点？ Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:12:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"其他问题 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis与Memcached的区别 两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同： 对比参数 Redis Memcached 类型 1. 支持内存 2. 非关系型数据库 1. 支持内存 2. 键值对形式 3. 缓存形式 数据存储类型 1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】 1. 文本型 2. 二进制类型 查询【操作】类型 1. 批量操作 2. 事务支持 3. 每个类型不同的CRUD 1.常用的CRUD 2. 少量的其他命令 附加功能 1. 发布/订阅模式 2. 主从分区 3. 序列化支持 4. 脚本支持【Lua脚本】 1. 多线程服务支持 网络IO模型 1. 单线程的多路 IO 复用模型 1. 多线程，非阻塞IO模式 事件库 自封转简易事件库AeEvent 贵族血统的LibEvent事件库 持久化支持 1. RDB 2. AOF 不支持 集群模式 原生支持 cluster 模式，可以实现主从复制，读写分离 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据 内存管理机制 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘 Memcached 的数据则会一直在内存中，Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 适用场景 复杂数据结构，有持久化，高可用需求，value存储内容较大 纯key-value，数据量非常大，并发量非常大的业务 (1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 (2) redis的速度比memcached快很多 (3) redis可以持久化其数据 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"如何保证缓存与数据库双写时的数据一致性？ 你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？ 一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况 串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。 还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后再删除缓存。 问题场景 描述 解决 先写缓存，再写数据库，缓存写成功，数据库写失败 缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读 这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存 先写数据库，再写缓存，数据库写成功，缓存写失败 写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据 缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现 需要缓存异步刷新 指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候 确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis常见性能问题和解决方案？ Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。 如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。 为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。 尽量避免在压力较大的主库上增加从库 Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。 为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master\u003c–Slave1\u003c–Slave2\u003c–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis官方为什么不提供Windows版本？ 因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"一个字符串类型的值能存储最大容量是多少？ 512M ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis如何做大量数据插入？ Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:6","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？ 使用keys指令可以扫出指定模式的key列表。 对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？ 这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:7","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"使用Redis做过异步队列吗，是如何实现的 使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:8","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis如何实现延时队列 使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:9","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis回收进程如何工作的？ 一个客户端运行了新的命令，添加了新的数据。 Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。 一个新的命令被执行，等等。 所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。 如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:10","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":[],"content":"Redis回收使用的是什么算法？ LRU算法 版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/ThinkWon/article/details/103522351 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:11","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"为什么使用MQ？MQ的优点 简答 异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。 流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。 日志处理 - 解决大量日志传输。 消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。 详答 主要是：解耦、异步、削峰。 解耦：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。 就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。 异步：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。 削峰：减少高峰时期对服务器压力。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:1:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息队列有什么优缺点？RabbitMQ有什么优缺点？ 优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。 缺点有以下几个： 系统可用性降低 本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低； 系统复杂度提高 加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。 一致性问题 A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。 所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:2:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"你们公司生产环境用的是什么消息中间件？ 这个首先你可以说下你们公司选用的是什么消息中间件，比如用的是RabbitMQ，然后可以初步给一些你对不同MQ中间件技术的选型分析。 举个例子：比如说ActiveMQ是老牌的消息中间件，国内很多公司过去运用的还是非常广泛的，功能很强大。 但是问题在于没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企业，用ActiveMQ做异步调用和系统解耦。 然后你可以说说RabbitMQ，他的好处在于可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。 另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。 而且经过调研，国内各大互联网公司落地大规模RabbitMQ集群支撑自身业务的case较多，国内各种中小型互联网公司使用RabbitMQ的实践也比较多。 除此之外，RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化，因此综合考虑过后，公司采取了RabbitMQ。 但是RabbitMQ也有一点缺陷，就是他自身是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以。 然后可以聊聊RocketMQ，是阿里开源的，经过阿里的生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。 而且RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。 另外就是Kafka。Kafka提供的消息中间件的功能明显较少一些，相对上述几款MQ中间件要少很多。 但是Kafka的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。 因此Kafka在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:3:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？ ActiveMQ RabbitMQ RocketMQ Kafka ZeroMQ 单机吞吐量 比RabbitMQ低 2.6w/s（消息做持久化） 11.6w/s 17.3w/s 29w/s 开发语言 Java Erlang Java Scala/Java C 主要维护者 Apache Mozilla/Spring Alibaba Apache iMatix，创始人已去世 成熟度 成熟 成熟 开源版本不够成熟 比较成熟 只有C、PHP等版本成熟 订阅形式 点对点(p2p)、广播（发布-订阅） 提供了4种：direct, topic ,Headers和fanout。fanout就是广播模式 基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式 基于topic以及按照topic进行正则匹配的发布订阅模式 点对点(p2p) 持久化 支持少量堆积 支持少量堆积 支持大量堆积 支持大量堆积 不支持 顺序消息 不支持 不支持 支持 支持 不支持 性能稳定性 好 好 一般 较差 很好 集群方式 支持简单集群模式，比如’主-备’，对高级集群模式支持不好。 支持简单集群，‘复制’模式，对高级集群模式支持不好。 常用 多对’Master-Slave’ 模式，开源版本需手动切换Slave变成Master 天然的‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave 不支持 管理界面 一般 较好 一般 无 无 综上，各种对比之后，有如下建议： 一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了； 后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高； 不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。 所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。 如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:4:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"MQ 有哪些常见问题？如何解决这些问题？ MQ 的常见问题有： 消息的顺序问题 消息的重复问题 消息的顺序问题 消息有序指的是可以按照消息的发送顺序来消费。 假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？ 解决方案： （1）保证生产者 - MQServer - 消费者是一对一对一的关系 缺陷： 并行度就会成为消息系统的瓶颈（吞吐量不够） 更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。 （2）通过合理的设计或者将问题分解来规避。 不关注乱序的应用实际大量存在 队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。 消息的重复问题 造成消息重复的根本原因是：网络不可达。 所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？ 消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:5:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"什么是RabbitMQ？ RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:6:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"rabbitmq 的使用场景 （1）服务间异步通信 （2）顺序消费 （3）定时任务 （4）请求削峰 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:7:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"RabbitMQ基本概念 Broker： 简单来说就是消息队列服务器实体 Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 Routing Key： 路由关键字，exchange根据这个关键字进行消息投递 VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。 Producer： 消息生产者，就是投递消息的程序 Consumer： 消息消费者，就是接受消息的程序 Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务 由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:8:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"RabbitMQ的工作模式 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"一.simple模式（即最简单的收发模式） 1.消息产生消息，将消息放入队列 2.消息的消费者(consumer) 监听 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失，这里可以设置成手动的ack,但如果设置成手动ack，处理完后要及时发送ack消息给队列，否则会造成内存溢出)。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:1","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"二.work工作模式(资源的竞争) 1.消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2同时监听同一个队列,消息被消费。C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用)。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:2","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"三.publish/subscribe发布订阅(共享资源) 1、每个消费者监听自己的队列； 2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:3","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"四.routing路由模式 1.消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息; 2.根据业务功能定义路由字符串 3.从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中。 4.业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误; ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:4","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"五.topic 主题模式(路由模式的一种) 1.星号井号代表通配符 2.星号代表多个单词,井号代表一个单词 3.路由功能添加模糊匹配 4.消息产生者产生消息,把消息交给交换机 5.交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费 （在我的理解看来就是routing查询的一种模糊匹配，就类似sql的模糊查询方式） ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:5","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证RabbitMQ消息的顺序性？ 拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:10:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息如何分发？ 若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:11:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息怎么路由？ 消息提供方-\u003e路由-\u003e一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）； 常用的交换器主要分为一下三种： fanout：如果交换器收到消息，将会广播到所有绑定的队列上 direct：如果路由键完全匹配，消息就被投递到相应的队列 topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:12:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息基于什么传输？ 由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:13:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？ 先说为什么会重复消费：正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除； 但是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。 针对以上问题，一个解决思路是：保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；保证消息等幂性； 比如：在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过； 假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:14:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？ 发送方确认模式 将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。 一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。 如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（notacknowledged，未确认）消息。 发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。 接收方确认机制 消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。 这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性； 下面罗列几种特殊情况 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重） 如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:15:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证RabbitMQ消息的可靠传输？ 消息不可靠的情况可能是消息丢失，劫持等原因； 丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息； 生产者丢失消息：从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息； transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降； confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后； rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了； 如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。 消息队列丢数据：消息持久化。 处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。 这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。 这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。 那么如何持久化呢？ 这里顺便说一下吧，其实也很容易，就下面两步 将queue的持久化标识durable设置为true,则代表是一个持久的队列 发送消息的时候将deliveryMode=2 这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据 消费者丢失消息：消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！ 消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息； 如果这时处理消息失败，就会丢失该消息； 解决方案：处理消息成功后，手动回复确认消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:16:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"为什么不应该对所有的 message 都使用持久化机制？ 首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多，message 的吞吐量可能有 10 倍的差距。 其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现“坑爹”问题。矛盾点在于，若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed ；若 message 设置了 persistent 属性，同时 queue 也设置了 durable 属性，那么当 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在这段时间内发送给该 queue 的 message 将被 blackholed 。 所以，是否要对 message 进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条/秒以上的消息吞吐量（单 RabbitMQ 服务器），则要么使用其他的方式来确保 message 的可靠 delivery ，要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。另外一种处理原则是：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:17:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证高可用的？RabbitMQ 的集群 RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。 单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式 普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。 镜像集群模式：这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:18:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？ 消息积压处理办法：临时紧急扩容： 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。 MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。 mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:19:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"设计MQ思路 比如说这个消息队列系统，我们从以下几个角度来考虑一下： 首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -\u003e topic -\u003e partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？ 其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。 其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -\u003e leader \u0026 follower -\u003e broker 挂了重新选举 leader 即可对外服务。 能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。 版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/ThinkWon/article/details/104588612 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:20:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"1 软件架构概述 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"1.1 软件架构的定义 架构是对系统的抽象，由多个架构组成，任何软件都存在架构，元素与其行为的集合构成架构内容，架构具有“基础性”，架构隐含有“决策”。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"1.2 软件架构重要性 项目关系人之间交流平台； 早期设计决策； 在较高层面上实现软件复用； 架构对开发的指导与规范意义不容忽略。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"1.3 架构的模型 结构模型；框架模型；动态模型；过程模型；功能模型； 逻辑视图，开发视图，进程视图，物理视图，场景。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"2 架构需求与软件质量属性 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:2:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"2.1 软件质量属性 功能性；可靠性；易用性；效率；可维护性；可移植性； 1 运行期质量属性 性能；安全性；易用性；可伸缩性；互操作性；可靠性；持续可用性；鲁棒性； 2 开发期质量属性 易理解性；可扩展性；可重用性；可测试性；可维护性； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:2:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"2.2 六个质量属性与实现 质量属性：可用性；可修改性；性能；安全性；可测试性；易用性； 质量属性场景组件：刺激源；刺激；环境；制品；响应；响应度量； 1 可用性与其实现战术 可用性描述 可用性战术 错误检测：命令/响应；心跳；异常； 错误恢复 表决；主动冗余；被动冗余；备件；状态再同步；检查点/回滚； 错误预防 从服务中删除；事务；进程监视器； 2 可修改性与其实现战术 可修改性描述 可修改性战术 局部化修改；(维持语义的一致性；预期期望的变更；泛化该模块；限制可能的选择) 防止连锁反应；（信息隐藏；维持现有的接口；限制通信路径；仲裁者的使用） 推迟绑定时间；（运行时注册；配置文件；多态；构件更换；） 3 性能与其实现技术 性能描述 性能战术 资源消耗：闭锁时间； 资源需求：减少处理事件流所需的资源；减少所处理事件的数量；控制资源的使用； 资源管理：引入并发；维持数据或计算的多个副本；增加可用资源； 资源仲裁：先进先出；固定优先级调度；动态优先级调度；静态调度； 4 安全性与其实现技术 安全性描述 安全性战术 抵抗攻击：对用户进行身份验证；对用户进行授权；维护数据的机密性；维护完整性；限制暴露的信息；限制访问； 检测攻击 从攻击中恢复：恢复；识别攻击者； 5 可测试性与其实现战术 可测试性描述 可测试性战术 输入/输出：记录回放；将接口与现实分离；优化访问线路 内部监控 6 易用性与实现战术 易用性描述 易用性战术 运行时战术：任务的模型；用户的模型；系统的模型； 设计时战术 支持用户主动操作 常见的六个质量属性:可用性、可修改性、性能、安全性、可测试性、易用性。 质量属性场景是一种面向特定的质量属性的需求，由6部分组成：刺激源、刺激、环境、制品、响应、响应度量。 以《淘宝网》为例： (1)可用性: 场景：天猫双十一购物狂欢节 刺激源：海量用户 刺激：过多用户涌入抢购，系统出现崩溃的状态 制品：处理系统崩溃的处理器 环境：正常操作 响应：淘宝网监控系统记录，处理人员进行紧急处理 响应度量：短时间内恢复系统正常运行 （2）可修改性： 场景：系统进行升级 刺激源：开发人员 刺激：改变页面的形态，增加少许功能、 制品：升级完后的系统 环境：设计时 响应：修改了用户的操作页面，未产生副作用 响应度量：在15分钟左右完成升级更改 （3）性能： 场景：天猫双十一购物狂欢节 刺激源：用户 刺激：进行疯狂购物交易 制品：系统 环境：在正常操作下 响应：大量的交易同时被处理 响应度量：每个交易平均等待时间为3s (4)安全性: 场景：黑客想要盗窃用户信息 刺激源：黑客 刺激：试图通过某些手段窃取用户的信息 制品：淘宝用户信息 环境：用户不在线时 响应：对访问者进行身份上的验证 响应度量：淘宝安全系统阻止黑客访问用户信息 （5）可测试性： 场景：一个马上要执行的系统功能 刺激源：系统测试人员 刺激：对系统功能执行测试 制品：系统的某个功能 环境：功能要部署时 响应：提供对状态值的访问、提供所要计算的值，准备测试环境 响应度量：3个小时测试了85% （6）易用性： 场景：用户误将某物品移入到购物车 刺激源：用户 刺激：用户想要将物品移出 制品：系统 环境；系统运行时 响应：希望快速完成操作 响应度量：在1s内完成撤销操作 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:2:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3 软件架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.1 软件架构风格分类 数据流风格：批处理序列；管道\\过滤器； 调用/返回风格：主程序、子程序；面型对象风格；层次结构； 独立构件风格：进程通信；事件系统； 虚拟机风格：解释器；基于规则的系统； 仓库风格：数据库系统；超文本系统；黑板系统； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.2 数据流风格 批处理序列：批处理风格的每一步处理都是独立的，并且每一步都是顺序的。 管道和过滤器：每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。 好处：良好的隐蔽性；高内聚低耦合；简单合成；支持重用；性能简单；允许死锁分析；支持并行执行； 弊端：导致进程成为批处理；不适合处理交互式应用； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.3 调用/返回风格 主程序/子程序 面向对象风格：对负责维护其表示的完整性；对象的表示对其他对象而言是隐蔽的； 层次结构风格：支持基于抽象程度递增的系统设计；支持功能增强；支持重用； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.4 独立构件风格 进程通信架构风格：构件是独立的过程，连接件是消息传递 事件系统风格：为软件重用提供了强大的支持；为还进系统带来了方便 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.5 虚拟机风格 解释器：包括完成解释工作的解释引擎，一个包含将被解释的代码储存区，一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的 规划为中心：基于规则的系统包括规则集、规则解释器，规则/数据选择器及工作内存 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:5","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.6 仓库风格 数据库系统、超文本系统、黑板风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:6","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4 层次系统架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.1 二层及三层C/S架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.2 B/S架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.3 MVC架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.4 MVP架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5 面向服务的架构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.1 SOA概述 5.1.1 服务基本结构 5.1.2 SOA设计原则 明确定义的接口、自包含和模块化、粗粒度、松耦合、互操作性。 5.1.3 服务构件和传统构件 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.2 SOA关键技术 UUDI（统一描述、发现集成） 数据模型、API、注册服务 WSDL（web服务描述语言） 服务实现定义：服务、端口 服务接口定义：绑定、端口类型、消息、类型 SOAP（简单对象访问协议） 封装；编码规则；RPC表示；绑定； SOAP消息：封装；SOAP头；SOAP体； REST（表述性状态转移） 网络上的所有事物都被抽象为资源 每个资源对应一个唯一资源标识 通过通用链接件接口对资源进行操作 对资源各种操作不会改变资源标识 所有操作都是无状态的 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.3 SOA的实现方法 Web Service 架构：服务提供者，服务请求者，服务注册者。 操作：发布，查找，绑定。 层次：底层传输层，服务通信协议层，服务描述层，服务层，业务流程层，服务注册层 服务注册表 服务注册，服务位置，服务绑定。 企业服务总线 功能： 支持异构环境中的服务，消息和基于事件的交互，并且具有适当的服务级别和可管理级别。 可以在几乎不更改代码的情况下，以一种无缝的非入侵方式使现有系统具有全新的服务接口，并能够在部署环境中支持任何标准 充当缓冲器的ESB于服务逻辑和分离，从而使不同的系统可以同时使用同一服务，不用在系统或数据变化时改动服务代码 ESB还提供服务代码和协议转换等功能，多种传输方式，发现和使用企业服务或界面提供基础设施。 提供可配置的消息转换翻译机制和基于消息内容的消息路由服务，传输消息到不同的目的地 提供安全和拥有者机制，保证消息和服务使用的认证，授权和完整性。 优势: 扩展的、基于标准的连接。 灵活的、服务导向的应用组合。 提高复用率。 减少市场的反应时间。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.4 微服务 优势： 技术异构性，弹性，扩展，简单部署，与组织结构相匹配，可组合性，对可替代的优化。 挑战： 分布式系统的复杂度，运维成本，部署自动化，DEVOPS与组织结构，服务间的依赖测试，服务间的依赖管理 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"6 架构设计 演变交付生命周期 属性驱动设计法ADD 按架构组织开发团队 开发骨架系统 利用商业构件进行开发 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:6:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"7 软件架构文档化 架构文档的使用者 合理的编写规则 从读者角度编写文档，避免出现不必要的重复，避免歧义，使用标准结构，记录基本原理，文档保持更新但注意频率，针对目标的适宜性对文档进行评审 视图编档 视图概述，元素目录，上下文图，可变性指南，架构背景，术语表，其他信息。 跨视图文档 UML 软件架构重构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:7:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8 软件架构评估 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8.1 软件架构评估方法 基于调查问卷 基于场景 基于度量 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8.2 架构的权衡分析法ATAM 一个简洁的架构表述 表达清楚的业务目标 用场景集合捕获质量需求 架构决策到质量需求的映射 所确定的敏感点与权衡点的集合 有风险决策和无风险决策 风险主题集合 产生一些附属结果 产生一些无形的结果 步骤： ATAM方法表述 商业动机表述 架构表述 对架构方法进行分类 生成质量属性效用树 分析架构方法 集体讨论并确定场景优先级 分析架构方法 结果的表述 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8.3 成本效益分析法CBAM 步骤： 整理场景，对场景进行求精，确定场景优先级，分配效用，策略-场景-响应，质量属性响应级别效用，各架构策略的总收益， ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9 构件及其复用 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9.1 商用构件标准规范 CORBA，J2EE，DNA 2000 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9.2 应用系统簇与构件系统 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9.3 基于服用开发的组织结构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10 产品线及系统演化 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.1 复用与产品线 需求，架构设计，元素，建模与分析，测试，项目规划，过程、方法和工具，人员，样本系统，缺陷消除 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.2 基于产品线的架构 三个方面：确定变化点，支持变化点，对产品线架构的适宜性进行评估 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.3 产品线的开发模型 前瞻性产品线，反应性模型 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.4 特定领域软件架构 领域模型为需求定义率领域知识和领域词汇 软件界面的设计往往和领域模型关系密切 领域模型的合理性将严重影响软件系统的可扩展性 在分层架构指导下，领域模型精华后即成为业务层骨架 领域模型也是其数据模型的基础 领域模型是团队交流的基础 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.4 架构及系统演化 需求变动归类，制订架构演化计划，修改增加删除构件，更新构件的互相作用，构架组装和测试，技术评审，产生演化后的架构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:5","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11 软件架构视图 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.1 软件视图分类 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.2 模块视图类型及其风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.3 C\u0026C视图类型及其风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.4 分配视图类型及其风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.5 各视图类型间的映射关系 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:5","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["概要"],"content":"自定义扩展 ","date":"2021-05-26","objectID":"https://blog.gethin.online/second-post/:1:0","tags":[],"title":"自定义扩展功能测试","uri":"https://blog.gethin.online/second-post/"},{"categories":["概要"],"content":"脑图测试 Root l1 l11 l12 l2 l12 l121 l122 l13 l3 l31 l313 l323 Test1 ABC 2021 function non0plural(number, name) { if (number == 0) { return \"\" } if (number == 1 || number == -1) { return number + \" \" +name } return number + \" \" + name + \"s\" } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2021-05-01\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 let years = 0 if (months Test 11 months ABC 2020 ","date":"2021-05-26","objectID":"https://blog.gethin.online/second-post/:1:1","tags":[],"title":"自定义扩展功能测试","uri":"https://blog.gethin.online/second-post/"},{"categories":["概要"],"content":"网站功能 文章加密 自定义域名 网站分析 脑图 时间轴 评论的优化 关于页面的优化 版权声明 运行时间 赞赏 网站流量统计 ","date":"2021-05-22","objectID":"https://blog.gethin.online/blog-todo/:1:0","tags":["待办事项"],"title":"博客代办事项","uri":"https://blog.gethin.online/blog-todo/"},{"categories":["概要"],"content":"编辑 新文章头部模板 ","date":"2021-05-22","objectID":"https://blog.gethin.online/blog-todo/:2:0","tags":["待办事项"],"title":"博客代办事项","uri":"https://blog.gethin.online/blog-todo/"},{"categories":["语言与平台"],"content":"自然拼读 ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:0","tags":null,"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["语言与平台"],"content":"元音 a am pam sam ad dad at cat rat an van man ran ap cap nap lap ab cab lab tab ag bag rag wag ack jack back sack pack ant pant Kant rant ang bang hang sang ank bank rank sank tank amp lamp camp ramp e ed Ted red en ten hen ell bell sell eg egg meg leg beg et jet get wet ess Bess less mess end bend mend send ent Kent bent sent went tent est best pest nest test west eck neck peck deck i id Sid kid ig pig dig ill Jill hill kill it sit fit hit pit im Tim Jim Kim dim in fin win tin pin ing ding ring king sing ink pink sink link ish fish dish wish ick pick kick sick tick Rick o ox fox box ot pot hot op hop top ob Bob job rob od nod pod rod og hog jog log om Tom mom ock rock sock lock u ug bug mug un run sun ut hut nut ub cub rub tub um gum hum mum uck duck luck tunk ump bump hump jump unch lunch munch punch ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:1","tags":null,"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["语言与平台"],"content":"辅音 辅音 bl black blink block blush cl clock clap click club class fl flag flex flip flop flush gl glass glad glob pl plan plane plant plot plum br Brad brick bring brush cr crab crack crash crop dr dress drip drop drum fr frog frank fresh Fred gr grass grab grand grid tr track trap trick truck sk skip skin skill sl sled slam slip slot sp spot spell spin spill st stand step stop stick sw swim swing swell ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:2","tags":null,"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["语言与平台"],"content":"元音组合 元音组合 ead read bead lead ean jean dean lean clean eat heat meat neat treat eal meal seal deal real oa goat toad oat coat goat boat moat oad road toad load oap soap oak soak oast toast roast coast boast oal goal oaf loaf ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:3","tags":null,"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["概要"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容。 此文章用于测试。 以下内容仅用于测试主题功能 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:0:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"LoveIt 的文章列表参考如下 hugoloveit https://hugoloveit.com/zh-cn/posts/ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:0:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"1 内容组织 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:1:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"2 前置参数 ---title:\"我的第一篇文章\"subtitle:\"\"# 文章副标题date:2020-03-04T15:58:26+08:00# 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置.lastmod:2020-03-04T15:58:26+08:00# 上次修改内容的日期时间.draft:true# 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染.author:\"\"# 文章作者.authorLink:\"\"# 文章作者的链接.description:\"\"# 文章内容的描述.license:\"\"# 这篇文章特殊的许可.images:[]# 页面图片, 用于 Open Graph 和 Twitter Cards.tags:[]# 文章的标签.categories:[]# 文章所属的类别.featuredImage:\"\"# 文章的特色图片.featuredImagePreview:\"\"# 用在主页预览的文章特色图片.hiddenFromHomePage:false# 如果设为 true, 这篇文章将不会显示在主页上.hiddenFromSearch:false# 如果设为 true, 这篇文章将不会显示在搜索结果中.twemoji:false# 如果设为 true, 这篇文章会使用 twemoji.lightgallery:true# 如果设为 true, 文章中的图片将可以按照画廊形式呈现.ruby:true# 如果设为 true, 这篇文章会使用 上标注释扩展语法.fraction:true# 如果设为 true, 这篇文章会使用 分数扩展语法.fontawesome:true# 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法.linkToMarkdown:true# 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接.rssFullText:false# 如果设为 true, 在 RSS 中将会显示全文内容.toc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位于 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位于 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...## featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法.resources:- name:featured-imagesrc:featured-image.jpg- name:featured-image-previewsrc:featured-image-preview.jpg--- ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:2:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3 内容摘要 文章摘要预览文章摘要预览 \" 文章摘要预览 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.1 自动摘要拆分 网站设置 summaryLength ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.2 手动摘要拆分 添加 \u003c!--more--\u003e ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.3 前置参数摘要 前置参数 summary ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.4 使用文章描述作为摘要 前置参数 description ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"4 Markdown 基本语法 ignore ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:4:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5 Markdown 扩展语法 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.1 Emoji 支持 https://hugoloveit.com/zh-cn/emoji-support/ 😀,😄,😆,🤣,😅,😂 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.2 数学公式 $$ c = \\pm\\sqrt{a^2 + b^2} $$ $$ c = \\pm\\sqrt{a^2 + b^2} $$ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.3 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\) $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.4 mhchem $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.5 字符注音或者注释 [Hugo]^(一个开源的静态网站生成工具) Hugo一个开源的静态网站生成工具 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:5","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.6 分数 [99]/[100] 99/100 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:6","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.7 Font Awesome 真开心! :(far fa-grin-tears): 真开心! ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:7","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.8 转义字符 {?:}joy: :joy: ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:8","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6 内置 Shortcodes https://hugoloveit.com/zh-cn/theme-documentation-built-in-shortcodes/ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.1 figure {{\u003c figure src=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.2 gist {{\u003c gist spf13 7896402 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.3 highlight {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.4 instagram instagram 的文档 {{\u003c instagram BWNjjyYFxVx hidecaption \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.5 param param 的文档 {{\u003c param description \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:5","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.6 ref 和 relref ref 和 relref 的文档 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:6","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.7 tweet tweet 的文档 {{\u003c tweet 877500564405444608 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:7","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.8 vimeo vimeo 的文档 {{\u003c vimeo 146022717 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:8","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.9 youtube youtube 的文档 {{\u003c youtube w7Ft2ymGmfc \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:9","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7 扩展shortcodes ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.1 style {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} This is a right-aligned paragraph. ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.2 link href [必需] content [可选] title [可选] rel [可选] class [可选] {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} Upstage ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.3 image src [必需] 图片的 URL. alt [可选] 图片无法显示时的替代文本, 默认值是 src 参数的值. caption [可选] 图片标题. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} lighthouse (image)\" lighthouse (image) ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.4 admonition 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] admonition 横幅的类型, 默认值是 note. title [可选] admonition 横幅的标题, 默认值是 type 参数的值. open [可选] 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.5 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 7.5.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:5","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.5.8 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:6","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.6 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:7","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.7 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. 7.7.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"music/wind.mp3\" name=起风了 artist=买辣椒也用券 cover=\"images/wind.png\" \u003e}} 呈现的输出效果如下: 7.7.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: 7.7.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] [netease, tencent, kugou, xiami, baidu]音乐平台. type [必需] [song, playlist, album, search, artist]音乐类型. id [必需] 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: 7.7.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme *[可选]*音乐播放器的主题色, 默认值是 #448aff. fixed *[可选]*是否开启固定模式, 默认值是 false. mini *[可选]*是否开启迷你模式, 默认值是 false. autoplay *[可选]*是否自动播放音乐, 默认值是 false. volume *[可选]*第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex *[可选]*是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选][all, one, none]音乐列表的循环模式, 默认值是 none. order [可选][list, random]音乐列表的播放顺序, 默认值是 list. list-folded *[可选]*初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height *[可选]*音乐列表的最大高度, 默认值是 340px. ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:8","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.8 bilibili {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:9","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.9 typeit typeit shortcode 基于 TypeIt 提供了打字动画. {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:10","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.10 script {{\u003c script \u003e}} console.log('Hello LoveIt!'); {{\u003c /script \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:11","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["语言与平台"],"content":" 声明：本文仅用做复习整理知识，在下列文章中进行二次加工，大部分内容参考自： https://www.cnblogs.com/edisonchou/p/4787775.html https://zhuanlan.zhihu.com/p/38799766 .NET 本质论 .NET中所有类型的基类是什么 值类型和引用类型的区别 装箱和拆箱的原理 struct和class的区别，struct适用于哪些场合 C#中方法的参数传递有哪几种方式 浅复制和深复制的区别 .NET中栈和堆的差异 执行string abc=\"aaa\"+\"bbb\"+\"ccc\"共分配了多少内存 托管堆内存分配 简要说说.NET中GC的运行机制 GC机制中如何判断一个对象仍然在被使用（如何标记） GC中代（Generation）是什么，分为几代（如何移动） GC有什么问题 托管与非托管资源是什么 托管资源 非托管资源 Dispose和Finalize方法在何时被调用（非托管资源回收方法） .NET中的托管堆中是否可能出现内存泄露的现象 大对象的分配 不恰当地保存根引用 不正确的Finalize方法 .NET 本质论 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:0:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":".NET中所有类型的基类是什么 System.Object ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:1:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"值类型和引用类型的区别 所有继承自System.ValueType的类型是值类型，而其他类型都是引用类型。 常用的值类型包括：结构、枚举、整数型、浮点型、布尔型等等。 赋值时的区别 值类型的变量直接将获得一个真实的数据副本，而对引用类型的赋值仅仅是把对象的引用赋给变量，这样就可能导致多个变量引用到一个对象实例上。 内存分配的区别 引用类型的对象将会在堆上分配内存，而值类型的对象则会在堆栈上分配内存 继承结构的区别 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:2:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"装箱和拆箱的原理 装箱：CLR需要做额外的工作把堆栈上的值类型移动到堆上，这个操作就被称为装箱。 拆箱：装箱操作的反操作，把堆中的对象复制到堆栈中，并且返回其值。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:3:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"struct和class的区别，struct适用于哪些场合 struct（结构）是值类型，而class（类）是引用类型。 struct与class相比，不具备继承的特性 struct不能有无参数的构造方法（class默认就有），也不能为成员变量定义初始值。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:4:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"C#中方法的参数传递有哪几种方式 ref关键字：引用传递参数，需要在传递前初始化；（ref 要求参数在传入前被初始化） out关键字：引用传递参数，需要在返回前初始化；（out 要求参数在方法返回前被初始化） params关键字：允许方法在定义时不确定参数的数量。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:5:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"浅复制和深复制的区别 浅复制：复制一个对象的时候，仅仅复制原始对象中所有的非静态类型成员和所有的引用类型成员的引用。（新对象和原对象将共享所有引用类型成员的实际对象） 深复制：复制一个对象的时候，不仅复制所有非静态类型成员，还要复制所有引用类型成员的实际对象。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:6:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":".NET中栈和堆的差异 .NET 中的栈 堆栈用来存储值类型的对象和引用类型对象的引用（地址），其分配的是一块连续的地址，堆栈上的地址从高位向低位分配内存。 .NET 中的堆 托管堆的分配也是连续的（从低位到高位），但是堆中却存在着暂时不能被分配却已经无用的对象内存块。 当一个引用类型对象被初始时，会通过指向堆上可用空间的指针分配一块连续的内存，然后使堆栈上的引用指向堆上刚刚分配的这块内存块。 .NET中的非托管堆 非托管的堆需要程序员用指针手动地分配和释放内存，.NET中的GC和内存管理不适用于非托管堆。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:7:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"执行string abc=\"aaa\"+\"bbb\"+\"ccc\"共分配了多少内存 string是引用类型，其内存分配会遵照引用类型的规范。字符串具有不可变性。 string first = \"aaa\" + \"bbb\" + \"ccc\"; string second = \"aaabbbccc\"; int num = 1; string str = \"aaa\" + num.ToString(); Console.WriteLine(str); string str = \"aaa\"; str += \"bbb\"; str += \"ccc\"; Console.WriteLine(str) ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:8:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"托管堆内存分配 CLR在进程中分配一块保留地址控件-即托管堆 托管堆有分为多个区域-垃圾回收堆（GC Heap）和加载堆（Loader Heap）[High-Frequency Heap、Low-Frequency Heap和Stub Heap] Loader Heap最重要的信息就是元数据相关的信息 每个Type在Loader Heap上体现一个Method Table，而Method Table中则记录了存储的元数据信息 Loader Heap不受GC控制。 TypeHandle：类型句柄，指向对应实例的方法表，每个对象创建时都包含该附加成员，并占用4个字节的内存空间。 SyncBlockIndex：用于线程同步，每个对象创建时也包含该附加成员la。它指向一块呗称为Synchronization Block的内存块，用于管理对象同步，同样占用4个字节的内存空间。 NextObjPtr:由托管堆维护的一个指针，用于标识下一个新建对象分配时在托管堆中所处的位置。CLR初始化时，NextObjPtr位于托管堆的及地址。 首先，将声明一个引用类型变量aUser：（堆栈4字节） VIPUser aUser;; 它仅是一个引用（指针），保存在线程的堆栈上，占用4Byte的内存空间，将用于保存VIPUser对象的有效地址，其执行过程正是上文描述的在线程栈上的分配过程。此时aUser未指向任何有效的实例，因此被自行初始化为null，试图对aUser的任何操作将抛出NullReferenceException异常。 然后，通过new操作执行对象创建：（GC托管堆20字节） aUser = new VIPUser(); 如上文所言，该操作对应于执行newobj指令，其执行过程又可细分为以下几步： 1、CLR按照其继承层次进行搜索，计算类型及其所有父类的字段，该搜索将一直递归到System.Object类型，并返回字节总数，以本例而言类型VIPUser需要的字节总数为 15 Bytes，具体计算为：VIPUser类型本身字段isVip（bool型）为 1 Bytes；父类User类型的字段id（Int32型）为 4 Bytes，字段user保存了指向UserInfo型的引用，因此占 4 Bytes，而同时还要为UserInfo分配 6 Bytes字节的内存。 2、实例对象所占的字节总数还要加上对象附加成员所需的字节总数，其中附加成员包括TypeHandle和SyncBlockIndex，共计 8 Bytes（在32位CPU平台下）。因此，需要在托管堆上分配的字节总数为 23 Bytes，而堆上的内存块总是按照 4 Bytes的倍数进行分配，因此本例中将分配 24 Bytes的地址空间。 3、CLR在当前AppDomain对应的托管堆上搜索，找到一个未使用的 20 Bytes 的连续空间，并为其分配该内存地址。事实上，GC使用了非常高效的算法来满足该请求，NextObjPtr指针只需要向前推进 20 Bytes，并清零原NextObjPtr指针和当前NextObjPtr指针之间的字节，然后返回原NextObjPtr指针地址即可，该地址正是新创建对象的托管堆地址，也就是aUser引用指向的实例地址。而此时的NextObjPtr仍指向下一个新建对象的位置。注意，栈的分配是向低地址扩展，而堆的分配是向高地址扩展。 最后，调用对象构造器，进行对象初始化操作，完成创建过程。该构造过程，又可细分为以下几个环节： （a）构造VIPUser类型的Type对象，主要包括静态字段、方法表、实现的接口等，并将其分配在上文提到托管堆的Loader Heap上。 （b）初始化aUser的两个附加成员：TypeHandle 和 SyncBlockIndex。 （解析类型）将TypeHandle指针指向Loader Heap上的MethodTable，CLR将根据TypeHandle来定位具体的Type； （实现对象实例同步）将SyncBlockIndex指针指向Synchronization Block的内存块，用于在多线程环境下对实例对象的同步操作。 （c）调用VIPUser的构造器，进行实例字段的初始化。 实例初始化时，会首先向上递归执行父类初始化，直到完成System.Object类型的初始化，然后再返回执行子类的初始化，直到执行VIPUser类为止。 以本例而言，初始化过程为首先执行System.Object类，再执行User类，最后才是VIPUser类。最终，newobj分配的托管堆的内存地址，被传递给VIPUser的this参数，并将其引用传给栈上声明的aUser。(System.Object-\u003eUser-\u003eVIPUser-\u003e封装成aUser-\u003e地址丢给线程堆栈) ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:9:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"简要说说.NET中GC的运行机制 GC是垃圾回收（Garbage Collect）的缩写,.NET中的垃圾回收是指清理托管堆上不会再被使用的对象内存，并且移动仍在被使用的对象使它们紧靠托管堆的一边。 标记：找到所有不再被使用的对象：对象A和对象C，并标记为垃圾； 移动：移动仍在被使用的对象：对象B和对象D; 通常情况下，我们不需要手动干预垃圾回收的执行，不过CLR仍然提供了一个手动执行垃圾回收的方法：GC.Collect()。当我们需要在某一批对象不再使用并且及时释放内存的时候可以调用该方法来实现。But，垃圾回收的运行成本较高（涉及到了对象块的移动、遍历找到不再被使用的对象、很多状态变量的设置以及Finalize方法的调用等等），对性能影响也较大，因此我们在编写程序时，应该避免不必要的内存分配，也尽量减少或避免使用GC.Collect()来执行垃圾回收。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:10:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"GC机制中如何判断一个对象仍然在被使用（如何标记） Mark-Compact 标记压缩算法 在.NET中引用类型对象实例通常通过引用来访问，而GC判断堆中的对象是否仍然在被使用的依据也是引用。简单地说：当没有任何引用指向堆中的某个对象实例时，这个对象就被视为不再使用。 在GC执行垃圾回收时，会把引用分为以下两类： （1）根引用：往往指那些静态字段的引用，或者存活的局部变量的引用； （2）非根引用：指那些不属于根引用的引用，往往是对象实例中的字段。 垃圾回收时，GC从所有仍在被使用的根引用出发遍历所有的对象实例，那些不能被遍历到的对象将被视为不再被使用而进行回收。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:11:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"GC中代（Generation）是什么，分为几代（如何移动） GC会把所有托管堆内的对象按照其已经不再被使用的可能性分为三类，并且从最有可能不被使用的类别开始扫描，.NET对这样的分类类别有一个称呼：代（Generation）。 第0代，新近分配在堆上的对象，从来没有被垃圾收集过。任何一个新对象，当它第一次被分配在托管堆上时，就是第0代。 第1代，经历过一次垃圾回收后，依然保留在堆上的对象。 第2代，经历过两次或以上垃圾回收后，依然保留在堆上的对象。如果第2代对象在进行完垃圾回收后空间仍然不够用，则会抛出OutOfMemoryException异常。 并不是每次垃圾回收都会同时回收3个代的所有对象，越小的代拥有着越多被释放的机会。 CLR对于代的基本算法是：每执行N次0代的回收，才会执行一次1代的回收，而每执行N次1代的回收，才会执行一次2代的回收。 根据.NET的垃圾回收机制，0代、1代和2代的初始分配空间分别为256KB、2M和10M。 一个对象实例存活的时间越长，那么它就具有更大的机率去存活更长的时间。 因为一次GC回收之后仍然被使用的对象会被移动到更高的代上，因此我们需要避免保留已经不再被使用的对象引用，将对象的引用置为null是告诉.NET该对象不需要再使用的最直接的方法。 在前面我们提到Finalize方法会大幅影响性能，通过结合对代的理解，我们可以知道：在带有Finalize方法的对象被回收时，该对象会被视为正在被使用从而被留在托管堆中，且至少要等一个GC循环才能被释放（为什么是至少一个？因为这取决于执行Finalize方法的线程的执行速度）。很明显，需要执行Finalize方法的那些对象实例，被真正释放时最乐观的情况下也已经位于1代的位置上了，而如果它们是在1代上才开始释放或者执行Finalize方法的线程运行得慢了一点，那该对象就在第2代上才被释放，相对于0代，这样的对象实例在堆中存留的时间将长很多。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:12:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"GC有什么问题 首先，GC并不是能释放所有的资源。它不能自动释放非托管资源。 第二，GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。 GC并不是实时性的，这会造成系统性能上的瓶颈和不确定性。所以有了IDisposable接口，IDisposable接口定义了Dispose方法，这个方法用来供程序员显式调用以释放非托管资源。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:13:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"托管与非托管资源是什么 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:14:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"托管资源 .NET中的所有类型都是（直接或间接）从System.Object类型派生的。.NET中超过80%的资源都是托管资源。 CTS中的类型被分成两大类——引用类型（reference type，又叫托管类型[managed type]），分配在内存堆上；值类型（value type），分配在堆栈上。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:14:1","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"非托管资源 ApplicationContext, Brush, Component, ComponentDesigner, Container, Context, Cursor, FileStream, Font, Icon, Image, Matrix, Object, OdbcDataReader, OleDBDataReader, Pen, Regex, Socket, StreamWriter, Timer, Tooltip, 文件句柄, GDI资源, 数据库连接等等资源。可能在使用的时候很多都没有注意到！ ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:14:2","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"Dispose和Finalize方法在何时被调用（非托管资源回收方法） Dispose方法 我们会在Dispose方法中实现一些托管对象和非托管对象的释放以及业绩业务逻辑的结束工作等等。 But，即使我们实现了Dispose方法，也不能得到任何有关释放的保证，Dispose方法的调用依赖于类型的使用者，当类型被不恰当地使用，Dispose方法将不会被调用,我们一般会借助using等语法来帮助Dispose方法被正确调用。 Finalize方法 Finalize在GC执行垃圾回收时被调用 ①当每个包含Finalize方法的类型的实例对象被分配时，.NET会在一张特定的表结构中添加一个引用并且指向这个实例对象，暂且称该表为“带析构方法的对象表”； ②当GC执行并且检测到一个不被使用的对象时，需要进一步检查“带析构方法的对象表”来查询该对象类型是否含有Finalize方法，如果没有则将该对象视为垃圾，如果存在则将该对象的引用移动到另外一张表，暂且称其为“待析构的对象表”，并且该对象实例仍然被视为在被使用。 ③CLR将有一个单独的线程负责处理“待析构的对象表”，其执行方法内部就是依次通过调用其中每个对象的Finalize方法，然后删除引用，这时托管堆中的对象实例就被视为不再被使用。 ④下一个GC执行时，将释放已经被调用Finalize方法的那些对象实例。 结合使用Dispose和Finalize方法：标准Dispose模式 Finalize方法由于有CLR保证调用，因此比Dispose方法更加安全（这里的安全是相对的，Dispose需要类型使用者的及时调用），但在性能方面Finalize方法却要差很多。因此，我们在类型设计时一般都会使用标准Dispose模式：Finalize方法作为Dispose方法的后备，只有在使用者没有调用Dispose方法的情况下，Finalize方法才被视为需要执行。这一模式保证了对象能够被高效和安全地释放，已经被广泛使用。 标准dispose模式模板 public class BaseTemplate : IDisposable { // 标记对象是否已经被释放 private bool isDisposed = false; // Finalize方法 ~BaseTemplate() { Dispose(false); } // 实现IDisposable接口的Dispose方法 public void Dispose() { Dispose(true); // 告诉GC此对象的Finalize方法不再需要被调用 GC.SuppressFinalize(this); } // 虚方法的Dispose方法做实际的析构工作 protected virtual void Dispose(bool isDisposing) { // 当对象已经被析构，则不必再继续执行 if(isDisposed) { return; } if(isDisposing) { // Step1:在这里释放托管资源 } // Step2:在这里释放非托管资源 // Step3:最后标记对象已被释放 isDisposed = true; } public void MethodA() { if(isDisposed) { throw new ObjectDisposedException(\"对象已经释放\"); } // Put the logic code of MethodA } public void MethodB() { if (isDisposed) { throw new ObjectDisposedException(\"对象已经释放\"); } // Put the logic code of MethodB } } public sealed class SubTemplate : BaseTemplate { // 标记子类对象是否已经被释放 private bool disposed = false; protected override void Dispose(bool isDisposing) { // 验证是否已被释放，确保只被释放一次 if(disposed) { return; } if(isDisposing) { // Step1:在这里释放托管的并且在这个子类型中申明的资源 } // Step2:在这里释放非托管的并且这个子类型中申明的资源 // Step3:调用父类的Dispose方法来释放父类中的资源 base.Dispose(isDisposing); // Step4:设置子类的释放标识 disposed = true; } } 真正做释放工作的只是受保护的虚方法Dispose，它接收一个bool参数，主要用于区分调用者是类型的使用者还是.NET的GC机制。两者的区别在于通过Finalize方法释放资源时不能再释放或使用对象中的托管资源，这是因为这时的对象已经处于不被使用的状态，很有可能其中的托管资源已经被释放掉了。在Dispose方法中GC.SuppressFinalize(this)告诉GC此对象在被回收时不需要调用Finalize方法，这一句是改善性能的关键，记住实现Dispose方法的本质目的就在于避免所有释放工作在Finalize方法中进行。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:15:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":".NET中的托管堆中是否可能出现内存泄露的现象 首先，必须明确一点：即使在拥有垃圾回收机制的.NET托管堆上，仍然是有可能发生内存泄露现象的。 其次，什么是内存泄露？内存泄露是指内存空间上产生了不再被实际使用却又不能被分配的内存空间，其意义很广泛，像内存碎片、不彻底的对象释放等都属于内存泄露现象。内存泄露将导致主机的内存随着程序的运行而逐渐减少，无论其表现形式怎样，它的危害是很大的，因此我们需要努力地避免。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"大对象的分配 NET中所有的大对象（这里主要是指对象的大小超过指定数值[85000字节]）将分配在托管堆内一个特殊的区域内，暂且将其称为“大对象堆”（这也算是CLR对于GC的一个优化策略）。大对象堆中最重要的一个特点就是：没有代级的概念，所有对象都被视为第2代。在回收大对象堆内的对象时，其他的大对象不会被移动，这是考虑到大规模地移动对象需要耗费过多的资源。这样，在程序过多地分配和释放大对象之后，就会产生很多内存碎片。 随着对象的分配和释放不断进行，在不进行对象移动的大对象堆内，将不可避免地产生小的内存碎片。我们所需要做的就是尽量减少大对象的分配次数，尤其是那些作为局部变量的，将被大规模分配和释放的大对象，典型的例子就是String类型。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:1","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"不恰当地保存根引用 最简单的一个错误例子就是不恰当地把一个对象申明为公共静态变量，一个公共的静态变量将一直被GC视为一个在使用的根引用。更糟糕的是：当这个对象内部还包含更多的对象引用时，这些对象同样不会被释放。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:2","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"不正确的Finalize方法 不正确的Finalize方法将导致Finalize方法不能被正确执行。如果系统中所有的Finalize方法不能被正确执行，包含它们的对象也只能驻留在托管堆内不能被释放，这样的情况将会导致严重的后果。 Finalize方法应该只致力于快速而简单地释放非托管资源，并且尽可能快地返回。相反，不正确的Finalize方法则可能包含： 1. 没有保护地写文件日志； 2. 访问数据库； 3. 访问网络； 4. 把当前对象赋给某个存活的引用； 例如，当Finalize方法试图访问文件系统、数据库或者网络时，将会有资源争用和等待的潜在危险。试想一个不断尝试访问离线数据库的Finalize方法，将会在长时间内不会返回，这不仅影响了对象的释放，也使得排在Finalize方法队列中的所有后续对象得不到释放，这个连锁反应将会导致很快地造成内存耗尽。此外，如果在Finalize方法中把对象自身又赋给了另外一个存活的引用，这时对象内的一部分资源已经被释放掉了，而另外一部分还没有，当这样一个对象被激活后，将导致不可预知的后果。 作者：周旭龙 出处：http://edisonchou.cnblogs.com 本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:3","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["数据与算法"],"content":" 这个篇文章主要是算法学习大纲。 主要参考 https://github.com/youngyangyang04/leetcode-master 的学习路线，标号||均为leetcode题号。 算法 数组 二分查找 搜索插入位置|35| 双指针 移除元素|27| 滑动窗口 长度最小的子数组|209| 链表 链表的理论 链表的种类 链表的存储方式 链表操作 数组和链表在不同场景下的性能分析 链表的经典题目 虚拟头节点(哨兵节点) 链表的基本操作 反转链表 环形链表 哈希表 哈希表介绍 哈希函数 哈希碰撞 常见的三种哈希结构 数组作为哈希表 set作为哈希表 map作为哈希表 字符串 什么是字符串 要不要使用库函数 双指针法、反转系列 KMP 栈和队列 栈与队列的理论基础 栈经典题目 栈在系统中的应用 括号匹配问题 字符串去重问题 逆波兰表达式问题 队列的经典题目 滑动窗口最大值问题 求前 K 个高频元素 二叉树 二叉树的遍历方式 前序遍历|144| 中序遍历|145| 后序遍历|94| 层级遍历|102| 二叉树的属性 对称二叉树|101| 二叉树最大深度|104| 二叉树最小深度|111| 完全二叉树的节点个数|222| 平衡二叉树|110| 二叉树的所有路径|157| 左叶子之和|404| 找树左下角的值|513| 路径总和|112| 二叉树的修改与构造 翻转二叉树|226| 从中序与后续遍历序列构造二叉树|106| 最大二叉树|654| 合并二叉树|617| 求二叉搜索树的属性 二叉搜索树中的搜索|700| 验证二叉搜索树|98| 二叉搜索树的最小绝对差|530| 二叉搜索树中的众数|501| 把二叉搜索树转换为累加树|538| 二叉树公共祖先问题 二叉树的最近公共祖先|236| 二叉搜索树的最近公共祖先|235| 二叉搜索树的修改和构造 二叉搜索树的插入操作|701| 删除二叉搜索树的节点|450| 修剪二叉搜索树|669| 将有序数组转换为二叉搜索树|108| 回溯算法 组合 组合|77| 电话号码的字母组合|17| 组合总和|39| 组合总和2|40| 组合总和3|216| 分割 分割回文串|131| 复原IP地址|93| 子集 子集|78| 子集2|90| 排列 全排列|46| 全排列2|47| 棋盘问题 N皇后|51| 解数独|37| 其他 递增子序列|491| 重新安排行程|332| 贪心算法 理论基础 简单题目 分发饼干|455| K次取反后最大化的数组和|1005| 柠檬水找零|860| 序列问题 摆动序列|376| 单调递增的数字|738| 股票问题 买卖股票的最佳时机|122| 买卖股票的最佳时机含手续费|714| 两个维度权衡问题 分发糖果|135| 根据身高重建队列|406| 区间问题 跳跃游戏|55| 跳跃游戏2|45| 用最少数量的箭引爆气球|452| 五重叠区间|435| 划分字母区间|763| 合并区间|56| 其他问题 最大子序和|53| 加油站|134| 监控二叉树|968| 动态规划 算法 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:0:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"数组 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:1:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二分查找 搜索插入位置|35| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:1:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"双指针 移除元素|27| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:1:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"滑动窗口 长度最小的子数组|209| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:1:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"链表 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:2:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"链表的理论 链表的种类 单链表、双链表、循环链表 链表的存储方式 数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 链表操作 添加、删除、查询 数组和链表在不同场景下的性能分析 插入删除的时间复杂度是O(1),查询的时间复杂度是O(n) ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:2:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"链表的经典题目 虚拟头节点(哨兵节点) 移除链表元素|203| 链表的基本操作 设计链表|707| 反转链表 反转链表|206| 环形链表 环形链表II|142| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:2:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"哈希表 哈希表 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"哈希表介绍 哈希表是根据关键码的值而直接进行访问的数据结构。 哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"哈希函数 通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把value映射为哈希表上的索引数字了。 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"哈希碰撞 拉链法、线性探测法。 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"常见的三种哈希结构 数组、set（集合）、map（映射） 数组作为哈希表 有效的字母异位词|242| 赎金信|383| set作为哈希表 两个数组的交集|349| map作为哈希表 两数之和|1| 三数之和|15| 四数之和|18| 四数相加II|454| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"字符串 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"什么是字符串 字符串是若干字符组成的有限序列，也可以理解为是一个字符数组 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"要不要使用库函数 反转字符串|344| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"双指针法、反转系列 反转字符串II|541| 剑指Offer 05.替换空格 翻转字符串里的单词|151| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"KMP 实现 strStr()|28| 重复的子字符串|459| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"栈和队列 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:5:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"栈与队列的理论基础 队列是先进先出，栈是先进后出 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:5:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"栈经典题目 栈在系统中的应用 简化路径|71| 括号匹配问题 有效的括号|20| 字符串去重问题 删除字符串中的所有相邻重复项|1047| 逆波兰表达式问题 逆波兰表达式求值|150| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:5:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"队列的经典题目 滑动窗口最大值问题 滑动窗口最大值|239| 求前 K 个高频元素 前 K 个高频元素|347| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:5:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树的遍历方式 前序遍历|144| 中序遍历|145| 后序遍历|94| 层级遍历|102| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树的属性 对称二叉树|101| 二叉树最大深度|104| 二叉树最小深度|111| 完全二叉树的节点个数|222| 平衡二叉树|110| 二叉树的所有路径|157| 左叶子之和|404| 找树左下角的值|513| 路径总和|112| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树的修改与构造 翻转二叉树|226| 从中序与后续遍历序列构造二叉树|106| 最大二叉树|654| 合并二叉树|617| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"求二叉搜索树的属性 二叉搜索树中的搜索|700| 验证二叉搜索树|98| 二叉搜索树的最小绝对差|530| 二叉搜索树中的众数|501| 把二叉搜索树转换为累加树|538| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树公共祖先问题 二叉树的最近公共祖先|236| 二叉搜索树的最近公共祖先|235| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:5","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉搜索树的修改和构造 二叉搜索树的插入操作|701| 删除二叉搜索树的节点|450| 修剪二叉搜索树|669| 将有序数组转换为二叉搜索树|108| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:6","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"回溯算法 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"组合 组合|77| 电话号码的字母组合|17| 组合总和|39| 组合总和2|40| 组合总和3|216| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"分割 分割回文串|131| 复原IP地址|93| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"子集 子集|78| 子集2|90| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"排列 全排列|46| 全排列2|47| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"棋盘问题 N皇后|51| 解数独|37| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:5","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"其他 递增子序列|491| 重新安排行程|332| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:6","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"贪心算法 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"理论基础 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"简单题目 分发饼干|455| K次取反后最大化的数组和|1005| 柠檬水找零|860| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"序列问题 摆动序列|376| 单调递增的数字|738| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"股票问题 买卖股票的最佳时机|122| 买卖股票的最佳时机含手续费|714| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"两个维度权衡问题 分发糖果|135| 根据身高重建队列|406| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:5","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"区间问题 跳跃游戏|55| 跳跃游戏2|45| 用最少数量的箭引爆气球|452| 五重叠区间|435| 划分字母区间|763| 合并区间|56| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:6","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"其他问题 最大子序和|53| 加油站|134| 监控二叉树|968| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:7","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"动态规划 Written with StackEdit. ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:9:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["概要"],"content":" 个人技术蓝图 计算机基础 [the-basics-of-computer-science] 计算机的组成原理 [principles-of-computer-composition] 操作系统原理 [principle-operating-system] 编译原理 [principle-of-compiling] 数据库系统 [database-system] 计算机网络 [network-of-computer] TCP HTTP 语言与平台 [language-and-platform] C# \u0026 .NET 5 [chsarp-and-dotnet5] .NET 本质论 [dotnet-essentialism] C# 基础语法 [csharp-basic-syntax] C# 高级用法 [professional-csharp] 新一代的 .NET [new-generation-dotnet] Swift \u0026 IOS [swift-ios] Python [python] Python 基础语法 [python-basic-syntax] Python 高级语法 [professional-python] Python 的应用 [python-application] JS,ES,TS \u0026 Vue,React (Gatsby) [js-es-ts-vue-react] 前端框架 [front-end] JavaScript [js] 数据与算法[data-and-algorithmic] 数据结构 [data-structure] 常用算法 [algorithm] 重构 [refactoring] 软件工程 [software-engineering] 开发方法 [software-development-methodologies] 系统分析与设计 [system-analysis-and-design] 软件开发的生命周期 [software-development-lifecycle] 架构艺术 [architecture-art] 架构模式 [architecture-pattern] 设计模式 [design-pattern] 常用组件 [common-components] Redis [redis] RabbitMQ [rabbitmq] Elastic Search [elastic-search] 云上漫谈 [cloud-native] 基础架构篇 [cloud-infrastructure] 软件架构篇 [cloud-software-architecture] DEVOPS [devops] 个人技术蓝图 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:0:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"计算机基础 [the-basics-of-computer-science] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"计算机的组成原理 [principles-of-computer-composition] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"操作系统原理 [principle-operating-system] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"编译原理 [principle-of-compiling] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"数据库系统 [database-system] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:4","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"计算机网络 [network-of-computer] TCP HTTP ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:5","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"语言与平台 [language-and-platform] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"C# \u0026 .NET 5 [chsarp-and-dotnet5] .NET 本质论 [dotnet-essentialism] dotnet-essentialism C# 基础语法 [csharp-basic-syntax] C# 高级用法 [professional-csharp] 新一代的 .NET [new-generation-dotnet] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"Swift \u0026 IOS [swift-ios] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"Python [python] Python 基础语法 [python-basic-syntax] python-learning-notes python-learning-intermediate-notes Python 高级语法 [professional-python] python-quick-grammar Python 的应用 [python-application] jupyter-notebook-shortcuts ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"JS,ES,TS \u0026 Vue,React (Gatsby) [js-es-ts-vue-react] 前端框架 [front-end] Gatsby JavaScript [js] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:4","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"数据与算法[data-and-algorithmic] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"数据结构 [data-structure] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"常用算法 [algorithm] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"重构 [refactoring] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"软件工程 [software-engineering] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"开发方法 [software-development-methodologies] software-development-methodologies ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"系统分析与设计 [system-analysis-and-design] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"软件开发的生命周期 [software-development-lifecycle] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"架构艺术 [architecture-art] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"架构模式 [architecture-pattern] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"设计模式 [design-pattern] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"常用组件 [common-components] Redis [redis] [转载]Redis面试题 RabbitMQ [rabbitmq] [转载][转载]消息中间件MQ与RabbitMQ面试题 Elastic Search [elastic-search] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"云上漫谈 [cloud-native] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"基础架构篇 [cloud-infrastructure] introduce-microservice-infrastructure-on-cloud how-to-setup-kubernetes-on-azure ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"软件架构篇 [cloud-software-architecture] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"DEVOPS [devops] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["软件工程"],"content":" Software Development Methodologies ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:0:0","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"开发方法 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:0","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"软件的生命周期 可行性研究与计划-\u003e需求分析-\u003e概要设计-\u003e详细设计-\u003e实现-\u003e集成测试-\u003e确认测试-\u003e使用与维护 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:1","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"软件开发模型 瀑布模型 演化模型 螺旋模型 增量模型 构建组装模型 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:2","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"统一过程 UP的9个核心工作流 业务建模，需求，分析设计，实施，测试，部署，配置与变更管理，项目管理，环境 UP的生命周期 目标里程碑，架构里程碑，能力里程碑，发布里程碑 UP的特点 UP不但给出类迭代的生命周期，还给出了生命周期每一阶段的迭代指南 采用不同迭代方式的UP可以演变为演化模型或增量模型 迭代特点使得更容易控制软件开发的风险 UP本身并不属于敏捷 实际应用中可以根据具体问题对UP进行剪裁 架构师在UP中的活动 同需求人员和项目管理人员密切协作 细化软件架构 保持整个架构的概念完整性 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:3","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"敏捷方法 极限编程 XP是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方式。 在更短的周期内，更早的提供具体、持续的反馈信息 迭代的进行计划编制 依赖自动测试程序来监控开发进度，并及早捕获缺陷 依赖口头交流、测试和源程序进行沟通 倡导持续的、演化式的设计 依赖与开发团队内部的紧密协作 尽可能达到程序员短期利益和项目长期利益的平衡 四大价值观 沟通，简单，反馈，勇气，（尊重） 十二个最佳实践 计划游戏，小型发布，隐喻，简单设计，测试先行，重构，结对编程，集体代码所有制，持续集成，每周工作40小时，现场客户，编码标准 特性驱动开发 FDD也是一个迭代开发模型，FDD每一步都强调质量，不断的交付可运行的软件，并以很小的开发提供精准的项目进度报告和状态信息。 FDD角色定义 项目经理，首席架构设计师，开发经理，主程序员，程序员，领域专家 核心过程 开发整体对象模型、构造特征列表、计划特征开发、特征设计、特征构建 最佳实践 领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管 Scrum Scrum是一个用于开发和维护复杂产品的框架，是一个增量的、迭代的开发过程。 Scrum 的五个活动 产品待办事项列表梳理、Sprint计划会议、每日Scrum会议、Sprint评审会议、Sprint回顾会议 Scrum的5大价值观 承诺、专注、开放、尊重、勇气 水晶方法 Crystal 是发展一种提倡“机动性“的方法，包括共有的核心元素，每个都含有独特的角色，过程模式，工作产品和实践。 7大体系特征：经常交付，反思改进，渗透式交流，个人安全，焦点，与专家用户建立方便的联系，配有自动测试、配置管理和经常集成功能的技术环境 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:4","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"软件重用 软件重用 源代码重用，架构重用，应用框架重用，业务建模重用，文档及过程的重用，软构件重用，软件服务重用 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:5","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"基于架构的软件设计 ABSD方法于生命周期 ABSD：分解功能，通过选择架构风格来事先质量和业务需求，软件模版的使用 抽象功能需求，包括变化的需求和通用的需求 用例（实际功能需求） 抽象的质量和业务需求 架构选项 质量场景 约束 基于架构的软件开发模型(ABSDM) 架构需求 需求获取，标识构件（生成类图，对类分组，打包构件），需求评审 架构设计 提出软件架构模型，把已标识的构件映射到软件架构中，分析构件的互相作用，产生软件架构，设计评审 架构文档化 输出：架构需求规格说明，测试架构需求的质量设计说明 架构复审 架构实现 架构演化 需求变动归类，制定架构演化计划，修改、增加或删除构件，更新构件的互相作用，构件组装与测试，技术评审 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:6","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["语言与平台"],"content":"Python Quick Grammar ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:0","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"1. 变量互换 a=1 b=2 a,b=b,a a,b (2, 1) ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:1","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"2. 连续赋值 a=b=c=50 a,b,c (50, 50, 50) ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:2","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"3. 自动解包 a,b,c=[1,2,3] a,b,c (1, 2, 3) a,*others=[1,2,3,4] print(a) print(*others) 1 2 3 4 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:3","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"4. 链式比较 a=10 if(5\u003ca\u003c15): print(a) 10 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:4","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"5. 重复列表 [5,2]*4 [5, 2, 5, 2, 5, 2, 5, 2] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:5","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"6. 重复字符串 \"hello\"*3 'hellohellohello' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:6","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"7. 三目运算 age = 30 slogon = \"牛逼\" if age == 30 else \"niubility\" print(slogon) 牛逼 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:7","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"8. 字典合并 a={\"a\":1} b={\"b\":2} {**a,**b} {'a': 1, 'b': 2} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:8","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"9. 字符串反转 s = \"i love python\" s[::-1] 'nohtyp evol i' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:9","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"10. 列表转字符串 s = [\"i\", \"love\", \"python\"] \" \". join(s) 'i love python' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:10","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"11. for else 语句 foo=[2,3,4,5] for i in foo: if i == 0: break else: print(\"未发现\") 未发现 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:11","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"12. 字典推导式 m = {x: x**2 for x in range(5)} m {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:12","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"13. 用Counter查找列表中出现最多的元素 content = [\"a\", \"b\", \"c\", \"a\", \"d\", \"c\", \"a\"] from collections import Counter c = Counter(content) c. most_common(1) [('a', 3)] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:13","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"14. 默认值字典 from collections import defaultdict d = defaultdict(list) d['a']. append(1) d['a'] [1] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:14","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"15. 赋值表达式 import re data = \"hello123world\" if match:=re. search(\"(\\d+)\", data): num = match. group(1) else: num=None num '123' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:15","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"16. isinstance x=1 b=isinstance(x, (int, float)) b True ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:16","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"17. 用 http.server 共享文件 #python3 -m http. server ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:17","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"18. zip 函数实现字典键值对互换 lang = {\"python\":\". py\", \"java\":\". java\"} dict(zip(lang. values(), lang. keys())) {'. py': 'python', '. java': 'java'} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:18","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"19. 查找列表中出现次数最多的数字 test = [1, 2, 3, 4, 2, 2, 3, 1, 4, 4, 4, 5] max(set(test), key=test. count) 4 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:19","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"20. 使用 slots 节省内存 class MyClass(object): def __init__(self, name, identifier): self. name = name self. identifier = identifier self. set_up() print(sys. getsizeof(MyClass)) class MyClass(object): __slots__ = ['name', 'identifier'] def __init__(self, name, identifier): self. name = name self. identifier = identifier self. set_up() print(sys. getsizeof(MyClass)) 1064 896 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:20","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"21. 扩展列表 i = ['a','b','c'] i. extend(['e','f','g']) i ['a', 'b', 'c', 'e', 'f', 'g'] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:21","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"22. 列表负数索引 a = [ 1, 2, 3] a[-1] 3 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:22","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"23. 列表切片 a = [0,1,2,3,4,5,6,7,8,9] a[3:6] # 第3个到第6个之间的元素 a[:5] # 前5个元素 a[5:] # 后5个元素 a[::] # 所有元素（拷贝列表） a[::2] # 偶数项 a[1::2] # 奇数项 a[::-1] # 反转列表 [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:23","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"24. 二维数组变一维数组 import itertools a = [[1, 2], [3, 4], [5, 6]] i = itertools. chain(*a) list(i) [1, 2, 3, 4, 5, 6] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:24","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"25. 有索引的迭代 a = ['Merry', 'Christmas ', 'Day'] for i, x in enumerate(a): print ('{}: {}'. format(i, x)) 0: Merry 1: Christmas 2: Day ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:25","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"26. 列表推导式 le = [x*2 for x in range(10)] le # 每个数取平方 le = [x for x in range(10) if x%2 == 0] le # 获取偶数项 [0, 2, 4, 6, 8] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:26","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"27. 生成器表达式 ge = (x*2 for x in range(10)) print(ge) print(next(ge)) print(next(ge)) print(next(ge)) \u003cgenerator object \u003cgenexpr\u003e at 0x000001D693764190\u003e 0 2 4 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:27","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"28. 集合推导式 nums = {n**2 for n in range(10)} nums {0, 1, 4, 9, 16, 25, 36, 49, 64, 81} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:28","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"29. 判断key是否存在字典中 d = {\"1\":\"a\"} print('1' in d) print(d['1']) print(d. get(\"1\")) print(d. get(\"2\")) True a a None ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:29","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"30. 装饰器 from functools import wraps def tags(tag_name): def tags_decorator(func): @wraps(func) def func_wrapper(name): return \"\u003c{0}\u003e{1}\u003c/{0}\u003e\". format(tag_name, func(name)) return func_wrapper return tags_decorator @tags(\"p\") def get_text(name): \"\"\"returns some text\"\"\" return \"Hello \" + name print(get_text(\"Python\")) \u003cp\u003eHello Python\u003c/p\u003e ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:30","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"31. 字典子集 def sub_dicts(d, keys): return {k:v for k, v in d. items() if k in keys} sub_dicts({1:\"a\", 2:\"b\", 3:\"c\"}, [1,2]) {1: 'a', 2: 'b'} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:31","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"32. 反转字典 d = {'a': 1, 'b': 2, 'c': 3, 'd': 4} zip(d. values(), d. keys()) z = zip(d. values(), d. keys()) dict(z) {1: 'a', 2: 'b', 3: 'c', 4: 'd'} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:32","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"33. 具名元组 from collections import namedtuple Point = namedtuple(\"Point\", \"x,y\") p = Point(x=1, y=2) print(p. x) print(p[0]) print(p. y) print(p[1]) 1 1 2 2 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:33","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"34. 设置字典默认值 d = dict() if 'a' not in d: d['a'] = [] d['a']. append(1) d d. setdefault('b',[]). append(2) d {'a': [1], 'b': [2]} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:34","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"35. 有序字典 from collections import OrderedDict m = OrderedDict((str(x), x) for x in range(10)) m. keys() # key 按照插入的顺序排列 odict_keys(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']) ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:35","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"36. 列表中最大最小的前n个数 import heapq a = [51, 95, 14, 65, 86, 35, 85, 32, 8, 98] heapq. nlargest(5,a) heapq. nsmallest(5,a) [8, 14, 32, 35, 51] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:36","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"37. 打开文件 import os with open('foo. txt', 'w') as f: f. write(\"hello\") os. remove(\"foo. txt\") ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:37","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"38. 两个列表组合成字典 list_1 = [\"One\",\"Two\",\"Three\"] list_2 = [1,2,3] dictionary = dict(zip(list_1, list_2)) print(dictionary) {'One': 1, 'Two': 2, 'Three': 3} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:38","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"39. 去除列表中重复元素 my_list = [1,4,1,8,2,8,4,5] my_list = list(set(my_list)) print(my_list) [1, 2, 4, 5, 8] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:39","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"40. 打印日历 import calendar print(calendar. month(2021, 1)) January 2021 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:40","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"41. 匿名函数 add = lambda a,b:a+b add(1,2) 3 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:41","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":" Python Learning Notes - Intermediate ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:0:0","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4. 序列 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:0","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.1 序列 1 索引 abc=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] print(abc[1]) 2 切片（slicing） sname[start🔚step] print(abc[1:5]) print(abc[0:5:2]) 3 序列相加 bcd=[\"b\",\"c\",\"d\"] print(abc+bcd) 4 乘法 print(bcd*5) 5 检查元素 print(\"b\" in bcd) 6 计算序列长度、最大值和最小值 print(len(abc)) print(max(abc)) print(min(abc)) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:1","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.2 列表(list) 1 创建和删除 lisa=[1,2,3,4,5,6] lisb=['a',\"b\",[\"a\",'''bcd''']] lise=[] lisr=list(range(1,10,2)) print(lisa,lisb,lise,lisr) del lisr print(lisr) 2 遍历 for i in lisa: print(i) for i,item in enumerate(lisb): print(i,item) 3 添加、修改和删除列表元素 lisa.append(7) print(lisa) lisa[5] = 7 print(lisa) del lisa[5] print(lisa) 4 统计 c=lisa.count(1) print(c) i=lisa.index(1) print(i) s=sum(lisa) print(s) lisa.sort(reverse=True) print(lisa) sort=sorted(lisa) print(sort) k=[x for x in lisa if x\u003e3] print(k) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:2","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.3 元组（tuple） 1 元组的基本操作 t=('a',12,(\"abc\",\"b\"),[\"ggg\",99]) print(t) t=tuple(range(10,20,2)) print(t) t=('人生苦短',28,'我用PYTHON',[123,456,789]) print(t[0]) print(t[:3]) 2 元组推导式 import random randomnumber=(random.randint(10,100) for i in range(10)) print(randomnumber) randomnumber=tuple(randomnumber) print(randomnumber) a=(1,2,3) print(a) a=(2,3,4) print(a) a=a+(5,6) print(a) 遍历后原生成器对象已经不存在了，如下： number=(i for i in range(3)) print(number.__next__()) print(number.__next__()) number=tuple(number) print(number) 元组和列表区别 列表属于可变序列，它的元素可以随时修改或者删除，而元组属于不可变序列，其中元素不可修改，除非整体替换 列表可以使用append(),extend(),insert(),remove()和pop()等方法实现添加和修改列表元素，而元组则没有这几个方法，因为不能向原则添加和修改元素，同样也不能删除元素 列表可以使用切片访问和修改列表中元素，元素也支持切片，但是它只支持通过切片访问元素中的元素，不支持修改 元组比列表的访问和处理速度快，所以如果只需要对其中元素进行访问，而不进行任何修改，建议使用元组而不使用列表 列表不能座位字典的键，而元组则可以 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:3","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.4 字典(dictionary) 字典的特性： 通过键而不是通过索引来读取 字典式任意对象的无序集合 字典是可变的，并且可以任意嵌套 字典中的键必须是唯一 字典中的键必须不可变 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:4","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5. 字符串和正则表达式 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:0","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5.1 字串常用操作 # 拼接 a='abc'+'bc'+'CD'+str(123)+'@' print(a) # 计算长度 print(len(a)) # 截取字符串【string[start🔚step]】 sub=a[2:7:2] print(sub) # 分割字符串【str.splite(sep,maxsplit)】 li=a.split('b') print(li) li=a.split('b',1) print(li) # 检索字符串count find index startswith endswith print(a.count('b')) print(a.find('b')) print(a.index('b')) print(a.startswith('abc')) print(a.endswith('123')) # 字母大小写 print(a.upper()) print(a.lower()) # 去特殊字符 print(a.strip('@')) 格式化字符串 常用格式化字符 s 字符串（采用str() 显示） r 字符串（采用repr() 显示） c 单个字符串 o 八进制整数 d 十进制整数 e 指数 x 十六进制整数 f 浮点数 % 字符串% template= '{:0\u003e9s}\\tname:{:s}\\ttitle:sr.{:s}' print(template.format('1','hello','wang')) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:1","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5.2 正则表达式基础 行定位符 ^tm$ 元字符 \\w\\s\\d\\b 限定符 ? + * {n} {n,} {n,m} 字符类 abc 排除字符 ^abc 选择字符 | 转义字符 \\ 分组 () ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:2","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5.3 使用re模块实现正则表达式 # re.match(pattern.string,[flags]) # re.search(pattern,string,[flags]) # re.findall(pattern,string,[flags]) # re.sub(pattern,repl.string,count,flags) # re.split(pattern,string,[maxsplite],[flags]) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:3","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["软件工程"],"content":" Scrum Learning Notes Scrum 学习笔记 理论与价值观 敏捷宣言 5 个价值观 8 大价值观 12 个原则 3 个角色 3 个工件 5 个活动 估算与计划 计划失败的原因 估算大小的策略 为价值制定计划 确定优先级因素 确定渴望度优先级 分解用户故事 用户故事的六个特性 - INVEST 确定经济优先级 会议与实战 Product Bocklog Refinement 框架 Skeleton 备忘录 Cheat Sheet Sprint Planning PART I PART II Spint Review 框架 Sprint Retrospective 发布计划策略 迭代计划策略 估算速度策略 有效原因与指导原则 敏捷计划有效原因 敏捷估算和计划的 12 条指导原则 Scrum 学习笔记 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:0:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"理论与价值观 在有限的时间（TimeBox）里 团队一起合作（Work Together），我们彼此信任（Trust）并发挥自我最大的能力和优势（Do The Best），持续不断的交付（CI，CD）可用、有价值（Usable，Valuable）的软件，赢得客户的满意。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"敏捷宣言 个体和互动 高于 流程和工具 （合作，信赖） 工作的软件 高于 详尽的文档 （产品增量） 客户合作 高于 合同谈判（同一组织） 响应变化 高于 遵循计划（公开，透明） ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"5 个价值观 专注 - 由于我们在一段时间内只能专注于少数几件事情，所以我们可以很好的合作并获得优质的产出，我们能够更快的交付有价值的事项。 公开 - 在团队合作中大家都会表达我们做的如何，以及遇到的障碍。我们发现将担忧说出来是一件好事，因为只有这样才能让这些担忧及时得到解决。 尊重 - 因为我们在一起工作，分享和成功失败，这有助培养并加深互相之间的尊重，并帮助彼此成为值得尊重的人。 承诺 - 由于对自己的命运有更大的掌控，我们会有更坚定的信念去获得成功。 勇气 - 因为我们不是单打独斗，我们能够感受到支持，而且掌握更多资源。这一切赋予我们勇气去迎接更大的挑战。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"8 大价值观 诚实，开放，勇气，尊重，专注，信任，授权，合作 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:3","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"12 个原则 我们最重要的目标，是通过及早和持续不断地交付有价值的软件使客户满意。 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。 业务人员和开发人员必须相互合作，项目中的每一天都不例外。 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。 可工作的软件是进度的首要度量标准。 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。(稳定的速度) 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。 以简洁为本，它是极力减少不必要工作量的艺术。 最好的架构、需求和设计出自自组织团队。 团队定期地反思如何能提高成效，并依此调整自身的行为表现。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:4","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"3 个角色 PO Scurm Master Team ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:5","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"3 个工件 Product Backlog Sprint Backlog Burndown chart ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:6","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"5 个活动 产品待办事项列表梳理 Sprint 计划 每⽇ Scrum 站会 Sprint 评审 Sprint 回顾 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:7","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"估算与计划 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"计划失败的原因 基于活动而不是基于特性 活动不会提前完成 延误沿着计划表向下传递 活动不是互相独立的 基于活动的计划分散了我们对特性的专注，而特性才是衡量客户价值的单元。解决策略：使用 FDD 策略。 多任务处理导致更多的延迟 - 每个人都达到 100%负荷，这和让高速公路保持 100%负荷结果相同，谁都无法取得任何进展。解决策略：专注 feature，合理估算 不按优先级开发特性 - 传统计划假设所有任务都会完成，但这样会造成如果无法完成会舍弃一些特性，而这些特性可能会比交付的更有价值。解决策略：明确优先级。 忽视不确定性 - 最明显的效果就是造成 delay。 解决策略：迭代。 把估算当作承诺 - 估算只是一个可能性，而对一个可能性做出承诺是不可能的。解决策略：对特性承诺而非时间。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"估算大小的策略 故事点的优势 故事点有助于驱动跨功能行为 故事点估算不会过期 故事点是纯粹对大小进行度量 故事点估算通常更快 我的理想人天不等于你的理想人天 理想人天 理想人天在团队以外更容易解释 理想人天估算更容易开始 理想人天便于预测速度 使用模糊的故事点产生的不舒服感觉是非常短暂的。 公司让实际人天接近于理想人天的压力会带来负面影响。 使用故事点估算更有说服力。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"为价值制定计划 确定优先级因素 价值 估算经济回报是一件很困难的工作，常常需要一种替代方案对价值估算 ** 确定渴望度的优先级 成本 确定经济优先级 新知识 关于产品的知识 关于技术的知识 风险 进度风险 成本风险 功能风险 确定渴望度优先级 客户满意度的 Kano 模型 作为阈值的特性 线性特性 兴奋点和惊喜点 Kano 模型 5 个度量点: 我希望这样; 我预期就是这样; 我没有意见; 我可以忍受这样; 我不希望这样; ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:3","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"分解用户故事 用户故事的六个特性 - INVEST 独立性 Independent、可协商性 Negotiable、有价值 Valuable、可以估算 Estimable、短小 Small、可测试性 Testable 何时分解用户故事 用户故事太大，不能放进单次迭代的时候 大型故事分解有助于作出更准确的估算 按照数据边界分解 按照用户故事所支持数据的边界来分解大型用户故事 按照操作边界分解 CURD 去除横切考虑 例如：日志 忽略满足性能限制 考虑把功能性和非功能性需求隔离到不同的用户故事，从而分解大型用户故事 分解具有混合优先级的用户故事 如果大型用户故事中的小故事具有不同的优先级，则可以对它们进行分解 不要把故事分解成任务 不要把大型用户分解成任务，而是寻找一种方法来让一颗曳光弹穿过整个故事 避免相关变化的诱惑 避免在具有适当大小的特性中增加相关变化而把事情弄糟，除非这些变化具有相同的优先级 组合用户故事 对于2周一次的迭代周期工作的团队来说，合适的做法是把特性分解成 2-5 天的用户故事 组合小故事 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:4","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"确定经济优先级 收入来源 新收入 增量收入 促进现有客户购买更多许可 包含了可以独立出售的可选，附加模块 包含允许提高收费的功能 促进对咨询服务的使用 留存收入 如果不开发项目或主题，公司会损失的收入 操作效率 需要或者在公司成长后需要很长时间的事 部门之间更好的集成和交流 减少人员更替 对新人缩短培训时间 任何对时间敏感的过程 综合多个过程 任何可以提高准确性和减少返工的工作 经济指标 1 金钱的时间价值 2 净现值 NPV 3 内部收益率 4 投资回收期 5 折现回收期 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:5","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"会议与实战 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Product Bocklog Refinement 框架 Skeleton 展示现阶段以及中期目标 展示并澄清 Product Backlog 团队估算 PBI PO 按照期望团队交付的顺序为 PBI 排序 分成小组协作对需求建模，切分以及确定验收条件 备忘录 Cheat Sheet 梳理之前是否与利益相关者一起评估确认远景、目标和 backlog 条目 团队和主要的利益相关者在场 会议由 ScurmMaster 或者 PO 引导 预留 sprint 总时间的 5%-10%梳理 backlog PO 把远景、目标和整个 backlog 分享给大家 技术风险是否被确认并创建响应的 spike Product Backlog 是一个有序列表 把所有的反馈、变更、缺陷记录到 Product Backlog 产品 Backlog 包括现景、近景和远景 团队一起对所有的条目估算 排列靠前的条目都有验收条件而且有具体实例 所有不确定的问题被记录下来等待会后继续调研 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Sprint Planning PART I 展示重要的 PBI 澄清 PBI 相关的问题 团队协作梳理新的 PBI 团队按照顺序尝试选择 PBI PART II 重新调整“完成的定义” 计算团队下个 Sprint 可用时间 团队一起讨论可能的实现方案 团队协作创建任务并估算 根据时间或速率向 PO 做出最终承诺 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Spint Review 框架 评估已经完成的 PBI 与承诺的 PBI 和 Sprint 目标 用讲故事的方式演示完成的功能 收集反馈 展示接下来要做的重要 PBI ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:3","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Sprint Retrospective 安全感 How much will each person participate 发现 Big Picture 分析 Continue; Fix; Stop; 计划 Where dowe want to be? How do we get there from here? 收尾 How to ducument; How to execute; ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:4","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"发布计划策略 确定满意条件，（日期驱动，特性驱动） 估算用户故事， 选择迭代周期长度，（官方建议：2 周迭代，压力分摊，6x2+1） 估算速度，（速度策略） 确定用户故事的优先级， 选择用户故事和发布时间 确定最初 1-3 个迭代的具体工作 卡片记录 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:5","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"迭代计划策略 速度驱动的迭代计划（客观） 调整优先级 确定目标速度 确定迭代目标 选择用户故事 把用户故事分解成任务 只包含此项目增加价值的工作 - 如“回复邮件 1 小时”。 尽量明确，直到养成习惯 - 如自动化测试培养。 会议会占据（很多）时间（整体时间：如开会）。 缺陷- 发现 bug 的迭代中就修复它们。 处理依赖性 - 如 mock 数据 难以分解的工作 - 探针策略 对任务进行估算 一部分设计就够了 任务的适合大小 承诺驱动的迭代计划（主观） 要求团队做出承诺(团队主导，承诺特性非任务)“你们可以承诺交付我们已经讨论过的特性么？” 对估算值求和 -实际上大多数团队在计划每天 4-6 个小时的工作量时候能够取得成功 维护与承诺 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:6","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"估算速度策略 如果你在给出对速度的估算前可以进行一次或多测迭代， ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:7","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"有效原因与指导原则 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:4:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"敏捷计划有效原因 经常重新计划 承认不可能建立完美的计划，可以大量减少焦虑，而且可以逐步的消除这种不精确性。 对大小和持续时间的估算时独立的 大小和时间时有关系统的，但很多因素也会影响持续时间。 故事点来估算大小，接下来估算速度，然后规模和速度估算结合起来就可以得到持续时间 在不同层次制定计划 发布计划，迭代计划，每日计划。1.不同的计划是用于不同的目的事实。2.帮助开发团队从不同的角度来看待项目。 基于特性而不是基于任务制定计划 团队可以少做一些关于特定任务的预先考量。让团队思考正在开发的特性。 小故事保持工作流畅 每个迭代都要消除未完成的工作 在团队层次跟踪 不要准备个人燃尽图**而只绘制团队层次的燃尽图 承认不确定性并为之计划 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:4:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"敏捷估算和计划的 12 条指导原则 让整个团队参与 在不同层次上进行计划 使用不同度量单位，让对大小和持续时间的估算保持独立 用功能或者日期来体现不确定性 经常重新计划 跟踪进度并沟通 承认学习的重要性 计划具有适当大小的特性 确定特性优先级 最好的估算和计划来源于事实 保留一些松弛度 通过前瞻性计划协调多个团队 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:4:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["语言与平台"],"content":" Jupyter Notebook Shortcuts ","date":"2020-06-04","objectID":"https://blog.gethin.online/jupyter-notebook-shortcuts/:0:0","tags":["python"],"title":"JUPYTER NOTEBOOK SHORTCUTS","uri":"https://blog.gethin.online/jupyter-notebook-shortcuts/"},{"categories":["语言与平台"],"content":"Command model Key Function 作用 Enter take you into edit mode 转入编辑模式 Shift-Enter run the current cell, select below 运行本单元，选中下个单元 Ctrl-Enter run selected cells 运行本单元 Alt-Enter run the current cell, insert below 运行本单元，在其下插入新单元 Y change the cell type to Code 单元转入代码状态 M change the cell type to Markdown 单元转入 markdown 状态 R change the cell type to Raw 单元转入 raw 状态 1 set level 1 title 设定 1 级标题-仅在 markdown 状态下 2 set level 2 title 设定 2 级标题 3 set level 3 title 设定 3 级标题 4 set level 4 title 设定 4 级标题 5 set level 5 title 设定 5 级标题 6 set level 6 title 设定 6 级标题 Up select cell above 选中上方单元 K select cell above 选中上方单元 Down select cell below 选中下方单元 J select cell above 选中下方单元 Shift-K Move selected cells up 连续选择上方单元 Shift-J Move selected cells down 连续选择下方单元 A insert cell above 在上方插入新单元 B insert cell below 在下方插入新单元 X cut selected cells 剪切选中的单元 C copy selected cells 复制选中的单元 Shift-V paste cells above 粘贴到上方单元 V paste cells below 粘贴到下方单元 Z undo cell deletion 恢复删除的最后一个单元 D,D delete selected cells 删除选中的单元 Shift-M merge cell below 合并选中的单元 Ctrl-S save and checkpoint 保存当前 NoteBook S Save and Checkpoint 保存当前 NoteBook L toggle line numbers 开关行号 O toggle output 转换输出 Shift-O toggle output scrolling 转换输出滚动 Esc close pager 关闭页面 Q close pager 关闭页面 H show all shortcuts 显示快捷键帮助 Shift-Space scroll notebook up 向上滚动 Space scroll notebook down 向下滚动 ","date":"2020-06-04","objectID":"https://blog.gethin.online/jupyter-notebook-shortcuts/:1:0","tags":["python"],"title":"JUPYTER NOTEBOOK SHORTCUTS","uri":"https://blog.gethin.online/jupyter-notebook-shortcuts/"},{"categories":["语言与平台"],"content":"Edit Mode Key Function 作用 Tab code completion or indent 代码补全或缩进 Shift-Tab tooltip 提示 Ctrl-] indent 缩进 Ctrl-[ dedent 解除缩进 Ctrl-A select all 全选 Ctrl-Z undo 撤销 Ctrl-Shift-Z redo 重做 Ctrl-Y redo 重做 Ctrl-Home go to cell start 跳到单元开头 Ctrl-Up go to cell start 跳到单元开头 Ctrl-End go to cell end 跳到单元末尾 Ctrl-Down go to cell end 跳到单元末尾 Ctrl-Left go one word left 跳到左边一个字首 Ctrl-Right go one word right 跳到右边一个字首 Ctrl-Backspace delete word before 删除前面一个字 Ctrl-Delete delete word after 删除后面一个字 Esc command mode 切换到命令模式 Ctrl-M command mode 切换到命令模式 Shift-Enter run cell, select below 运行本单元，选中下一单元 Ctrl-Enter run cell 运行本单元 Alt-Enter run cell, insert below 运行本单元，在下面插入一单元 Ctrl-Shift- - split cell 分割单元 Ctrl-Shift-Subtract split cell 分割单元 Ctrl-S Save and Checkpoint 保存当前 NoteBook Up move cursor up or previous cell 光标上移或转入上一单元 Down move cursor down or next cell 光标下移或转入下一单元 Ctrl-/ toggle comment on current or selected lines 注释整行/撤销注释 Written with StackEdit. ","date":"2020-06-04","objectID":"https://blog.gethin.online/jupyter-notebook-shortcuts/:2:0","tags":["python"],"title":"JUPYTER NOTEBOOK SHORTCUTS","uri":"https://blog.gethin.online/jupyter-notebook-shortcuts/"},{"categories":["语言与平台"],"content":" Python Learning Notes - Junior ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:0:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1. python 入门 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.1. 注释 单行注释 # 注释内容 多行注释 \"\"\"注释内容\"\"\" 中文编码声明注释 # coding=utf-8 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:1","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.2. 代码缩进 采用代码缩进和冒号“：”区分代码之间的层次，python 对代码缩进非常严格，如果不合理缩进会抛出 SyntaxError 异常。 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:2","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.3. 代码规范 1.3.1. 编写规范 每个 import 只导入一个模块 不要再行尾添加分号“；” 仅以每行不超过 80 个字符；如果超过，仅以使用小括号“（）” 使用必要的空行可以提高代码可读性 通常情况下，运算符两侧、函数参数之间、逗号“，”两侧建议使用空格进行分隔 应该避免在循环中使用+和+=运算符累加字符串，推荐做法是将每个字符串加入列表，然后再循环结束后使用 join 方法连接列表。 适当的使用一场处理提高程序容错性 1.3.2. 命名规范 模块名尽量短小，并且全部使用小写字母，可以使用下划线分割多个字母 如：game_main 包名尽量短小，并且全部使用小写字母，不推荐使用下划线，如：com.cr 类名采用单词首字母大写形式，即 Pascal 风格 如：TakeSomething 模块内部的类采用下划线+Pascal 风格的类名组成 如：_TakeSomething 函数、类的属性和方法的命名规则同模块类似，也是全部采用小写字母，多个字母间用下划线_进行分割 常量明明时全部采用大写字母，可以使用下划线 使用单下划线_开头的模块变量或者函数是受保护的，在使用 import * from 语句从模块中导入时这些变量或者函数不能导入 使用双下划线__开头的实例变量或者方法时类私有的 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:3","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.4. 基本输出 使用 print() 函数输出 使用 input() 函数输入 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:4","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2. 变量和数据类型 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.1. 保留字 Python 保留字: and, as, assert, break, class, continue, def, del, elif, else, except, finally, for, form, False, global, if, import, in, is, lambda, nonlocal, not, None, or, pass, raise, return, try, True, while, with, yield ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:1","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.2. 标识符 标识符命名规则：数字，字母，下划线，不能使用保留字 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:2","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.3. 变量 在 python 中，不需要先声明变量名及其类型，直接赋值即可创建各种类型变量。 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:3","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.4. 基本数据类型 2.4.1.数字类型 整数 十进制 八进制 - 必须以 0o/0O 开头 十六进制 - 必须以 0X/0x 开头 二进制 浮点数 复数 2.4.2. 字符串类型 通常使用‘’，“”，‘“’”。单引号双引号必须再一行，三引号可以分布在多行。 转义符：\\（续行符）,\\n（换行符）,\\0（空）,\\t（水平制表符）,\"（双引号）,'（单引号）,\\（一个反斜杠）,\\f（换页）,\\0dd（八进制数，dd 表示字符）,\\xhh（十六进制数，hh 表示字符） 布尔类型 类型转换 int(x) | float(x) | complex(real [,imag]) | str(x) | repr(x) | eval(str) | chr(x) | ord(x) | hex(x) | oct(x) ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:4","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.5. 运算符 2.5.1 数字运算符 +,-,*,/,%(余),//(取整除),**(幂) 2.5.2 赋值运算符 =,+=,-=,*=,/=,%=,//=,**= 2.5.3 比较运算符 \u003e,\u003c,==,!=,\u003e=,\u003c= 2.5.4 逻辑运算符 and,or,not 2.5.5 位运算符 \u0026,|,^,~,\u003c\u003c,\u003e\u003e ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:5","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3. 流程控制 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.1 选择语句 if 表达式: 语句块 if 表达式: 语句块 else: 语句块 if 表达式: 语句块 elif 表达式: 语句块 else: 语句块 if 表达式: if 表达式: 语句块 else: 语句块 else: 语句块 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:1","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.2 条件表达式 a=1 b=a if a\u003e0 else -a ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:2","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.3 循环语句 while 表达式: 循环体 for 迭代变量 in 对象: 循环体 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:3","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.4 跳转语句 break,continue ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:4","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.5 pass 空语句 pass 不做任何事 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:5","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["数据与算法"],"content":"海量数据优化 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:0","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"1. 合理使用索引 索引是数据库中重要的数据结构，它的根本目的就是为了提高查询效率。现在大多数的数据库产品都采用 IBM 最先提出的 ISAM 索引结构。索引的使用要恰到好处，其使用原则如下： 在经常进行连接，但是没有指定为外键的列上建立索引，而不经常连接的字段则由优化器自动生成索引。 在频繁进行排序或分组（即进行 group by 或 order by 操作）的列上建立索引。 在条件表达式中经常用到的不同值较多的列上建立检索，在不同值少的列上不要建立索引。比如在雇员表的“性别”列上只有“男”与“女”两个不同值，因此就无必要建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。 如果待排序的列有多个，可以在这些列上建立复合索引（compound index）。 使用系统工具。如 Informix 数据库有一个 tbcheck 工具，可以在可疑的索引上进行检查。在一些数据库服务器上，索引可能失效或者因为频繁操作而使得读取效率降低，如果一个使用索引的查询不明不白地慢下来，可以试着用 tbcheck 工具检查索引的完整性，必要时进行修复。另外，当数据库表更新大量数据后，删除并重建索引可以提高查询速度。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:1","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"2. 避免或简化排序 应当简化或避免对大型表进行重复的排序。当能够利用索引自动以适当的次序产生输出时，优化器就避免了排序的步骤。以下是一些影响因素： 索引中不包括一个或几个待排序的列； group by 或 order by 子句中列的次序与索引的次序不一样； 排序的列来自不同的表。 为了避免不必要的排序，就要正确地增建索引，合理地合并数据库表（尽管有时可能影响表的规范化，但相对于效率的提高是值得的）。如果排序不可避免，那么应当试图简化它，如缩小排序的列的范围等。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:2","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"3. 消除对大型表行数据的顺序存取 在嵌套查询中，对表的顺序存取对查询效率可能产生致命的影响。比如采用顺序存取策略，一个嵌套 3 层的查询，如果每层都查询 1000 行，那么这个查询就要查询 10 亿行数据。避免这种情况的主要方法就是对连接的列进行索引。 例如，两个表：学生表（学号、姓名、年龄……）和选课表（学号、课程号、成绩）。如果两个表要做连接，就要在“学号”这个连接字段上建立索引。 还可以使用并集来避免顺序存取。尽管在所有的检查列上都有索引，但某些形式的 where 子句强迫优化器使用顺序存取。下面的查询将强迫对 orders 表执行顺序操作： SELECT * FROM orders WHERE (customer_num=104 AND order_num\u003e1001) OR order_num=1008 虽然在 customer_num 和 order_num 上建有索引，但是在上面的语句中优化器还是使用顺序存取路径扫描整个表。因为这个语句要检索的是分离的行的集合，所以应该改为如下语句： SELECT * FROM orders WHERE customer_num=104 AND order_num\u003e1001 UNION SELECT * FROM orders WHERE order_num=1008 这样就能利用索引路径处理查询。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:3","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"4. 避免相关子查询 一个列的标签同时在主查询和 where 子句中的查询中出现，那么很可能当主查询中的列值改变之后，子查询必须重新查询一次。查询嵌套层次越多，效率越低，因此应当尽量避免子查询。如果子查询不可避免，那么要在子查询中过滤掉尽可能多的行。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:4","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"5. 避免困难的正规表达式 MATCHES 和 LIKE 关键字支持通配符匹配，技术上叫正规表达式。但这种匹配特别耗费时间。例如： SELECT * FROM customer WHERE zipcode LIKE “98_ _ _” 即使在 zipcode 字段上建立了索引，在这种情况下也还是采用顺序扫描的方式。如果把语句改为SELECT * FROM customer WHERE zipcode \u003e“98000”，在执行查询时就会利用索引来查询，显然会大大提高速度。 另外，还要避免非开始的子串。例如语句：SELECT * FROM customer WHERE zipcode[2，3] \u003e“80”，在 where 子句中采用了非开始子串，因而这个语句也不会使用索引。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:5","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"6.使用临时表加速查询 把表的一个子集进行排序并创建临时表，有时能加速查询。有助于避免多重排序操作，而且在其他方面还能简化优化器的工作。例如： SELECT cust.name，rcvbles.balance，……other columns FROM cust，rcvbles WHERE cust.customer_id = rcvlbes.customer_id AND rcvblls.balance\u003e0 AND cust.postcode\u003e“98000” ORDER BY cust.name 如果这个查询要被执行多次而不止一次，可以把所有未付款的客户找出来放在一个临时文件中，并按客户的名字进行排序： SELECT cust.name，rcvbles.balance，……other columns FROM cust，rcvbles WHERE cust.customer_id = rcvlbes.customer_id AND rcvblls.balance\u003e0 ORDER BY cust.name INTO TEMP cust_with_balance 然后以下面的方式在临时表中查询： SELECT * FROM cust_with_balance WHERE postcode\u003e“98000” 临时表中的行要比主表中的行少，而且物理顺序就是所要求的顺序，减少了磁盘 I/O，所以查询工作量可以得到大幅减少。 注意：临时表创建后不会反映主表的修改。在主表中数据频繁修改的情况下，注意不要丢失数据。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:6","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"7. 用排序来取代非顺序存取 非顺序磁盘存取是最慢的操作，表现在磁盘存取臂的来回移动。SQL 语句隐藏了这一情况，使得在写应用程序时很容易写出要求存取大量非顺序页的查询。 有些时候，用数据库的排序能力来替代非顺序的存取能改进查询。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:7","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"百万数据查询优化技巧三十则 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询： select id from t where num=0 应尽量避免在 where 子句中使用!=或\u003c\u003e操作符，否则将引擎放弃使用索引而进行全表扫描。 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 下面的查询也将导致全表扫描： select id from t where name like '%abc% 若要提高效率，可以考虑全文检索。 如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)='abc'--name以abc开头的id` select id from t where datediff(day,createdate,'2005-11-30')=0--‘2005-11-30’生成的id 应改为 select id from t where name like 'abc%' select id from t where createdate\u003e='2005-11-30' and createdate\u003c'2005-12-1' 要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(...) 很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段 sex，male、female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 任何地方都不要使用 select * from t，用具体的字段列表代替“*”，不要返回用不到的任何字段。 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 避免频繁创建和删除临时表，以减少系统表资源的消耗。 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 尽量避免大事务操作，提高系统并发能力。 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:2:0","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"常用SQL ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:0","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的存储过程 --select string using in procedure select b.name, a.text from syscomments a left join sysobjects b on b.id=a.id where b.xtype='P' and a.text like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:1","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的列名 --select columns name select b.name as Table1, a.name as Columns1,a.type from syscolumns a left join sysobjects b on b.id=a.id where b.xtype='u' and a.name like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:2","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的表名 --select table name select name from sysobjects where xtype='u' and name like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:3","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的函数名 --select string using in function select b.name, a.text from syscomments a left join sysobjects b on b.id=a.id where b.xtype='fn' and a.text like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:4","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的视图 --select string using in view select b.name, a.text from syscomments a left join sysobjects b on b.id=a.id where b.xtype='V' and a.text like '%abc%' Written with StackEdit. ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:5","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["语言与平台"],"content":" 这篇文章主要是翻译和记录了一些 Gateby 的基础知识，有助于开发者通过这些基础知识进行快速的开发 Refer to the Article: https://mpolinowski.github.io/gatsby-js-knowledgebase ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:0:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"10 添加文件数据(Adding File Data) 使用 Gatsby，您可以使用 GraphQL 直接从文件中查询数据。 Transformer插件将文件节点转换为各种其他类型的数据，例如 gatsby-transformer-json 将 将JSON 文件转换为 JSON 数据节点，而 gatsby-transformer-remark 将 将markdown 文件转换为 MarkdownRemark 节点，您可以从中查询 Markdown 的 的HTML 表示形式。 在这里，我们将使用gatsby-source-filesystem从我们的文件系统创建文件节点。 npm install --save gatsby-source-filesystem 安装后，将插件添加到 gatsby-config.js。 您可以具有此插件的多个实例，以从文件系统上的不同位置读取源节点。 以下设置了 Jekyll 模式：具有 Markdown 文件的页面目录和.json，.yaml，.csv 的数据目录： { resolve: `gatsby-source-filesystem`, options: { name: `pages`, path: `${__dirname}/src/pages/`, }, }, { resolve: `gatsby-source-filesystem`, options: { name: `data`, path: `${__dirname}/src/data/`, }, } 现在，您可以打开 GraphiQL 调试器-在大括号中，当你开始键入 allFiles 时，它应提供自动补全功能。 只需按 Enter 接受，然后再次按 CTRL + ENTER 填写所有页面 ID 的查询： { allFile { edges { node { id } } } } 当你删除 ID 并按 CTRL + SPACE 时，将显示一个包含所有可查询选项的下拉菜单：你可以使用 parent，children 和 和relativePath 属性来创建， 例如 breadcrumb navigation：现在，我们可以在/src/pages/page-2.js 中添加 GraphQL 查询，以遍历我们的所有页面并显示一些数据： export const query = graphql` query MyFilesQuery { allFile { edges { node { relativePath prettySize extension birthTime(fromNow: true) } } } } ` 不要忘记将{data}注入页面组件： const SecondPage = ({data}) =\u003e 现在，我们可以添加一些 JSX 来遍历所有文件，并在\u003ctable\u003e中输出信息 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003erelativePath\u003c/th\u003e \u003cth\u003eprettySize\u003c/th\u003e \u003cth\u003eextension\u003c/th\u003e \u003cth\u003ebirthTime\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e {data.allFile.edges.map(({ node }, index) =\u003e ( \u003ctr key={index}\u003e \u003ctd\u003e {node.relativePath} \u003c/td\u003e \u003ctd\u003e {node.prettySize} \u003c/td\u003e \u003ctd\u003e {node.extension} \u003c/td\u003e \u003ctd\u003e {node.birthTime} \u003c/td\u003e \u003c/tr\u003e ))} \u003c/tbody\u003e \u003c/table\u003e ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:1:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11 使用 Markdown(Working with Markdown) ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.1 添加 Markdown 到 GraphQL 现在，我们可以访问有关我们所有页面的信息。 但是如上所述，在最后一段的开头，我们还可以使用 Gatsby Transformer Plugins 来查找文件并将其内容可以通过 GraphQL 查询。 这里，我们希望使用 Markdown 文件并对其进行转换，以便能够在我们的网站上显示其内容。 为此所需的 Transformer Plugin 是 gatsby-transformer-remark。 首先，我们需要安装插件： npm install --save gatsby-transformer-remark 在 gatsby-config.js 中添加： plugins: [ `gatsby-transformer-remark`, ] 然后在/src/pages/FirstMDpost/index.md 内创建一个 markdown 页面，其中包含一些 FrontMatter（文件开头的元数据，以后可以由 GraphQL 查询）和一些文本： --- path: '/md-posts' title: 'My first Post' date: '2017-10-05' author: 'Mike Polinowski' chapter: 'Index' --- # This is my first mardown Post! 现在我们为 GraphQL 提供了 Markdown -与以前一样，只需开始输入 allMardownRemark（ENTER 自动完成），然后按 CTRL + ENTER 完成查询： ![gatsby_10](https://raw.githubusercontent.com/mpolinowski/gatsby-wiki/master/gatsby_10.png =577x189) 现在，我们可以查询 FrontMatter 以及添加到页面文件夹中的每个 MD 文件的 MD 转换为 HTML 的内容： ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:1","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.2 发布我们的 Markdown 数据模板 这些 Markdown 表示将要被显示的模板，但是现在我们需要创建一个用于此数据的样式模板。让我们先在/src 内添加一个称为templates的文件夹。 现在，向其中添加一个名为post.js的文件，该文件将包含每个帖子条目的结构模板。 该文件包含我们帖子的 JSX markup： import React from 'react' export default function Template({data}) { const {markdownRemark: post} = data return ( \u003cdiv\u003e \u003ch1\u003e{post.frontmatter.title}\u003c/h1\u003e \u003cdiv dangerouslySetInnerHTML={{__html: post.html}} /\u003e \u003c/div\u003e ) } export const postQuery = graphql` query BlogPostByPath($path: String!) { markdownRemark(frontmatter: { path: { eq: $path} }) { html frontmatter { path title } } } ` \u003cTemplate /\u003e组件接收{data}属性，这些属性由 GraphQL 查询检索。 该查询会查找 markdown 中 中frontmatter 里面所有 URL 等于$Path 的帖子，所以如果你在浏览器中键入的这个 URL 是/md-posts，那么路径中带有/md-posts 的文件，就会被调用。 然后，查询使用 markdownRemark 插件将 post markdown 转换为 HTML，并在{data}中提供其前题的路径和标题，并将其传递到组件，然后渲染。 Gatsby 已经配置为将/src/pages 中的所有页面路由为我们网站的页面。 但是现在我们必须注册来自 markdown 文件和 post.js 模板的帖子。 为此，我们必须在应用程序的根目录内创建一个名为 gatsby-node.js 的文件。 我们将使用createPages Gatsby API从我们的帖子模板创建页面： const path = require('path'); exports.createPages = ({boundActionCreators, graphql}) =\u003e { const {createPage} = boundActionCreators; // const createPage = boundActionCreators.createPage; const postTemplate = path.resolve('src/templates/post.js'); return graphql(`{ allMarkdownRemark { edges { node { html id frontmatter { path title } } } } }`) .then(res =\u003e { if(res.errors) { return Promise.reject(res.errors); } res.data.allMarkdownRemark.edges.forEach(({node}) =\u003e { createPage({ path: node.frontmatter.path, component: postTemplate }) }) }) } 保存并重新启动您的应用程序，然后在浏览器中打开 http://localhost:8000/md-posts ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:2","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.3 带有 Markdown 的嵌套路由 要为./src/pages/FirstMDpost/index.md 文件创建子帖子，我们可以简单地向文件夹中添加更多文件，并在其前题中定义嵌套路由 - e.g. ./src/pages/FirstMDpost/myfirstpost.md: --- path: '/md-posts/first-post' title: 'First Blog Post' date: '2017-10-05' author: 'Mike Polinowski' chapter: 'Markdown Posts' --- # This is my first markdown Post! 和 ./src/pages/FirstMDpost/mysecondpost.md: --- path: '/md-posts/second-post' title: 'Second Blog Post' date: '2017-10-05' author: 'Mike Polinowski' chapter: 'Markdown Posts' --- # A dive into Markdown Syntax 它们可以分别通过http://localhost:8000/md-posts/first-post和http://localhost:8000/md-posts/second-post 来访问 ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:3","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.4 创建 Index 页面 现在，我们可以使用 GraphQL 检索所有 Markdown 页面并将过滤它们。 对于此测试，我们将一个表添加到起始页面，显示最后 10 个帖子（到目前为止，我只发表了 3 3个帖子…），我们希望按日期降序排列它们，并且仅显示 chapter: ‘Markdown Posts’的页面 ，并排除我们的 index.md： const IndexPage = ({data}) =\u003e ( \u003cdiv\u003e \u003ch2\u003eMarkdown Index\u003c/h2\u003e \u003cp\u003eThe table below sorts out all Markdown pages that are not inside the \"Markdown Posts\" chapter - as defined inside their frontmatter. It also applies a filter, to only display the latest 10 posts. Click on here to display \u0026nbsp; \u003cLink to=\"/md-posts/\"\u003e all Markdown pages \u003c/Link\u003e .\u003c/p\u003e \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eDate\u003c/th\u003e \u003cth\u003eLink\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e {data.allMarkdownRemark.edges.map(post =\u003e ( \u003ctr key={post.node.id}\u003e \u003ctd\u003e {post.node.frontmatter.date} \u003c/td\u003e \u003ctd\u003e \u003cLink to={post.node.frontmatter.path}\u003e {post.node.frontmatter.title} \u003c/Link\u003e \u003c/td\u003e \u003c/tr\u003e ))} \u003c/tbody\u003e \u003c/table\u003e \u003c/div\u003e ) export const pageQuery = graphql` query IndexQuery { allMarkdownRemark(limit: 10 sort: {fields: [frontmatter___date], order: DESC} filter: { frontmatter: { chapter: {eq: \"Markdown Posts\"} }} ) { edges { node { id frontmatter { path title date } } } } } ` ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:4","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.5 缓存 Markdown 中的链接 一旦开始在 Markdown 文件中添加链接，您会发现单击它们会重新加载您的应用程序-这不是很好 :( 但请放心，这里的gatsby-plugin-catch-links可以助您一臂之力！ 它-安装后，将其添加到./gatsby-config.js 中的 Gatsby 插件中，它就可以正常工作： npm install --save gatsby-plugin-catch-links // In your gatsby-config.js plugins: [ `gatsby-plugin-catch-links`, ] ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:5","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"12 添加 Material-UI 为了使我们的生活更轻松，我们希望包含来自@ Materials-UI 的即用型 material 设计组件。 我们将安装 v.1.0.0 的测试版-它也需要 Roboto Fontface 和 和Material-UI 图标： npm install material-ui@next --save npm install typeface-roboto --save npm install material-ui-icons --save 现在，我们可以轻松地将 Material-UI 组件导入我们的应用程序： import React from 'react' import { render } from 'react-dom' import Button from 'material-ui/Button' import 'typeface-roboto' function AppWithButton() { return ( \u003cButton\u003e Hello World \u003c/Button\u003e ); } render(\u003cAppWithButton /\u003e, document.querySelector('#app')); ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:3:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"13 添加 Elasticsearch 该项目的先决条件之一是，我们需要为我们的 ElasticSearch Index 创建一个闪电般的界面。 我们已经为其构建了ES6 Class component。并将其添加到 Gatsby/Material-UI 中非常简单。 首先，添加./src/pages/search/jsx 并修改 ElasticSearch 组件来配合我们的 UI. import React, { Component } from 'react' import Link from 'gatsby-link' import elasticsearch from 'elasticsearch' import { withStyles } from 'material-ui/styles' import Grid from 'material-ui/Grid' import Button from 'material-ui/Button' import ResultCards from '../components/ResultCards' const connectionString = 'localhost:9200' const _index = 'wiki2_de_2017_09_09' const _type = 'article' let client = new elasticsearch.Client({ host: connectionString, log: \"trace\" }) const rootStyle = { flexGrow: 1, marginTop: 30, } export class Search extends Component { constructor(props) { super(props) this.state = { results: [] }; this.handleChange = this.handleChange.bind(this) } handleChange(event) { const search_query = event.target.value; client.search({ index: _index, type: _type, body: { query: { multi_match: { query: search_query, fields: ['title^100', 'tags^100', 'abstract^20', 'description^10', 'chapter^5', 'title2^10', 'description2^10'], fuzziness: 1, }, }, }, }).then(function(body) { this.setState({ results: body.hits.hits }); }.bind(this), function(error) { console.trace(error.message); } ); } render() { return ( \u003cdiv className=\"container\"\u003e \u003cinput type=\"text\" onChange={this.handleChange} /\u003e \u003cSearchResults results={this.state.results} /\u003e \u003c/div\u003e ); } } const SearchResults = ({results}) =\u003e ( \u003cdiv className=\"search_results\"\u003e \u003cbr/\u003e\u003chr/\u003e \u003cdiv className={rootStyle}\u003e \u003cGrid container spacing={24}\u003e {results.map((result , i) =\u003e \u003cResultCards key={i} image={result._source.image} title={result._source.title2} link={result._source.link} abstract={result._source.abstract}/\u003e )} \u003c/Grid\u003e \u003c/div\u003e \u003cbr/\u003e\u003cbr/\u003e\u003cLink to=\"/\" style={{ textDecoration: 'none' }}\u003e\u003cButton raised color=\"primary\"\u003eGo back to the homepage\u003c/Button\u003e\u003c/Link\u003e \u003c/div\u003e ) export default Search \u003cSearchResults /\u003e组件将遍历\u003cResultCards /\u003e组件内的 Material UI Card： import React from 'react' import Link from 'gatsby-link' import Card, { CardActions, CardContent, CardMedia } from 'material-ui/Card' import Button from 'material-ui/Button' import Typography from 'material-ui/Typography' import Grid from 'material-ui/Grid' const ResultCards = ({image, title, abstract, link}) =\u003e ( \u003cGrid item xs={12} sm={6} lg={4}\u003e \u003cCard style={{ maxWidth: 345 }}\u003e \u003cCardMedia style={{ height: 200 }} image={image} title={abstract} /\u003e \u003cCardContent\u003e \u003cTypography type=\"headline\" component=\"h4\" style={{ minHeight: 60, marginBottom: \"10px\" }}\u003e {title} \u003c/Typography\u003e \u003cTypography component=\"p\" style={{ minHeight: 50, marginBottom: \"10px\" }}\u003e {abstract} \u003c/Typography\u003e \u003c/CardContent\u003e \u003cCardActions\u003e \u003cLink to={link} style={{ textDecoration: 'none' }}\u003e \u003cButton dense color=\"primary\"\u003e Read \u003c/Button\u003e \u003c/Link\u003e \u003cButton dense color=\"primary\"\u003e Learn More \u003c/Button\u003e \u003c/CardActions\u003e \u003c/Card\u003e \u003c/Grid\u003e ) export default ResultCards 组件将添加来自 ElasticSearch JSON Response 的结果，并给我们一个灵活的卡片网格。 ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:4:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":" 这篇文章主要是翻译和记录了一些 Gateby 的基础知识，有助于开发者通过这些基础知识进行快速的开发 Refer to the Article: https://mpolinowski.github.io/gatsby-js-knowledgebase ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:0:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"06 属性传递(Passing down Props) 现在，我们可以从父组件传递属性到Counter组件。例： 我们可以通过显示的页面来更改我们的Counter 标题。 ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"6.1 更改头部 \u003cCounter header=\"This is the Index Counter\" /\u003e 这个header的属性现在可以用在Counter组件中的render方法。现在我们可以通过调用他的父组件来为Counter组件获取不同的标头了。 render() { return \u003cdiv\u003e \u003ch3\u003e{this.props.header}\u003c/h3\u003e \u003cp\u003ecurrent count: {this.state.count}\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003eplus\u003c/button\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count - 1 })}\u003eminus\u003c/button\u003e \u003c/div\u003e } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:1","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"6.2 更改样式 样式也是如此-如果我们希望标题与父组件的配色方案匹配，我们只需要将颜色属性传递给 Counter 组件： \u003cCounter header=\"This is the Index Counter\" color=\"rebeccapurple\" /\u003e 并在组件本身中添加必要的内联样式： render() { return \u003cdiv\u003e \u003ch3 style={{color: this.props.color}}\u003e{this.props.header}\u003c/h3\u003e \u003cp\u003ecurrent count: {this.state.count}\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003eplus\u003c/button\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count - 1 })}\u003eminus\u003c/button\u003e \u003c/div\u003e } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:2","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"6.3 设置默认属性 为了确保localhost:8000/counter URL 仍可以被打开，我们现在必须在Counter 组件内部定义一个默认的属性 - 如果没有父组件传递 props，则标题标记和字体颜色将是未定义的！ 这可以通过 Prop-Types 完成，我们需要安装： npm install --save prop-types 现在，我们可以将其导入到/src/pages/counter.js： import React from \"react\" import PropTypes from \"prop-types\" 并在Counter组件内（在export语句上方）为 header prop 定义一个默认值： Counter.defaultProps = { header: \"Default Counter\", color: \"black\", } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:3","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"07 Gatsby 插件(Gatsby Plugins) 插件是实现 Gatsby API 的 的Node.js 软件包。 它们使您能够轻松解决常见的网站构建问题，例如 设置 Sass，添加 markdown 支持，过程映像等。 ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:2:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"7.1 进度动画 在此示例中，我们要使用 NProgress.js 插件将加载动画添加到我们的网站。 您使用 npm 安装 NProgress 插件： npm install --save gatsby-plugin-nprogress 现在，我们必须告诉 Gatsby 通过编辑（在文件不存在的情况下创建）应用程序根目录内的 gatsby-config.js 文件来使用该插件。 在 在starter 模板中，我们已经安装了 react-helmet 插件（此插件如下所述：Page Layout）。 现在，只需将 gatsby-plugin-nprogress 添加到数组中： module.exports = { siteMetadata: { title: `Gatsby Wiki`, }, plugins: [ `gatsby-plugin-react-helmet`, { { resolve: `gatsby-plugin-nprogress`, options: { // Setting a color is optional. color: `rebeccapurple`, // Disable the loading spinner. showSpinner: false, }, }, ], } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:2:1","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"7.2 离线支持和清单 现在，我们想在网站上添加一个 Serviceworker，以帮助我们缓存应用程序的重要部分，从而为我们提供一定程度的脱机支持-正如 Offline Plugin告诉我们的那样，我们还将安装 Manifest Plugin （请确保它是 在 Offline Plugin 之前列出！）。 npm install --save gatsby-plugin-manifest npm install --save gatsby-plugin-offline 现在，将它们添加到我们的 Gatsby 配置中： module.exports = { siteMetadata: { title: `Gatsby Wiki`, }, plugins: [ `gatsby-plugin-react-helmet`, { resolve: `gatsby-plugin-nprogress`, options: { // Setting a color is optional. color: `rebeccapurple`, // Disable the loading spinner. showSpinner: false, }, }, { resolve: `gatsby-plugin-manifest`, options: { name: \"Gatsby Wiki\", short_name: \"Gatsby Wiki\", start_url: \"/\", background_color: \"white\", theme_color: \"rebeccapurple\", display: \"minimal-ui\", icons: [ { // Everything in /static will be copied to an equivalent // directory in /public during development and build, so // assuming your favicons are in /static/favicons, // you can reference them here src: `/apple-touch-icon.png`, sizes: `180x180`, type: `image/png`, }, { { src: `/favicon.ico`, sizes: `256x256`, type: `image/png`, }, ], }, }, `gatsby-plugin-offline`, ], } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:2:2","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"08 单页面应用(Single-Page-Application) Gatsby 基于他的布局特性提供了一个创建 Single-Page-Applications (SPA’s)的简单方法。 你可以在/src/layout 中找到 JSX 和 和CSS。我们正在使用的 Gatsby Starter，已经提供了头导航栏，该头导航栏已在 index.js 文件中定义（并带有必需的 CSS）。 您可以看到该应用程序已经使用React-Helmet作为 Gatsby 插件。 这个可重用的 React 组件将管理您对文档\u003chead\u003e的所有更改。 Helmet采用纯 HTML 标记并输出纯 HTML 标记。 该布局定义了\u003cHeader /\u003e组件，该组件与\u003cHelmet /\u003e组件一起在\u003cTemplateWrapper /\u003e内部使用。 您到目前为止所创建的页面中的所有内容，都将通过{children}标签注入到 Wrapper 中。 这样，您可以创建顶部导航栏，页眉，侧面导航和页脚，然后将其显示在所有网站上。 ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:3:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"09 GraphQL 我们可以在应用程序的根目录下的 gatsby-config.js 内定义一些全局变量： module.exports = { siteMetadata: { title: `Gatsby Wiki`, author: `Mike Polinowski`, description: `Trying out Gatsby`, }, } 该数据将可用于每个页面，并可使用 GraphQL 查询。 只需将以下 GraphQL 查询添加到/src/pages/index.js，即可保留这些值： export const query = graphql` query FirstQuery { site { siteMetadata { title author description } } } ` 然后，我们需要将此{data}注入父组件\u003cIndexPage /\u003e： const IndexPage = ({data}) =\u003e 现在我们可以查询组件内部的这些数据： \u003ch1\u003e{data.site.siteMetadata.description}\u003c/h1\u003e 为什么是 data.site.siteMetadata？Gatsby 的 的graphql 调试器在 http://localhost:8000/___graphql上运行，您也可以使用它来测试查询并查看结果。 只需打开调试器，然后尝试我们先前的查询： ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:4:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":" 这篇文章主要是翻译和记录了一些 Gateby 的基础知识，有助于开发者通过这些基础知识进行快速的开发 Refer to the Article: https://mpolinowski.github.io/gatsby-js-knowledgebase ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:0:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"00 准备操作 The default Gatsby starter Github 有关项目结构的概述，请参阅Gatsby documentation - Building with Components 从您的 CLI 运行此安装程序（假设已安装 Gatsby）： gatsby new gatsby-wiki ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:1:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"01 开始你的 Gatsby 开发环境(Start your Gatsby development environment) 现在请转到你的站点目录中，并使用 npm 运行你的 Gatsby 开发环境如下： cd gatsby-wiki npm run development 看，你可以访问你的网站了http://localhost:8000 ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:2:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"02 添加内容和链接页面(Adding content and Linking Pages) /src/pages/index.js 文件包含常规的 JSX-在\u003cdiv /\u003e标记内添加任何 HTML，可以让它显示在您的网站内。（Gatsby 使用的热加载） import React from \"react\" import Link from \"gatsby-link\" const IndexPage = () =\u003e ( \u003cdiv\u003e \u003ch1\u003eHi people\u003c/h1\u003e \u003cp\u003eWelcome to your new Gatsby site.\u003c/p\u003e \u003cp\u003eNow go build something great.\u003c/p\u003e \u003cLink to=\"/page-2/\"\u003eGo to page 2\u003c/Link\u003e \u003c/div\u003e ) export default IndexPage 你可以通过import Link from gatsby-link使用 Link 组件并链接到其他页面 \u003cLink to=\"/page-2/\"\u003eGo to page 2\u003c/Link\u003e 链接我们的 index.js 页面到同目录的 page-2 页面。/src /pages 文件夹中的每个 js 文件都会自动被 Gatsby 路由！ ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:3:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"03 样式化 JSX(Styling your JSX) 你可以在组件中使用内联样式如： const IndexPage = () =\u003e ( \u003cdiv style={{ color: \"tomato\", background: \"blue\"}}\u003e \u003ch1\u003eHi people\u003c/h1\u003e \u003cp\u003eWelcome to your new Gatsby site.\u003c/p\u003e \u003cp\u003eNow go build something great.\u003c/p\u003e \u003cLink to=\"/page-2/\"\u003eGo to page 2\u003c/Link\u003e \u003c/div\u003e ) 一些高级样式，请查看 Gatsby 插件 Glamor 或者 Styled Components. 如何安装这些插件请查看Gatsby Plugins。 ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:4:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"04 添加交互式插件(Adding Interactive Components) React 允许你向页面中添加交互 - 我们想添加一个计数器，在加载时将其状态设置为 0，并且有两个使用 onClick 事件增加或减少计数器状态的按钮。 我们可以添加一个新文件/src/pages/counter.js并链接到index页面\u003cLink to=\"/counter/\"\u003eGo to Counter\u003c/Link\u003e。 import React from \"react\" class Counter extends React.Component { constructor() { super() this.state = { count: 0 } } render() { return ( \u003cdiv\u003e \u003ch1\u003eCounter\u003c/h1\u003e \u003cp\u003ecurrent count: {this.state.count}\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003e plus plus\u003c/button\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count - 1 })}\u003e minus minus\u003c/button\u003e \u003c/div\u003e ) } } export default Counter ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:5:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"05 向你的站点导入组件(Importing Components to your Sites) 目前为止，我们将 pages 目录中的每个文件都用作单独的站点。但是 React.js 允许我们采用默认组件-在文件底部导出的默认组件-并将其导入另一个页面。 例如，我们可以将上面的\u003cCounter /\u003e组件添加到索引页面中（而不是仅链接到它）。 我们只需要在/src/pages/index.js开头添加import一行: import React from \"react\" import Link from \"gatsby-link\" import Counter from \"./counter\" 并在 index.js 的 的JSX 代码内引用 Counter，如下所示： const IndexPage = () =\u003e ( \u003cdiv\u003e \u003ch1\u003eHi people\u003c/h1\u003e \u003cp\u003eWelcome to your new Gatsby site.\u003c/p\u003e \u003cp\u003eNow go build something great.\u003c/p\u003e \u003cLink to=\"/page-2/\"\u003eGo to Page 2\u003c/Link\u003e \u003cbr /\u003e \u003cbr /\u003e \u003cCounter /\u003e \u003c/div\u003e ) ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:6:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":null,"content":"自我评价 Hi，我叫GETHIN，是一名主修计算机，有8年工作经验的软件工程师，擅长全栈开发，主要工作语言是C#，曾就职于多家知名外企和互联网企业，如Honeywell，腾讯文学等，目前就职于GreenDot。 擅长技术体系架构设计与重构，软件项目研究，分析设计与风险识别，爱好云原生架构设计。 熟悉OOP，SOA，AOP，MVC，MVVM，EDA，BDD，DDD，微服务架构，云架构，SPA等架构与编程思想，注重基于SOLID编码规范。熟悉常见的架构风格。熟悉各种UML的使用。 精通C#/.NET开发，熟悉Python，精通传统.NET相关技术WCF，WEBAPI，MVC，WPF并熟练掌握现代.NET开发技术.NET Core, RabbitMQ, Azure, K8S, Docker 等。 认证Scrum Master，善于发现和解决敏捷开发中的各种技术和流程问题，熟知软件开发生命周期SDLC。 熟悉手机IOS端开发，Cordova，熟悉react，vue，javascript，jquary等。 了解SQL Server，Oracle，MySQL，存储过程，EF，Redis。 ","date":"0001-01-01","objectID":"https://blog.gethin.online/about/:0:1","tags":null,"title":"关于我","uri":"https://blog.gethin.online/about/"},{"categories":null,"content":"个人经历 GREEN DOT - Sr. Software Engineer 在 GreenDot 担任 高级软件工程师，主要负责开发维护银行后端系统。如银行转账，信用卡自动还款 等 主要的开发语言是 C#，主要技术有 .NET Core, RabbitMQ, WEBAPI，K8S，SQLServer 等 主要项目：Eureka 发卡，TMM，BAAS交易，信用卡自动还款 等 2019 function non0plural(number, name) { if (number == 0) { return \"\" } if (number == 1 || number == -1) { return number + \" \" +name } return number + \" \" + name + \"s\" } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2019-05-31\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 let years = 0 if (months Honeywell - Software Engineer 1 years 在 霍尼韦尔 担任 移动端软件工程师，主要负责开发项目手机端应用，如SRS IOS手机端， 工业报警混合应用端 等 主要开发语言是SWIFT，JS。主要技术有 Cordova，Vue，IOS，Hybird 等 主要项目: REF SAAS IOS端应用，工业报警手机混合端应用 2018 GREEN DOT - Software Engineer II 3 years 在 GreenDot 担任 软件工程师，主要负责开发维护银行风险控制项目 主要开发语言是 C#， 主要技术有 .NET，WCF，MVC，WEBAPI 等 主要项目：APPLY PAY CASH风控，MITIK \u0026 IDOLOGY 风控系统集成，银行常规风控项目 等 2015 腾讯文学 - Software Engineer 1 years 在 腾讯文学 担任 软件工程师，主要负责开发维护起点读书的各种功能 在 主要开发语言是 C#，JS， 主要技术有 .NET，MVC，aspx，memchached，Oracle 主要项目：Mobile 端春节打赏活动，端闪屏替换，文章末打赏互动 等 2014 易贸集团 - Software Engineer 1 years 4 months 在 易贸集团 担任 软件工程师，主要负责开发维护集团内部的各种系统 主要开发语言是 C#，JS， 主要技术有 .NET，MVC，WPF，MSMQ 主要项目：会展系统，客服系统 等 2012 南京航空航天大学 - 计算机专业 4 years 南京航空航天大学，计算机专业，优秀毕业论文 2009 ","date":"0001-01-01","objectID":"https://blog.gethin.online/about/:0:2","tags":null,"title":"关于我","uri":"https://blog.gethin.online/about/"},{"categories":null,"content":"友情链如下 ","date":"0001-01-01","objectID":"https://blog.gethin.online/links/:1:0","tags":null,"title":"友情链接","uri":"https://blog.gethin.online/links/"},{"categories":null,"content":"欢迎留言 ","date":"0001-01-01","objectID":"https://blog.gethin.online/message-board/:1:0","tags":null,"title":"留言板","uri":"https://blog.gethin.online/message-board/"},{"categories":null,"content":"此页面用于展示收藏的网站 ","date":"0001-01-01","objectID":"https://blog.gethin.online/websites/:1:0","tags":null,"title":"网站收藏","uri":"https://blog.gethin.online/websites/"},{"categories":null,"content":"网站里程碑 BLOG 3.0 ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:0","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"},{"categories":null,"content":"个人博客3.0 由 hugo \u0026 loveit \u0026 github page 驱动 https://blog.gethin.online 摘要 博客3.0 基于 hugo 建站，主题采用了loveit，github action 作为 CI/CD，托管于github page。 gatsby 始终还是太重了，而且升级难度太大，依赖的包太多。强大也是强大的，折腾也是真折腾。人生有限，所以还是调整了策略，把博客迁移到hugo上，还是站在巨人的肩膀上才能做更多的事情。 摘要 2021-6-3 | 添加赞赏、网站分析、版权等功能 2021-5-28 | 添加时间轴、脑图、文章加密等功能 2021-5-17 | 添加背景图片 2021-5-16 | 添加顶部菜单 2021-5-12 | 添加测试文章 2021-5-11 | 集成搜索自动化 2021-5-10 | 添加评论，搜索 2021-5-6 | 集成Github Action 2021-5-5 | 建站 2021 function non0plural(number, name) { if (number == 0) { return \"\" } if (number == 1 || number == -1) { return number + \" \" +name } return number + \" \" + name + \"s\" } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2021-05-05\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 let years = 0 if (months BLOG 2.0 1 years ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:1","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"},{"categories":null,"content":"个人博客2.0 由 gatsby \u0026 tinacms \u0026 netlify 驱动 https://gethin.online 摘要 博客2.0 基于 gatsby 建站，主题采用了tinacms，netlify 作为 CI/CD，托管于netlify。 之前的基于react gatsby 引擎，依托于aks，个人维护精力有限，实在踩不起 19年 azure k8s 的那些坑。所以决定对网站进行升级，并托管于netlify。目前网站仍然保留。 2020 BLOG 1.0 10 months ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:2","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"},{"categories":null,"content":"个人博客1.0 由 gatsby \u0026 AKS 驱动 https://gethin.online 摘要 博客1.0 基于 gatsby 建站，自建主题，Azure DEVOPS 作为 CI/CD，托管于自建AKS。 2019年底个人博客建站，托管于自建AKS，使用Azure DEVOPS 作为CI/CD。博客用于总结个人技术，专注云原生，kubernetes，python 等技术。 2019 ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:3","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"}]