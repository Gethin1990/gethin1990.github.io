[{"categories":["架构艺术"],"content":"设计模式六大原则 单一职责原则 Single Responsibility Principle 一个类只负责一个功能领域中的相应职责，或者就一个类而言，应该只有一个引起它变化的原因。 开放封闭原则 Open-Close Priciple 一个软件实体应当对扩展开放，对修改封闭。软件实体应该尽量在不修改原有代码的情况下进行扩展。 里氏替换原则 Liskove Substitution Principe 所有引用基类的地方必须能透明的使用其子类的对象。（在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物） 依赖倒置原则 Dependency Inversion Principle 抽象不应该依赖于细节，细节应该依赖于抽象，要针对接口编程，而不是针对实现编程。（依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象） 接口隔离原则 Interface Segregation Principle 使用多个专用接口，而不是使用单一的总接口，客户端不应该依赖于那些它不需要的接口。 迪米特法则 Law of Demeter 一个软件实体应当尽可能少的与其他实体发生互相作用（高内聚，低耦合）。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:1:0","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"为什么要多用组合，少用继承 变化部分取出并封装起来，便于以后扩展，而不影响其他部分。要针对接口编程而不是针对实现编程。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:2:0","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"一句话常用设计模式 Iterator——迭代器 Adapter（适配器）————换个包装再度利用 ◎ 万事交给子类： Template Method（模板方法）————实际处理就交给子类 Factory Method（工厂方法）————建立对象实例交给子类 ◎建立对象实例 Singleton（单件）————唯一的对象实例 Prototype（原型）————复制建立对象实例 Builder（生成器）————组合复杂的对象实例 Abstract Factory（抽象工厂）————把相关零件组合成产品 ◎切割性思考 Bridge（桥接）————分成功能层次和实现层次 Strategy（策略）————把算法整个换掉 ◎一视同仁 Composite（组成）————对容器和内容一视同仁 Decorator（装饰）————对装饰和内容一视同仁 ◎在结构中穿梭来去 Visitor（访问者）————在结构中穿梭还同时做事 Chain of Responsibility（职责链）————责任转送 ◎简单最好 Facade（外观）————单一窗口 Mediator（中介者）————只要面对一个顾问 ◎管理状态 Observer（观察者）————通知状态变化 Memento（备忘录）————存储状态 State（状态）————以类表示状态 ◎精简不浪费 Flyweight（享元）————有相同的部分就分享，采取精简政策 Proxy（代理）————要用在建立 ◎用类来表示 Command（命令）————将命令写成类 Interpreter（解释器）————以类来表达语法规则 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:3:0","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"设计模式口诀 创建5：工厂，抽象工厂，单例，原型，建造者， 【抽工建单元】 结构7：适配器，代理，桥接，组合，装饰，外观，享元，【时代接合装外向】 行为11：解释器，模版，责任链，命令，中介，观察者，迭代器，备忘录，访问者，状态，策略 【责令中介观迭被，解释策略防撞模】 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:4:0","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"设计模式代码 自己整理的设计模式UML图与代码如下，UML 使用VS2015建模项目。 https://github.com/Gethin1990/design_pattern ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:5:0","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"C# 中常用的设计模式 单例（全局唯一）、工厂（反射）、迭代器（foreach）、观察者（消息队列）、责任链（pipeline）、外观（Gateway）、代理（网络相关）、解释器（表达式树）、策略（打折业务）等 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:6:0","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"设计模式介绍 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:0","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"抽象工厂模式 意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决：接口选择的问题。 何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决：在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。 注意事项：产品族难扩展，产品等级易扩展。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:1","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"工厂模式 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:2","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"建造者模式 意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 主要解决：在软件系统中，有时候面临着\"一个复杂对象\"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 何时使用：一些基本部件不会变，而其组合经常变化的时候。 如何解决：将变与不变分离开。 关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的\"套餐”。 2、JAVA 中的 StringBuilder。 优点： 1、建造者独立，易扩展。 2、便于控制细节风险。 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。 使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。 注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:3","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"单例模式 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决：一个全局使用的类频繁地创建与销毁。 何时使用：当您想控制实例数目，节省系统资源的时候。 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 1、一个班级只有一个班主任。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:4","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"原型模式 意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 主要解决：在运行期建立和删除原型。 何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。 关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些\"易变类\"拥有稳定的接口。 应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。 优点： 1、性能提高。 2、逃避构造函数的约束。 缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:5","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"适配器模式 意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决：在软件系统中，常常要将一些\"现存的对象\"放到新的环境中，而新环境要求的接口是现对象不能满足的。 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 如何解决：继承或依赖（推荐）。 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。 应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。 缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。 注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:6","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"代理模式 意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:7","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"桥接模式 意图：将抽象部分与实现部分分离，使它们都可以独立的变化。 主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。 何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。 如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。 关键代码：抽象类依赖实现类。 应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。 优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。 缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:8","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"组合模式 意图：将对象组合成树形结构以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。 关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。 应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。 优点： 1、高层模块调用简单。 2、节点自由增加。 缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。 使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。 注意事项：定义时为具体类。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:9","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"装饰器模式 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。 何时使用：在不想增加很多子类的情况下扩展类。 如何解决：将具体功能职责划分，同时继承装饰者模式。 关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。 应用实例： 1、孙悟空有 72 变，当他变成\"庙宇\"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：多层装饰比较复杂。 使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。 注意事项：可代替继承。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:10","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"外观模式 意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。 何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个\"接待员\"即可。 2、定义系统的入口。 如何解决：客户端不与系统耦合，外观类与系统耦合。 关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。 应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。 优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。 缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。 使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。 注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:11","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"享元模式 意图：运用共享技术有效地支持大量细粒度的对象。 主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。 何时使用： 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。 如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。 关键代码：用 HashMap 存储这些对象。 应用实例： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。 优点：大大减少对象的创建，降低系统的内存，使效率提高。 缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。 使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。 注意事项： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:12","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"责任链模式 意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用：在处理消息的时候以过滤很多道。 如何解决：拦截的类都实现统一接口。 关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。 应用实例： 1、红楼梦中的\"击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。 缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。 使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。 注意事项：在 JAVA WEB 中遇到很多应用。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:13","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"命令模式 意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。 主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 何时使用：在某些场合，比如要对行为进行\"记录、撤销/重做、事务\"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\"行为请求者\"与\"行为实现者\"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。 如何解决：通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。 关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口 应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。 优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。 缺点：使用命令模式可能会导致某些系统有过多的具体命令类。 使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。 注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:14","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"中介者模式 意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。 何时使用：多个类相互耦合，形成了网状结构。 如何解决：将上述网状结构分离为星型结构。 关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。 应用实例： 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。 优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。 缺点：中介者会庞大，变得复杂难以维护。 使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 注意事项：不应当在职责混乱的时候使用。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:15","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"观察者模式 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 如何解决：使用面向对象技术，可以将这种依赖关系弱化。 关键代码：在抽象类里有一个 ArrayList 存放观察者们。 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。 优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。 缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:16","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"迭代器模式 意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 主要解决：不同的方式来遍历整个整合对象。 何时使用：遍历一个聚合对象。 如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。 关键代码：定义接口：hasNext, next。 应用实例：JAVA 中的 iterator。 优点： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。 注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:17","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"备忘录模式 意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有\"后悔药\"可吃。 如何解决：通过一个备忘录类专门存储对象状态。 关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。 应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。 优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 使用场景： 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。 注意事项： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:18","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"解释器模式 意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 主要解决：对于一些固定文法构建一个解释句子的解释器。 何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 如何解决：构建语法树，定义终结符与非终结符。 关键代码：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。 应用实例：编译器、运算表达式计算。 优点： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。 缺点： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。 使用场景： 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。 注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:19","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"策略模式 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决：将这些算法封装成一个一个的类，任意地替换。 关键代码：实现同一个接口。 应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。 优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。 使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:20","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"访问者模式 意图：主要将数据结构与数据操作分离。 主要解决：稳定的数据结构和易变的操作耦合问题。 何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，使用访问者模式将这些封装到类中。 如何解决：在被访问的类里面加一个对外提供接待访问者的接口。 关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。 应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。 优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。 缺点： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。 使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，也不希望在增加新操作时修改这些类。 注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:21","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"状态模式 意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 何时使用：代码中包含大量与对象状态有关的条件语句。 如何解决：将各种具体的状态类抽象出来。 关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。 应用实例： 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，‘钟是抽象接口’,‘钟A’等是具体状态，‘曾侯乙编钟’是具体环境（Context）。 优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对\"开闭原则\"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。 注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:22","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["架构艺术"],"content":"模板模式 意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 主要解决：一些方法通用，却在每一个子类都重新写了这一方法。 何时使用：有一些通用的方法。 如何解决：将这些通用算法抽象出来。 关键代码：在抽象类实现，其他步骤在子类实现。 应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。 优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。 注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。 ","date":"2021-08-15","objectID":"https://blog.gethin.online/design-pattern/:7:23","tags":["设计模式"],"title":"设计模式","uri":"https://blog.gethin.online/design-pattern/"},{"categories":["软件工程"],"content":"1. 定义问题与归结模型 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:1:0","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"1.1 问题分析 在问题定义上达成共识 问题概述，影响，结果，优点 理解问题的本质 因果鱼骨图（将问题写在右边的方框里，确定问题潜在原因的主要类别，用头脑风暴法寻找原因并归类） 帕累托图（明确问题，找出问题原因，选择评价标准和考察期限，收集各种原因发生的频率与费用数据，将原因按照发生的频率排列，将原因横轴频率纵轴） 确定项目干系人和用户 定义系统边界（上下文范围图，用例模型） 确定系统实现的约束 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:1:1","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"1.2 问题定义 目标（优势，度量，合理性，可行性，可达成性） 功能需求（注意二义性【同名异义词，代词】） 非功能需求（感官需求，易用性需求，性能需求，可操作性需求，可维护性和可移植性需求，安全性需求，文化和政策需求，法律需求，） ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:1:2","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"2 需求分析与软件设计 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:2:0","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"2.1 需求分析的任务与过程 问题识别，分析与综合，编制需求分析的文档，需求分析与评审 分类：功能需求，非功能需求，设计约束，业务需求，用户需求，系统需求 需求工程：开发，管理 分析方法：结构化分析方法，软系统方法，面向对象分析方法，面向问题分析 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:2:1","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"2.2 如何进行系统设计 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:2:2","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"2.3 软件设计的任务与活动 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:2:3","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"3 架构化分析与设计 是一种面向数据流的需求分析和设计方法，适用与分析设计大型数据处理系统 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:3:0","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"3.1 结构化分析 结构化分析工作步骤：研究“物质环境“；建立系统逻辑模型；划清人机界限 数据流图：过程；外部实体；数据存储；数据流；实时连接； 细化几率DFD部件 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:3:1","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"3.2 结构化设计 概要设计与详细设计的主要任务； 结构图； 程序流程图和盒图； PAD和PDL ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:3:2","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"3.3 模块设计 信息隐蔽原则 模块独立性原则 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:3:3","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"4 面向对象的分析与设计 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:4:0","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"4.1 面向对象的基本概念 对象与类：实体类，控制类，边界类 继承与泛化 多态与重载 模版类 消息与消息通信 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:4:1","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"4.2 面向对象分析 OOA/OOD方法 5个层次：主题，对象类，结构，属性，服务 5个步骤：标识对象类，标识结构与关联，划分主题，定义属性，定义服务 4个部分：设计问题域部分，设计人机交互部件，设计任务管理部分，设计数据管理部分 Booch方法 4个步骤：标识类和对象，确定类和对象的含义，标识关系，说明类的接口和实现 OMT方法 三大模型：对象模型，动态模型，功能模型 OOSE方法 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:4:2","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"4.3 统一建模语言 UML设计与基本概念 UML结构：构造块（建模元素，关系，图），公共机制（规格说明，修饰，公共分类，扩展机制），架构（逻辑视图，进程视图，实现视图，部署视图，用例视图） 用例图基础： 参与者，用例，包含和扩展。 类图和对象图基础： 类和对象（类的获取和命名，类的属性，类的操作） 类之间的关系（依赖关系，泛化关系，关联关系【聚合，组合】，实现关系） 多重性问题 类图 对象图 交互图基础：顺序图，通信图，定时图 状态图基础：状态，初始状态，结束状态，状态转移。 活动图基础：基本活动图，带泳道的活动图，对象流，信号 构件图基础：面向对象系统的物理方面进行建模1。 部署图基础：面向对象系统的物理方面进行建模2。 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:4:3","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"5 用户界面设计 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:5:0","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"5.1 用户界面设计的原则 置用户于控制之下 减少用户的记忆负担 保持界面的一致 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:5:1","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"5.2 用户界面设计过程 用户、任务、环境分析，界面设计，实现，界面确认 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:5:2","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"6 工作流设计 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:6:0","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"6.1 工作流设计概述 工作流，流程定义，流程实例，工作流管理系统，流程定义工具，参与者，活动，活动所有者，工作所有者，工作项。 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:6:1","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"6.2 工作流管理系统 流程定义工具，工作流执行服务，其他工作流执行服务，客户应用程序，被调用应用程序，管理和监控工具 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:6:2","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"7 简单分布式计算机应用系统的设计 基于实例协作 基于服务协助 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:7:0","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"8 系统运行环境的集成与设计 集中式设计：单计算机结构，集群结构，多计算机结构 分布式系统 C/S结构 多层结构 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:8:0","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["软件工程"],"content":"9 系统过渡计划 直接过度，并行过度，阶段过渡 ","date":"2021-08-11","objectID":"https://blog.gethin.online/system-analysis-and-design/:9:0","tags":["系统分析与设计"],"title":"系统分析与设计","uri":"https://blog.gethin.online/system-analysis-and-design/"},{"categories":["语言与平台"],"content":"概述 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:1:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"谈一谈对DDD的理解 DDD，领域驱动设计。就是通过领域来指导软件设计，是一种十分抽象的软件设计思想，它主要分为战略设计和战术设计。 战略方面，通过事件风暴进行领域模型的划分，划分出核心域，子域，支撑域，定义通用语言，划分出界限上下文。 在战术设计方面，ddd将架构分层，“松耦合，高内聚”是架构设计的整体思想。按照DDD思想，可以分为领域层，基础设施层，应用层，接口层。 接口层为前端用户提供api接口。基础设施层可以放一些第三方的服务，数据库连接等内容。 应用层是对领域服务的编排，是很薄的一层（目前我自己的架构，应用的是cqrs，所有的相关逻辑都是放在了应用层，而领域层只是放了实体，因为暂时还不是特别理解领域层的服务和事件都应该写什么）。 领域层包括实体，值对象，聚合根，领域服务，领域事件等内容。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:1:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"ASP.NET Core 比 ASP.NET 更具优势的地方是什么 跨平台 对框架没有依赖 处理请求效率更高 可以自我寄宿 轻量高性能 可以使用vs；vs code进行开发 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:1:2","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"ASP.NET Core 主要的特性有哪些 startup 类 依赖关系注入（服务） 中间件 主机 服务器 appsettings.json 配置 选项 环境（dev,stage,prod） Logging 路由 处理错误 发送HTTP请求 静态文件 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:1:3","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"Startup ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:2:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"什么是dot net core的startup class Startup class是dot net core应用的入口。 所有的dot net core应用必须有这个class。这个类用来配置应用。 这个类的调用是在program main函数里面进行配置的。类的名字可以自己定义。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:2:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"如何在controller中注入service ConfigureServices 添加 Service； services.TryAddTransient\u003cIDataAccess, DataAccess\u003e(); 在controller 添加注入 private readonly ILogManager _logManager; public HomeController(ILogManager logManager) { _logManager = logManager; } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:2:2","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"Startup 类包括哪些配置 ConfigureServices （可选择）方法以配置应用的服务。 服务是一个提供应用功能的可重用组件。 在 ConfigureServices 中注册服务，并通过依赖关系注入 (DI) 或 ApplicationServices 在整个应用中使用服务。 Configure 方法用于指定应用响应 HTTP 请求的方式。 可通过将中间件组件添加到 IApplicationBuilder 实例来配置请求管道。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:2:3","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"startup class的configure方法有什么作用 这个方法来定义整个应用如何响应HTTP请求。 它有几个比较重要的参数，application builder，Hosting environment, logo factory， 在这里我们可以配置一些中间件用来处理路径，验证和session等等。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:2:4","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"依赖注入 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"ASP.NET Core Filter如何支持依赖注入 可以通过全局注册，支持依赖注入； 通过TypeFilter(typeof(Filter)) 标记在方法，标记在控制器 通过ServiceType(typeof(Filter))标记在方法，标记在控制器，必须要注册Filter这类； TypeFilter和ServiceType的本质是实现了一个IFilterFactory接口； ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"介绍ASP.NET Core中服务的生命周期 Singleton 只有一个服务的实例被创建，这个实例，存储在内存中，可以在整个应用程序中使用。我们可以对一些初始化代价比较大的服务，使用Singleton模式。 services.AddSingleton\u003cIProductService, ProductService\u003e(); Scoped 范围内的，作用域生存期服务，以每个客户端请求(连接)一次的方式创建。可以这么理解：同一个请求中同一个IServiceProvider提供的对象是同一个。 services.AddSingleton\u003cIProductService, ProductService\u003e(); Transient 服务每次被请求的时候，都会创建一个服务实例，这种模式特别适合轻量级、无状态的服务。 services.AddSingleton\u003cIProductService, ProductService\u003e(); ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:2","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"什么是依赖注入 通过控制反转（Ioc），对象A在被创建的时候，由一个IOC容器来控制依赖，把类B通过构造函数，属性或工厂模式等方法，注入到类A内，实现对类A和类B的解耦。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:3","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"依赖注入有哪几种方式 属性注入 using Microsoft.Extensions.Logging; using Microsoft.Extensions.Logging.Abstractions; namespace MyApp { public class ProductService { public ILogger\u003cProductService\u003e Logger { get; set; } private readonly IProductRepository _productRepository; public ProductService(IProductRepository productRepository) { _productRepository = productRepository; Logger = NullLogger\u003cProductService\u003e.Instance; } public void Delete(int id) { _productRepository.Delete(id); Logger.LogInformation($\"Deleted a product with id = {id}\"); } } } 构造函数注入 public class ProductService { private readonly IProductRepository _productRepository; public ProductService(IProductRepository productRepository) { _productRepository = productRepository; } public void Delete(int id) { _productRepository.Delete(id); } } 接口注入 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:4","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"控制反转是什么 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:5","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"依赖注入有哪些著名的框架 Unity、autofac、spring.net、MEF、Injection、Asp.Net Core的ServiceCollection。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:6","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"依赖注入实现原理 实现DI，核心在于依赖注入容器IContainer，该容器具有以下功能 （容器）保存可用服务的集合 // 要用的特定对象、特定类、接口服务 （注册）提供一种方式将各种部件与他们依赖的服务绑定到一起；// Add…函数或containerBuilder.Register函数， （解析点）为应用程序提供一种方式来请求已配置的对象： 构造函数注入、属性注入. 运行时，框架会一层层通过反射构造实例，最终得到完整对象。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:3:7","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"中间件 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"什么是中间件（Middleware） 中间件是一种装配到应用管道以处理请求和响应的软件。 每个组件： 选择是否将请求传递到管道中的下一个组件。 可在管道中的下一个组件前后执行工作。 请求委托用于生成请求管道。 请求委托处理每个 HTTP 请求。 使用 RunMap 和 Use 扩展方法来配置请求委托。 可将一个单独的请求委托并行指定为匿名方法（称为并行中间件），或在可重用的类中对其进行定义。 这些可重用的类和并行匿名方法即为中间件，也叫中间件组件。 请求管道中的每个中间件组件负责调用管道中的下一个组件，或使管道短路。 当中间件短路时，它被称为“终端中间件”，因为它阻止中间件进一步处理请求。 public class Startup { public void Configure(IApplicationBuilder app) { app.Use(async (context, next) =\u003e { // Do work that doesn't write to the Response. await next.Invoke(); // Do logging or other work that doesn't write to the Response. }); app.Run(async context =\u003e { await context.Response.WriteAsync(\"Hello from 2nd delegate.\"); }); } } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"中间件的使用场景有哪些 身份验证，Session存储，日志记录等。 其实我们的Asp.net core项目中本身已经包含了很多个中间件。比如 身份认证中间件 UseAuthorization()等系列。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:2","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"列举官方常用的中间件 以下 Startup.Configure 方法将为常见应用方案添加中间件组件： 异常/错误处理 当应用在开发环境中运行时： 开发人员异常页中间件 (UseDeveloperExceptionPage) 报告应用运行时错误。 数据库错误页中间件报告数据库运行时错误。 当应用在生产环境中运行时： 异常处理程序中间件 (UseExceptionHandler) 捕获以下中间件中引发的异常。 HTTP 严格传输安全协议 (HSTS) 中间件 (UseHsts) 添加 Strict-Transport-Security 标头。 HTTPS 重定向中间件 (UseHttpsRedirection) 将 HTTP 请求重定向到 HTTPS。 静态文件中间件 (UseStaticFiles) 返回静态文件，并简化进一步请求处理。 Cookie 策略中间件 (UseCookiePolicy) 使应用符合欧盟一般数据保护条例 (GDPR) 规定。 用于路由请求的路由中间件 (UseRouting)。 身份验证中间件 (UseAuthentication) 尝试对用户进行身份验证，然后才会允许用户访问安全资源。 用于授权用户访问安全资源的授权中间件 (UseAuthorization)。 会话中间件 (UseSession) 建立和维护会话状态。 如果应用使用会话状态，请在 Cookie 策略中间件之后和 MVC 中间件之前调用会话中间件。 用于将 Razor Pages 终结点添加到请求管道的终结点路由中间件（带有 MapRazorPages 的 UseEndpoints）。 public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); app.UseDatabaseErrorPage(); } else { app.UseExceptionHandler(\"/Error\"); app.UseHsts(); } app.UseHttpsRedirection(); app.UseStaticFiles(); app.UseCookiePolicy(); app.UseRouting(); app.UseAuthentication(); app.UseAuthorization(); app.UseSession(); app.UseEndpoints(endpoints =\u003e { endpoints.MapRazorPages(); }); } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:3","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"中间件的执行顺序 异常/错误处理 HTTP 严格传输安全协议 HTTPS 重定向 静态文件服务器 Cookie 策略实施 路由 身份验证 会话 MVC ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:4","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"application builder的use和run方法有什么区别 这两个方法都在start up class的configure方法里面调用。都是用来向应用请求管道里面添加中间件的。 Use方法可以调用下一个中间件的添加，而run不会。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:5","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"dot net core 管道里面的map拓展有什么作用 可以针对不同的路径添加不同的中间件。 public class Startup { private static void HandleMapTest1(IApplicationBuilder app) { app.Run(async context =\u003e { await context.Response.WriteAsync(\"Map Test 1\"); }); } private static void HandleMapTest2(IApplicationBuilder app) { app.Run(async context =\u003e { await context.Response.WriteAsync(\"Map Test 2\"); }); } public void Configure(IApplicationBuilder app) { app.Map(\"/map1\", HandleMapTest1); app.Map(\"/map2\", HandleMapTest2); app.Run(async context =\u003e { await context.Response.WriteAsync(\"Hello from non-Map delegate. \u003cp\u003e\"); }); } } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:4:6","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"配置 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:5:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"ConfigurationBinder 的常用方法 GetValue GetSection GetChildren Exists AddJsonFile ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:5:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"日志 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:6:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"日志的级别有哪些 LogLevel “值” 方法 描述 Trace 0 LogTrace 包含最详细的消息。 这些消息可能包含敏感的应用数据。 这些消息默认情况下处于禁用状态，并且不应在生产中启用。 调试 1 LogDebug 用于调试和开发。 由于量大，请在生产中小心使用。 信息 2 LogInformation 跟踪应用的常规流。 可能具有长期值。 警告 3 LogWarning 对于异常事件或意外事件。 通常包括不会导致应用失败的错误或情况。 错误 4 LogError 表示无法处理的错误和异常。 这些消息表示当前操作或请求失败，而不是整个应用失败。 严重 5 LogCritical 需要立即关注的失败。 例如数据丢失、磁盘空间不足。 无 6 指定日志记录类别不应写入任何消息。 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:6:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"路由 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:7:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"默认路由的配置和使用 public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddMvc(); } public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { app.UseMvc(routes =\u003e { routes.MapRoute( name: \"default\", template: \"{controller=Home}/{action=Index}/{id?}\"); }); } } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:7:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"配置多个默认路由 app.UseMvc(routes =\u003e { //New Route routes.MapRoute( name: \"about-route\", template: \"about\", defaults: new { controller = \"Home\", action = \"About\" } ); routes.MapRoute( name: \"default\", template: \"{controller=Home}/{action=Index}/{id?}\"); }); ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:7:2","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"配置标签(Attributes)为个方法或控制器指定路由 [Route(\"[controller]\")] public class AnalyticsController : Controller { [Route(\"Dashboard\")] public IActionResult Index() { return View(); } [Route(\"[action]\")] public IActionResult Charts() { return View(); } } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:7:3","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"配置RESTful路由 [Route(\"api/[controller]\")] public class ValuesController : Controller { // GET api/values [HttpGet] public IEnumerable\u003cstring\u003e Get() { return new string[] {\"hello\", \"world!\"}; } // POST api/values [HttpPost] public void PostCreate([FromBody] string value) { } // POST api/values/5 [HttpPost(\"{id}\")] public void PostUpdate(int id, [FromBody] string value) { } } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:7:4","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"配置路由器参数约束 [HttpGet(\"{id:int}\")] public string GetById(int id) { return \"item \" + id; } ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:7:5","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"错误处理 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:8:0","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"Asp.Net Core中有哪些异常处理的方案 继承 Controller，重写 OnActionExecuted 使用 ActionFilterAttribute 使用 IExceptionFilter 使用 ExceptionHandler 自定义 Middleare 处理 ","date":"2021-08-10","objectID":"https://blog.gethin.online/dotnet-core/:8:1","tags":["dotnet"],"title":".NET CORE","uri":"https://blog.gethin.online/dotnet-core/"},{"categories":["语言与平台"],"content":"词根(2565) 词根 含义 示例 -cel 动画序列中的单帧【词根】天空【后缀】表小称或“缩小” parcel(n.包裹，小包，邮包) -dom 【词根】家；房子；驯服；驯服【后缀】表示抽象名词 kingdom(n.王国；领域，界) -ed 埃德（男名）【词根】吃【后缀】形容词【后缀】 edible(n. 食品, 食物) -fic 【词根】做【后缀】表示“形成…的”，“产生…的” fiction(n.小说；虚构，杜撰) -ite 【词根】走【后缀】名词【后缀】;形容词【后缀】;动词【后缀】 computerite(n. 电脑迷（等于computernik）；电脑技术人员) -let vi.出租【后缀】表小称或“缩小”【词根】诱使 houselet（n. 小房子） -long adj. 长的；过长的【词根】长的【后缀】表示方向 prolong（vt. 延长；拖延（pro向前+long→向前长→延长）） -man n. 人；男人【词根】停留；手【后缀】表示“人” manual(n. 手册; 指南) -ment 【词根】思考；心智;记忆【后缀】表示抽象名词 mention(vt.\u0026n.提及，说起（ment+ion→有思考→想到，提到) -tic / tik/ n. 痉挛【词根】形容词【后缀】 dramatic（adj. 戏剧的；引人注目的；激动人心的） -ward n.病房；选区【词根】照顾，照料【后缀】表示方向 reward(n. [劳经] 报酬；报答；酬谢) *-al 【词根】滋养【前缀】总的【后缀】表示抽象名词 principal(a.主要的) *ac 【词根】酸的；尖锐的【前缀】＝ad-[用于c,k或q前] acid(adj. 酸的；讽刺的；刻薄的) accept(vt. 接受；承认；承担（ac往里，cept拿）) *ag / Ag/ a. 农业的【词根】行为；行动【前缀】转为动词 agent(作用因素,代理人(ag+ent表人或物=做的人=代理人)) *am / Am, Em/ 上午【词根】喜爱【前缀】不；无 amateur(n. 业余从事者; 粗通的人; 外行; 爱好者) *arch / a:tF/ n.拱【词根】首领；统治者【前缀】古代 anarchism（无政府主义的(an无+arch+ism主义)） *be v. 是; 值【词根】居住【前缀】变换为及物动词 tribe(n.部落，宗族) *cor 【医】 心脏, 心【词根】心【前缀】一同，合并 correspond(v 符合,通信(cor共同+respond回答=两人互相回答=通信)) *di 【词根】日【前缀】二 dial(n.钟面；拨号盘) *du 【计】 定义使用【词根】负债【前缀】二,双 duplicate(n. 复制品) *em 【词根】拿；买【前缀】进入某种状态，使成为… enamor(vt. 使迷恋，使倾心) *ev 【电】 电子伏特【词根】年龄；时代【前缀】良好 medieval(a.中世纪的（medi中间+eval→中间时代的→中世纪的）) *fort n.要塞，堡垒【词根】强壮的,运气【前缀】十四 fortune(n. 财富, 兴隆, 运气) *hom 【词根】人【前缀】相同 homogeneous(a.同类的；均匀的) *ig 【词根】行为；行动【前缀】不,非,无 navigation(n.航行；航海术；导航) *im 【词根】主张【前缀】不,非,无；向内,进入,朝 impossible(adj. 不可能的；不可能存在的) *mal 【医】 [疾]病【前缀】不舒服；与bene相反【词根】坏 malice(n.恶意；蓄意犯罪) *med 【词根】治疗【前缀】=mid中间 remedy(n.\u0026vt.治疗；补救) *mega 【计】 兆; 百万【词根】大【前缀】百万,兆 megalith(n. 巨石) *mis 【词根】送；释放【前缀】坏，错误，否定 misconduct(n. 不端行为；处理不当) *mon 等于Monday星期一【词根】劝告；吃【前缀】单一 monument(n. 纪念碑（monu警告，提醒+ment→提醒的东西→纪念碑）) *pan / pAn/n.平底锅【词根】面包【前缀】全；所有的 panacea(n. 灵丹妙药；万能药) *par n. 标准【词根】准备；相等的；出现；生【前缀】完全 parent(n. 父亲（或母亲）；父母亲；根源) *pel 【计】 象素【词根】驱动；驱赶【前缀】完全；彻底 repel(vt.拒绝；使厌恶) *peri n. 美丽仙女【词根】通过；尝试【前缀】周围；环绕 expert(n.专家) *pil 【词根】毛发；柱【前缀】完全；彻底 compile(vt.编辑，编制，搜集) *pur 【词根】纯粹的【前缀】为了…；代替…；赞成… pursuit(n.追赶；追求；事务) *sept / sept/ n. 氏族【前缀】七【词根】腐烂 septet(n. [计] 七位字节；七重奏) *sim 【前缀】单一；一个接一个【词根】相似 simply(ad.简单地；朴素地) *sum / sQm/n.总数, 和, 金额【前缀】下；次【词根】集结 resume(n. 摘要；[管理] 履历，简历) *sur 【词根】确定的；安全的【前缀】在下面,超过 survive(vt. 幸存；生还；幸免于（sur在下面+viv+e→在[事故]下面或下来→辛存） *tele n. 电视【词根】远【前缀】远距离 television(n.电视；电视机) *un 联合国【词根】一【前缀】不,无；相反的动作 unlimited(a.无限的；不定的) *ut 【词根】用【前缀】向外；超越；胜过 utmost(a.最远的) abl 【词根】：能力 able(adj. 能；[经管] 有能力的；能干的) abol 【词根】：废除 abolish(vt. 废除，废止；取消，革除) academ 【词根】：学术 academic（adj. 学术的；理论的；学院的） accoutr 【词根】：dress（穿着） accoutrement （n. 穿着；配备（等于accouterment）） acer 【词根】：苦, 酸, 尖 acerbic（adj. 尖刻的（等于acerb）；酸的；辛辣的） acerb adj. 尖锐的；酸涩的【词根】尖,酸,锐利 acerbate(adj. 恼怒的；粗鄙的) acet 【化】 次乙基; 乙酰【词根】sharp,sour尖,酸 acetimeter(n. 醋酸比重计) acid / 5Asid/ a.酸的【词根】酸的；尖锐的 acid(n.酸；酸的，酸性的) acm 【词根】：top（顶端） acme（n. 顶点，极点；最高点） acou 【词根】：听,闻 acoustics（n. 声学；音响效果，音质） acr 【词根】酸的；尖锐的 acrid(adj. 刺激的; 刻薄的; 苦的, 辣的) acri 【词根】：表示“尖，酸，锐利” acrid(adj. 刺激的; 刻薄的) act / Akt/ 表演【词根】行为；行动 react(vi.起反应；有影响) acu 【词根】：表示“尖，酸，锐利” acute(adj. 尖锐的; 剧烈的) add vi. 加；增加【词根】加 addendum(n. 补遗; 补篇; 追加; 附录) adelph 【词根】：兄弟 adelphogamy(n. 姊妹交配，同胞交配) adip 【词根】：fat（肥） adipose（adj. 脂肪的；肥胖的） adjut 【词根】：assist（帮助） adjutant（n. 副官，助手） advant 【词根】：ahead（前面） advantage（n. 优势；利益；有利条件） aeg 【词根】：山羊,保护、庇护 aegagrus(n.野山羊) aem 【词根】：血 anaemic(adj. 贫血的，患贫血症的；无活力的) aer 【医】 气压单位【词根】空气；天空 aerial(空气的(aeri+al表形容词)) aeri 【词根】：表示“空气，充气”等 aerial(adj. 航空的; 由飞机进行的; 飞机的; 空气的) aero adj.航空的。【词根】表示“空气，充气”等 aerospace(n. 航空宇宙) aesth 【词根】：发觉 aesthete(n. 唯美主义者；审美家) aesthet 【词根】感觉 aesthetics(n 美学(aesthet感觉+ics)) aestiv 【词根】夏天 aestivation(n. 度夏; 夏眠) agap 【词根】：爱 agape(n.神对世人的爱) agi 【词根】：表示摇动、行动、驱使、领导、引领等 agitate（vt. 摇动；骚动；使…激动) ago adv. 以前【词根】引导 pedagog(n. （小学）教师) agog adj. 兴奋的。【词根】：表示“引导” demagogue(n. 煽动者, 群众煽动者) agogue 【词根】领导者 demagogue(n 煽动者(dem人民+agogue=引导肉民者=煽动者)) agon n. 斗争；竞赛。【词根】：表示“挣扎，斗争” agony(n.极度痛苦; 临死的痛苦; 苦恼) agor 【词根】：市场 agora(n. 市场；集会) agr 【词根】田野，农田 agriculture(n.农业，农艺；农学) agri 【词根】田地，农田 agrimotor(农用拖拉机(agri+motor机动车)) agro n. 暴力行为。 【词根","date":"2021-08-03","objectID":"https://blog.gethin.online/english-root-full/:1:0","tags":["english"],"title":"英语词根","uri":"https://blog.gethin.online/english-root-full/"},{"categories":["语言与平台"],"content":"前后缀(10) 词根词缀 含义 示例 *-a 一【前缀】用于加强语气,不【后缀】表示抽象名词 atom（n 原子(a不+tom=不能在切割的小东西=原子)） *-al 【词根】滋养【前缀】总的【后缀】表示抽象名词 principal(a.主要的) *-an / An, En/ 一【前缀】无；非；缺乏【后缀】表示\"人” anarchy（无政府状态(an无+archy)） *-ant / Ant/ 蚂蚁【前缀】在前；相反【后缀】表示“人” sergeant（n. 警官, 军士） *-ar 【前缀】转为动词【后缀】表性质、大小状况、状貌 pedlar(n.(挨户兜售的)小贩) *-d 【前缀】：右或顺时针方向.【后缀】:构成某些动词的过去式等 D-glucose（n. 葡萄糖） *-e 【前缀】出,除去；超出【后缀】名词结尾e,无实意 eject(v.喷出；驱逐（e出+ject→扔出→喷出）) *-el 【前缀】进入某种状态，使成为【后缀】表小称或缩小 parcel(n.包裹，小包，邮包) *-en n. 半方,字母N【前缀】进入【后缀】起功能转换作用 encage(vt. 关在笼中；禁闭) *-es 【前缀】出自；超出;=ex【后缀】构成复数 escape（vt. 逃避，避免；被忘掉） *-in 在…里面【前缀】不,非,无【后缀】表示“集体活动” inaction(n. 不活动；迟钝) ","date":"2021-08-03","objectID":"https://blog.gethin.online/english-affix-full/:1:0","tags":["english"],"title":"英语词缀","uri":"https://blog.gethin.online/english-affix-full/"},{"categories":["语言与平台"],"content":"前缀(275) 词根词缀 含义 示例 *ab prep. 从, 自【前缀】 表示“偏离，脱离或离开”之义 abuse（滥用(ab+use用=用坏=滥用)） *abs 【前缀】离开，离去 abstract（抽象的,心不在焉的(abs+tract拉=被拉开=心不在焉)） *ac 【词根】酸的；尖锐的【前缀】＝ad-[用于c,k或q前] acid(adj. 酸的；讽刺的；刻薄的) accept(vt. 接受；承认；承担（ac往里，cept拿）) *acro 【前缀】：表示“最高，顶点，开头” acrobat杂技演员 *ad / Ad/ abbr.公元（后）【前缀】表示“向……”之义 adjust（v. 调节; 校正; 改变…以适应; 校准） *af 【前缀】表示动作的开始或结束；转为动词 affect(v 影响,感动(af使+fect=使人做=影响)) *after adv. 后来【前缀】表示“在…后面”，“在…以后” aftercare（n. 安置；病后的照顾调养） *ag / Ag/ a. 农业的【词根】行为；行动【前缀】转为动词 agent(作用因素,代理人(ag+ent表人或物=做的人=代理人)) *am / Am, Em/ 上午【词根】喜爱【前缀】不；无 amateur(n. 业余从事者; 粗通的人; 外行; 爱好者) *amb 【前缀】周围；二者 ambient(a.周围的，包围着的) *ambi 【前缀】二,双 ambition(n.雄心，抱负，野心) *amphi 【前缀】二,双 amphibian（n. 两栖动物, 水陆两用车） *ana / ‘B:nE/ n. 言论集, 语录【前缀】表示相似 analogue(n.类似物；同源语) *anci 【前缀】在前 ancient（a 古代的(anci+ent)） *andr 【前缀】：男 androgyne(n. 具有男女两性的人) *ante / ‘Anti/ n. 赌注vt. 下赌注【前缀】在前；先前,早于 anterior（adj. 前部的, 前面的; 较早的; 以前的; 在前的） *anti n. 反对者【前缀】在前；与post相反；相反；抵抗 anticipate(vt.预料，预期，期望) *ap 【前缀】远，离，分离 apart（adv. 分别地; 分离; 分成零件） *apo 【前缀】远,远离 apology（n 道歉,认错(apo离开+logy=退后一步说=道歉)） *arch / a:tF/ n.拱【词根】首领；统治者【前缀】古代 anarchism（无政府主义的(an无+arch+ism主义)） *arche 【前缀】主要的 archenemy（n. 主要敌人; 魔王; 大敌; 撒旦） *archi 【前缀】原始，旧，原，第一，主要 architect(n. 建筑师; 缔造者, 创造者; 设计师) *arist 【前缀】：最优越 aristocracy（n. 贵族；贵族统治；上层社会；贵族政治） *as / Az, Ez/ 作为【前缀】表示”一再”等加强意 assault(进攻(as+saul跳=跳起来=进攻)) *at / At, Et/ 在…(指时间的某一点)【前缀】转为动词 attain(vt.达到，获得，完成) *auth 【前缀】作者 author(n. 作者；作家；创始人) *be v. 是; 值【词根】居住【前缀】变换为及物动词 tribe(n.部落，宗族) *bene n. 祈祷；祝福【前缀】很好；与mal(e)相反 benefit(n.利益；恩惠；津贴) *bi 【前缀】生命，二 biography传记(bio+graphy写=写生命=传记) *bibl 【前缀】书 bible(n.基督教《圣经》) *bin / bin/n. 箱子，容器；二进制【前缀】双；二 binary（n. 一双, 一对; 二进制数; 双体; 双子星） *bon 【前缀】很好 bonus(n. 奖金; 红利) *bronch 【前缀】：支气管 bronchitis（n. [内科] 支气管炎) *by / bai/ 通过；经过【前缀】副,次要的；附近 bypass(n. 旁路, 支路 ) *caco 【前缀】坏的；不好的 cacophony(n 刺耳的声音(caco刺耳,坏+phony)) *cat / kAt/n.猫【前缀】下面 category(n.种类，类目；范畴) *cata n. 渺位【前缀】下面 catalogue(n目录,一览表(cata下面+logue在下面要说的话=目录)) *centi n. 厘；百分之一【前缀】百,百分之一 centigrade(a.百分度的) *chili n. 干辣椒, 辣椒粉【前缀】千 chiliad(n. 一千年) *circu 【前缀】环绕；在…周围 circuit(n.电路；环行；巡行) *circum n. 环绕，周围【前缀】周围,环绕 circumference(n.圆周，周长，圆周线) *co 【前缀】一起；共同；联合 cognate(a 同族的,同种的(cog同+nate=同出生的=同种的)) *col / kRl/ n. 出口, 山坳【计】 列【前缀】共同 collection(n.搜集，收集；收藏品) *com 【前缀】 表示“一起”、“共同”、“完全” incomplete(a.不完全的，未完成的) *con / kRn/vt. 精读；默记【前缀】表示\"共同” conflict(v 冲突,斗争(con共同+flict=共同打=冲突)) *contra / ‘kRntrE/ n. 反对, 相反【前缀】反对；逆 contravention(n. 违反; 矛盾; 违背) *contro 【前缀】反对；逆 controversy(n.争论，辩论，争吵) *cor 【医】 心脏, 心【词根】心【前缀】一同，合并 correspond(v 符合,通信(cor共同+respond回答=两人互相回答=通信)) *coun 【前缀】国家,全 country(n. 国家; 祖国; 国土; 故乡; 乡村) *counter / 5kauntE/ n.柜台【前缀】反对；逆 counteract(对抗,抵消(counter+act行为=反着行动=对抗)) *countrer 【前缀】:反对,相反 counterclaim(n. 反诉；反对要求) *crypt n. 土窖，地下室；腺窝【前缀】隐藏的 cryptogram(n.密码) *de 【化】 非对映体过量【前缀】去,反,解,往底下 detach(vt. 分离；派遣；使超然(（de分开+tach→把钉子上的分开→拆开）) *deca 【前缀】十 decade(n. 十年，十年期；十) *decem 【前缀】十 December（n. 十二月（古罗马时为十月）） *deci 【计】 十分之一【前缀】十 decimeter(n. [计量] 分米；公寸) *demi adj. 小的，一半的【前缀】半 demigod(n. 受崇拜的人，英雄人物；半神半人) *des 【前缀】脱，去，除，离，解除 dessert(n.甜点心) *di 【词根】日【前缀】二 dial(n.钟面；拨号盘) *dia 【前缀】在两者之间 dialog(n.对话，对白) *dif 【前缀】表示\"不，否定，分开” different(a.差异的；各种的) *dil 【前缀】表示否定、相反或相对；表示分离 dilate（vi. 扩大；膨胀；详述） *dis 【前缀】表示“分开； 分离； 否定； 不”之义 dismiss(vt. 解散；解雇；开除) *do / du:, du/ aux.v.vt.做,干,办【前缀】二；双 dozen(n. 十二个，一打) *dodeca 【前缀】十二 dodecagon（n. [数] 十二边形；十二角形） *du 【计】 定义使用【词根】负债【前缀】二,双 duplicate(n. 复制品) *duo / ‘dju:Eu/ n. 二重唱【前缀】二,双 duodenum(n.十二指肠) *dy 【前缀】：二, 两次, 两倍 dyon(n. [高能] 双荷子) *dys 【医】 不良, 困难, 障碍【前缀】不好的 dyslexia(n.阅读障碍（dys不良+lex+ia病→对词汇不良的病→阅读障碍）) *ec 【前缀】出,除去；超出 eclipse(n. (日，月)食) *ecto 【前缀】外面；…外 ectoderm(n. 外胚层，外细胞层) *ef 【前缀】表示“由…出来，自”之义 effluence(n. 流出；流出物；发射物) *em 【词根】拿；买【前缀】进入某种状态，使成为… enamor(vt. 使迷恋，使倾心) *endo 【前缀】在里面的 endocardial(adj. 心内膜的；心脏内的) *ennea 【前缀】九 enneasyllable(九音节) *enter / 5entE/vt.进入, 加入, 参加【前缀】在中间,肠道 entertain(vt. 娱乐；招待；怀抱(（enter在中间+tain→在[工作]中间拿) *ento 【前缀】在内 entotic（adj.耳中的） *eo 【前缀】黎明；开始 eobiont(n.原生物（生命起源中的一个假想阶段）) *ep 【前缀】在…上面；在…外面 epoch(n.新纪元；新时代；时间上的一点) *epi 【前缀】在…上面；在…外面 epicenter(n. 震中；中心) *eso 【前缀】内；在…里面 esoteric（adj","date":"2021-08-03","objectID":"https://blog.gethin.online/english-affix-full/:2:0","tags":["english"],"title":"英语词缀","uri":"https://blog.gethin.online/english-affix-full/"},{"categories":["语言与平台"],"content":"后缀(266) 词根词缀 含义 示例 -ability / E5biliti/ n.能力；才能【后缀】表示抽象名词 probability(n.可能性；概率) -able / 5eibl/ 能【后缀】表性质、大小状况、状貌 indispensable(a.必不可少的，必需的) -ably adv. 巧妙地【后缀】表副词，“能…地” miserably(ad. 悲惨地,糟糕地) -acal 【后缀】：用以构成的词仅用作形容词，＝-ac maniacal(adj. 疯狂的，狂热的；躁狂的) -ace / eis/ n.(纸牌中的)“A\"牌，爱司【后缀】表示地点 terrace(n.平台，阳台，露台) -acea 【后缀】:某些动物纲名、目名 crustacea(n.甲壳类) -aceae 【后缀】:许多植物科名 pinaceae((pl. )松科) -aceous 【后缀】：表形容词，“具有…特征的” foliaceous(a 叶状的(foli 叶+aceous;参考:foliage树叶)) -acious 【后缀】：表形容词，“有特征的，多…的” sagacious(a 精明的,智慧的(sag+aclous多…的=知道很多的=智慧的)) -acity 【后缀】：表名词，“有…倾向” capacity(n.容量；能力；能量) -acle 【后缀】： 表名词，“…物品，状态” manacle(n 手铐,束缚(man+acle东西=手上的东西=手铐)) -acy 【后缀】：表名词，“性质，状态” intimacy(n. 亲密, 亲昵行为) -ade n.果汁饮料【后缀】表示抽象名词 renegade(n. 背教者, 叛徒, 变节者) -ado n. 忙乱【后缀】构成名词，表示“人”,“物” desperado（n. 亡命之徒，暴徒（de+sper+ado人→无希望之人→亡命徒）） -ae 【后缀】：用于动植物名称后构成动植物科名；构成复数 algae(n. [植] 藻类；[植] 海藻) -age / eidV/ n. 年龄；时代；寿命【后缀】表示抽象名词 hostage(n.人质，抵押品) -ain 【后缀】表示“人” captain(n. 陆军上尉; 空军上尉; 海军上校; 船长; 首领) -aire n. 亚耳河（英国约克郡西部河流）【后缀】表示“人” millionaire(n.百分富翁，巨富) -algia 【后缀】：用于构成名词，表示“痛”，“疼痛” gastralgia(n. [内科] 胃痛) -ality 【后缀】：表名词，“状态，性质” frugality(n. 节约; 节俭; 朴素) -amin abbr. 最小声幅【后缀】表“物质” vitamin(n.维生素，维他命) -ance n. 状态；性质；情况【后缀】表示抽象名词 nuisance(n.讨厌的东西) -ancy 【后缀】表示抽象名词 inerrancy（n 无错误(in无+err+ancy=无错误)） -and conj. 和【后缀】附在动词后构成名词，表示“对象” viand（n. 食物；食品） -ane 【后缀】：构成名词，表示“烷,烷属烃” methane（n. [有化] 甲烷；[能源] 沼气） -aneity 【后缀】：表名词，表示“性质，状态” spontaneity(n. 自发性; 自然发生) -aneous 【后缀】：表形容词，表示“…有；…特征的” simultaneous(adj. 同时的, 同时发生的) -apsis n. 教堂东端之半圆室【后缀】情况，状态：另见-sis periapsis（n. [天] 近拱点） -ard 【后缀】表示“人” coward(n.懦夫；胆怯者) -arian 【后缀】构成形容词或名词 librarian(n. 图书馆员; 图书管理员) -arious 【后缀】：构成形容词，表示“与…有关的” hilarious(adj. 欢闹的；非常滑稽的；喜不自禁的) -arity 【后缀】：名词【后缀】，表示情况 similarity（n. 类似；相似点） -arium 【后缀】：表名词，“地点，场所” vivarium(n. 动物园, 植物园) -art / a:t/ 美术【词根】技巧；艺术【后缀】表示“人” artist(n.艺术家，美术家) -ary n. 氩【后缀】表性质、大小状况、状貌 elementary(a.基本的；初级的) -asm 【后缀】表示抽象名词 enthusiasm(n.热情，热心，热忱) -ass n. 屁股；驴子；蠢人【后缀】表示抽象名词 embarrass(vt.使窘迫，使为难) -ast 【后缀】：表名词，“…人，物” ballast(n. 压载物, 压舱物) -astic 【后缀】：形容词【后缀】，表示“…的” gymnastic（adj. 体操的，体育的） -ate v.eat的过去式【后缀】表示“人” delegate (n 代表(de+leg选+ate…选出来的人 …代表)) -atic 【后缀】：表形容词，“有…性质的” emblematic(adj. 象征的; 标记的) -ation 【后缀】构成抽象名词，表示“动作”,“过程”等 alteration（n. 修改，改变；变更） -ative 【后缀】：表形容词.“有…倾向（性质）的” sedative(n.镇静剂) -ator 【后缀】构成抽象名词，表示“做…动作的人”等 improvisator（n. 即席演奏者；即兴诗人） -atory 【后缀】:表形容词,‘有…性质的’;表名词,‘场所,地点’ propitiatory(adj. 安抚的; 取悦的; 劝解的) -berg / bE:g/ n. 冰山【后缀】山；村庄 iceberg(n. [地理] 冰山；显露部分) -cade n. 杜松【后缀】队伍，行列 motorcade(n. 汽车行列，车队) -ce 【后缀】表示抽象名词 province(n.领域，范围，职权) -cel 动画序列中的单帧【词根】天空【后缀】表小称或“缩小” parcel(n.包裹，小包，邮包) -cele 【后缀】：表示“腔”，“瘤”，“肿”，“膨出”，“疝” blastocele（n. 囊胚腔；分裂腔） -cian 【后缀】：表示人的职业 logician(n. 逻辑学家；论理学者) -cle 【后缀】表小称或“缩小” particle(n.粒子，微粒) -cul 【后缀】耕种,培养 cultivate(v. 培养; 耕作) -cule 【后缀】表小称或“缩小” animalcule(n. 微生物) -dom 【词根】家；房子；驯服；驯服【后缀】表示抽象名词 kingdom(n.王国；领域，界) -eal 【后缀】：形容词【后缀】，表示“似…的” funereal（adj. 悲哀的；送葬的；适合葬礼的） -ean 【后缀】：形容词【后缀】，表示“如…的” gigantean（adj.巨大的，庞大的） -ed 埃德（男名）【词根】吃【后缀】形容词【后缀】 edible(n. 食品, 食物) -ee 【后缀】表示“人” committee(n.委员会；全体委员) -een 【后缀】：构成名词，表示“可爱的人(或物)、小的人(或物)” colleen（n. 姑娘；（爱尔兰）少女） -eer adv.无论何时，曾经【后缀】表示“人” engineer(n. 工程师；工兵；火车司机) -efy 【后缀】：等于fy，表示“…化” liquefy（vt. 液化；溶解） -ella 【后缀】表小称或“缩小” umbrella(n.伞，雨伞) -emia 【后缀】表示“血液” anemia(n. 贫血；贫血症) -ence 【后缀】用于形容词后构成名词，通常是代替-ent existence(n. 存在，实在；生存，生活；存在物，实在物) -ency 【后缀】表示抽象名词,表示性质，状态，情况等 proficiency(n.熟练，精通) -ene 【后缀】：名词【后缀】，表示“烯”类 polyethylene（n. [高分子] 聚乙烯) -enne 【后缀】：表名词，“女性” comedienne(n. 女喜剧演员) -ent 【后缀】表性质、大小状况、状貌 dependent(adj. 依靠的；从属的（de+pend悬挂+ent)) -eous 【后缀】表形容词，“有…的” aqueous(adj. 水成的; 水的) -ept dj.聪明能干的【后缀】表示“适应，能力” adept(adj. 熟练的, 内行的; 拿手的) -er 【后缀】名词【后缀】;动词【后缀】;形容词及副词【后缀】 player(n.游戏的人；比赛者) -ere 【后缀】:指地方 here(adv. 在这里；此时) -erel 【后缀】：名词【后缀】，表示“小称” cockerel(n. （未满一年的）小公鸡；好斗的年轻人) -erly 【后缀】：形容词、副词【后缀】，表示“向…” easterly(adj. 在东方的；向东的) -ern 【后缀】表示方向;表示场所、地点 western(adj. 西方的，西部的；有西方特征的) -ery 【后缀】名词【后缀】,表示地点、状态等 printery（n. 印刷工厂） -esce 【后缀】动词【后缀】，表示“开始发生”，“开始成为” evanesce（vi. 消散；逐渐看不见） -escence 【后缀】:用以构成名词，相当于形容词【后缀】-escent coalescence(n. 合并；联合；接合) -","date":"2021-08-03","objectID":"https://blog.gethin.online/english-affix-full/:3:0","tags":["english"],"title":"英语词缀","uri":"https://blog.gethin.online/english-affix-full/"},{"categories":["语言与平台"],"content":"前缀 方向: ad【朝向】；by【旁边】；epi【旁边】；para【旁边】；circum【周围】；dia【居中】；en;em【进入】；inter;【之间】；per【穿过】；para【旁边】；tele【远距离】；trans【穿越】； de【下降】；hyper【之上】；hypo【之下】；sub;suc;suf;sup【在下方】；super【在上方】；over【上方】； under【下】；up【上】； fore【前面】；pre【前】；pro【向前】；post【后面】；with【向后】；ex;e;ec;ef;exo【向外】；il;im;in;ir【向内】；intro【向内】；intra【里面】；out【外】； ab【相反】；dif【分开】；dis【相反】；ob;op【反】；re【相反】；se【分开】；extra【超出】；sur【超过】； 数字： bi【二】；deca;dec;deci【十】；kilo【千】；octo;octa;octu【八】；tri【三】；twi【二】；hemi【一半】；mon;mono【单一】；multi【多】；poly【多】；uni【单一】； 意义： anti【反对】;arch【主要的；弧形 】；auto【自动】;be【使】；bene【好】；co【共同】；contra【对抗】； eco【生态】；geo【土地】；homo【相同】；mal【坏】；micro【微】mini【小】mis【错误】；sym;syn【共同的】；un【不】； a| 加强 ab;abs| 离开；相反；不 | away;from;not absent| abs+ent abduct| ab+duct abstract| abs+tract abuse| ab+use abnormal| ab+norm+al ab;ac;af;ap;ar;as;at| 加强 |to account accustom ad| 朝向 | to;toward admire| ad+mire adjoin| ad+join advertisement| ad+vert+ise+ment addict| ad+dict adorn| ad+orn anti| 反对 | aggainst antiaircraft| anti+aircraft antigas| anti+gas antimissile| anti+missile arch| 主要的；弧形 | chief architecture| archi+tect+ure archbishop| arch+bishop auto| 自己；自动 | self automatic| auto+matic automobile| auto+mobile autoalarm| auto+alarm be|使；加以；在| make behave beloved bene| 好 | good benefit| bene+fit benefactor| bene+fact+or benediction| bene+dict+ion bi| 二 | two bicycle| bi+cycle binoculars| bi+noculars bilingual| bi+lingu+al by| 旁边 | near byroad| by+road bypass| by+pass byline| by+line circum| 周围；环绕 | around circumambulate| circum+ambul+ate circumnavigate| circum+navigate circumscribe| circum+scribe circumspect| circum+spect circumvent| circum+vent co;com;con;cor;col| 共同；一起 | with;together coherent| co+her+ent combine| com+bine compassion| com+pass+ion congest| con+gest cooperation| co+oper+ation contra;contrp;counter| 反对；对抗 | against contradict| contra+dict contrary| contra+ry controversial| contro+versial counteract| counter+act counterattack| counter+attack de| 去除；下降 | down;away decline| de+cline decrepit| de+crep+it demeaning| de+mean+ing demerit| de+merit demolish| de+mol+ish deca;dec;deci | 十 | ten decade| deca+de decathlete| dec+athlete decible| deci+ble dia| 穿越；居中 | through;between diagnose| dia+gnose dialogue| dia+logue diameter| dia+meter dif| 分开；否定 | difference diffident dis| 相反的 | not disagree| dis+agree discourage| dis+cour+age dishonest| dis+honest dislike| dis+like dismiss| dis+miss eco| 生态；经济 |lift; ecological en;em| 使进入 | in embellish| em+bell+ish embrace| em+brace enclose| en+close enforce| en+force enhance| en+hance epi| 在…旁边；上；后 | epigram| epi+gram epigraph| epi+graph epilogue| epi+logue ex;e;ec;ef;exo| 向外 | out exclude| ex+clude exhale| ex+hale export| ex+port exposure| ex+pos+ure extend| ex+tend extra;extro| 超过 | over;beyond extracurricular| extra+curricul+ar extraordinary| extra+ordin+ary extravagant| extra+vag+ant fore| 前面 | before forearm| fore+arm forecast| fore+cast foredoom| fore+doom forefather| fore+father forehead| fore+head geo| 地；土地 | hemi| 一半 | half hemicycle| hemi+cycle hemisect| hemi+sect hemisphere| hemi+sphere homo| 相同 | of teh same homogenous| homo+genous homologous| homo+log+ous hyper| 在–之上；过度 | over hyperactive| hyper+act+ive hyperbolize| hyper+bol+ize hypercritical| hyper+crit+ical hypo| 在–之下；低于 | under hypogastric| hypo+gastr+ic hypotension| hypo+tens+ion hypothesis| hypo+thesis il;im;in;ir| 向内 | in immerse| im+merse immigrate| im+migrate implant| im+plant impress| im+press imprison| im+prison indoors| in+doors insert| in+sert insight| in+sight insist| in+sist invade| in+vade inter| 在–之间 | between;among interact| inter+act interfere| inter+fere interlace| inter+lace international| inter+nation+al interrupt| inter+rupt intro| 向内 | in introduce| intro+duc+e introvert| intro+vert intra| 在–里面 | in intracity| intra+city intragenic| intra+gene+ic intra-party| intra+party kilo| 千 kilogram| kilo+gram kilometer| kilo+meter kilowatt| kilo+watt mal;male| 坏 | bad malady malfunction| mal-function maltreat| mal+treat micro| 微 | small microorganism| micro+organism microscope| micro+scope","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:1:0","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"后缀 ","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:2:0","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"名词 acy;cy| 状态；特质 accuracy| ac+cur+acy conspiracy| con+spir+acy privacy| priv+acy age| 做；做之后的结果 advantage| ad+vant+age courage| cour+age marriage| marri+age al| 做；做之后的结果 approval| ap+prov+al capital| capit+al disposal| dis+pos+al ance;ence| （抽象）状态；做 assurance| as+sur+ance evidence| e+vid+ence occurrence| oc+curr+ence ancy;ency| （抽象）状态 constancy| con+sta+ancy fluency| flu+ency vacancy| vac+ancy ant;ent| 人；特质 accountant| ac+count+ant detergent| de+terg+ent opponent| op+pon+ent ar;er;or| 人；物 beggar| begg+ar calculator| calculat+or founder| found+er ate| 状态；人；物 advocate| ad+voc+ate certificate| certi+fic+ate illiterate| il+liter+ate action| 行为 accusation| ac+cuse+ation adaptation| ad+apt+ation congratulation| con+gratul+ation dom| 领域；状况 freedom| free+dom kingdom| king+dom wisdom| wise+dom ful| 分量 handful| hand+ful mouthful| mouth+ful ian;an| 人 magician| magic+ian pedestrian| ped+estr+ian vegetarian| vegetar+ian ic;ics| 学科 civics| civ+ics dramatics| dramat+ics dynamics| dynam+ics ice| 行动；状态 malice| mal+ice notice| not+ice prejudice| pre+jud+ice ing| 物；做 blessing| bless+ing earning| earn+ing following| follow+ing ion| 状态；行动 circulation| circu+lat+ion convention| con+vent+ion recession| re+cess+ion ism| 主义；行动 atheism| a+the+ism pessimism| pessim+ism racism| rac+ism ist| 人 chemist| chem+ist dentist| dent+ist terrorist| terror+ist ite| 人；物 appetite| ap+pet+ite dynamite| dynam+ite opposite| op+pos+ite ity;ty| 状态；性质 conformity| con+form+ity maturity| matur+ity novelty| nov+el+ty ive| 有–性质的；人 captive| capt+ive motive| mot+ive native| nat+ive ment| 行为；结果；手段 appointment| ap+point+ment displacement| dis+place+ment document| docu+ment ness| 状态；性质 illness| ill+ness kindness| kind+ness seriousness| serious+ness ory| 地点 factory| fact+ory laboratory| labo+rat+ory territory| terr+it+ory ship| 身份相关；动作 friendship| friend+ship leadership| lead+er+ship relationship| relat+ion+ship ure| 结果；做 departure| de+part+ure failure| fail+ure pleasure| pleas+ure y| 做之后的结果 discovery| dis+cover+y inquiry| in+quir+y mastery| master+y ","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:2:1","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"动词 ate| 导致；引发 en| 导致；使变成 er;or| 做 ify| 导致；引发 ize| 导致；引发 ure| 做 ","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:2:2","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"形容词 able;ible| 能够 al;ial;ical| 特质 ant;ent;ient| 有–性质的 ar;ary| 有–性质的 ate| 有–性质的 ed| 具–的特质 en| 物质 ful| 具有–特质 ic| 特质；–的 ile;ish| 具–特质 ive;ative;itive| 具–特质 less| 没有 ous;eous;ose;ious| 具–特质；和–相关 y| 状态；特质 ","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:2:3","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"副词 ly| 有–特质 ward| 朝–方向 wise| 和–有关 ","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:2:4","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"词根 abl;abili| 能 acid;acri;acrid;acu| 尖酸；锐利 act;ag| 做 aer;aero;aeri| 空气 agri;agro;agr| 田地，农田 alter(n);ali| 其它;改变 am;amor;amat| 爱 ambul| 行走 anim| 气息 ann(u)| 年 aqu| 水 arch(y)| 统治 arm| 武器 art(i)| 技巧 aud(i);audit| 听 aut;auto| 自己 av;avar;avi |渴望；鸟 ball;bol |抛；舞；球 ban| 禁止 bas| 低 bell;bel| 战争；打斗 bio| 生物 brev| 短 cad;cas;cid| 降落 cand| 白光 cant;cent| 唱歌 cap;capt;cept;ceive;cip;cup| 抓取 card;cord| 心脏；一致 cede;ceed;cess| 行进；走；让步 cent(i)| 一百 celer| 快速 centr(i)| 中心 cern;cert;cret| 确定；区别 chron| 长时间 cide| 杀害 close;clude;clus| 关闭 circ;cycl| 圆 civ| 公民 cit| 引用；唤起 claim;clam| 呼喊 clear;clar;clair| 清楚；明白 clin;cliv| 倾斜；斜坡 clos;clud;clus| 关闭 cord| 心 corp;corpor| 身体；团体 cover| 遮盖；盖子 creed;cred| 信任 cre;creas| 增长；产生 cruc;crus;crux| 十字；交叉 crypt| 秘密 cub;cumb| 躺 cur| 关心 dent| 牙齿 derm;dermat| 皮肤 dic;dict| 说；断言 dign| 值得；高贵 doc| 教 don;dit| 给予 du(o);dub;dou(b)| 二，双 dur| 持久；坚硬 duc;duct| 引导，带来 dyn;dynam| 力量 electr| 电 em;empt;ampl| 拿 equ;equi| 相等；平均 erg| 能量；活动 err| 漫游；犯错误 ev|年龄 fabl;fabul| 说 fac(t);fec(t);fic(t)| 做 fall;fail;fault| 犯错误；欺骗 fend;fens| 打击 fer| 带来；拿来 ferv| 热 fid| 相信；信念 fin| 范围；结束 flam;flagr| 火焰 flect;flex| 弯曲 flict| 打击 flor;flour| 花 flu| 流动 fore;fort| 强大 form| 形成；形式 found;fund| 基础 fract;frang| 打碎 frig;friger| 冷 frim| 坚定 fug| 逃 fus| 流；泻 gen(e);gener| 出产；产生；根源 gnos(t);gnor| 知道 gon| 角 grad;gress| 行进 grat;gree| 高兴 grav;griev| 重 greg| 群体 gress| 行走 habit| 居住 hap| 运气 her;hes| 粘附 hibit| 拿住 hydy;hydro| 水 idea;ideo| 思想；观点 imag| 想象 ject| 投掷 jur;juris| 发誓；法律 join(t);junct| 连接，结合 judg;judic| 判断 labor| 劳动 laps| 滑走 lav;luv;lut| 洗；冲洗 lect;lig| 选择；收集 lect;leg| 讲；读 lev;live| 提高；举起；变轻 liber| 自由；考虑 line| 直线；线条 liqu| 液体 liter| 字母；文字 loc| 地方 locu;log;loqu| 说话 long;leng| 长 lingu| 语言 maj| 大,伟大 man(i);manu| 手 mark;marc| 记号，符号 med(i);mid| 中间 mend| 修改 miss;mit| 发送 mount| 登上，升 mun(i)| 公共的 neg| 否认，拒绝 norm| 规则 nounc(i)| 讲，说 nov| 新的 oper| 工作 opt| 选择，视力，眼 part| 部分，分开 pass| 走，通过 part(i)| 父亲，祖国 pear| 看见 ped 足 pel;puls| 驱动，推 pend| 悬挂 phon(o)| 声音，嗓音 physi(o)| 自然 pict| 绘 place| 地方 plant| 种植 ple;plen(t);plet| 满，填满 port| 拿，运；部分，分开 prehend;prehens| 抓 press| 挤压；逼迫 prim;prem;prin| 第一，主要的 priv| 单个 proach;proxim| 接近靠近 prob;prov| 证明 prot| 运送；携带 pose| 放置 press| 按压 psych(o)| 心理，精神 quaint| 知道 quest;quir;quis;quer| 寻求，获得 quot| 引用；数目 radi| 光线 range| 行列；顺序 rest| 停留 rect;reg| 正，直 rud| 天然的，原始的 rupt| 破，断裂 san;sanit| 健康的 sacr| 神圣的 sati;satis;satur 足够的 scop| 观察，看；镜 scrib;script| 写 sect;seg| 切，割 secu;sequ;sue| 追随 sens;sent| 感觉；保持 set| 放，安置 sess;sid| 坐 sign| 记号，信号 simil;simul(t);sembl| 类似，一样 sist;sta| 站立 soci| 同伴；社会 sol(i)| 单独；太阳 spec(i)| 外观；种类 soect;spic;spec| 看 spher(o)| 球 spond;spons| 承诺，约定 st;sta(n);stant;stat| 站，立 stall| 放 strain;strict;string| 拉紧 struct| 建造，建立 sum;sumpt| 拿，取 sum(m)| 加 sur| 肯定；安全 tact;tag| 接触 tail| 剪切 tain;ten;tin| 拿住 techn(o)| 技术，技艺 tect| 盖上 tele| 远；电 temper;tempor| 时间或事件引起的现象 tend;tens| 伸展 test(i)| 测试，证据 them(o)| 热 toler| 容忍 touch| 摸碰 tort| 扭转 tract| 拉，拖 treat| 处理 tribute| 给予 trude;truse| 推 urb| 城市 vac;void| 空；缺乏 vail;val(u)| 价值，之，强壮 vers;vert| 转 view;vis;vid| 看；分开 viv(i);vit;vig| 生命 vol;volunt| 意志，意愿 ","date":"2021-08-01","objectID":"https://blog.gethin.online/english-affix-root/:3:0","tags":["english"],"title":"英语词根词缀","uri":"https://blog.gethin.online/english-affix-root/"},{"categories":["语言与平台"],"content":"必考核心词！378个雅思高频听力单词词汇表 引用：https://ieltsonlinetests.com/zh-hans/listening-tips/378-high-frequency-words-ielts-listening 0 1 2 3 4 校园类 图书馆 Shelf Librarian The stacks Return Fine Magazine Copier Overdue Reading room Reference room Periodical room Study lounge Catalogue Index Keyword Volume Library card Book reservation Periodical Quarterly Back issue Current issue Latest number Writing permission Check out Put on reserve 学生 Freshman Sophomore Junior student Senior student Bachelor Master Doctoral candidate Alumni/alumnus Post doctorate 老师 Lecturer Associate professor Supervisor Professor Dean Teaching assistant 上课及选课 Take the course Credit Register Drop the course Introductory course Advanced course Rank Syllabus Curriculum Seminar Elective/optional course Compulsory course Drop-out Makeup exam Psychology course Physics Computer course Computer science 读书 Book review Novel Press Publisher Publication Biography Editorial Extra copy Paperback edition Out of print Read selectively Get through a novel Plough through Read extensively 课余活动 Devote to Run for Candidate Vote Conflict Election campaign Campaign manager Participant The student’s union Chairman Speech contest Enroll Sign up for 生活交际类 购物消费 Convenience store Department store Mall Chain store Shopping list Supermarket Family size Receipt Outlet On sale Sell out Grocery store Out of stock In stock Customer Complaint Deliver Counter Closing time Balance Luxurious items Electronic product Stationery Digital video camera Past the prime 居家琐事 Housework Electric cooker Laundry Iron Vacuum cleaner Housemaid Housekeeper Housewife Keep an eye on Household expenses Keep down the cost Fix the dinner Budget In a mess Economical 日常交往 Leisure time Telephone booth Date Pay phone Call on sb. Long-distance call Take a message Hang up Keep contact Hold on Hospitable 工作商务类 求职面试 Job hunting Inexperienced Opportunity Want ads Unemployment Position Wage Opening/vacancy Full-time job Part-time job Inquiry Do odd jobs Consult Resume Application letter Fire Hire Recruit Interview Job-hopping Interviewee Take over Interviewer Appointment Impression Confident Turn down Have no match for 工作往来 On business Be involved in Appointment In charge of Client Compromise Get along with Proposal Assistance Branch Cooperation Transaction Bid Transfer 工作态度 Attitude Personality Overwork Determined Forgetful Diligent Wear out Perseverance Hang on Workaholic Workload Struggle Continuous exploration Hard-working 工作业绩 Recognition Tribute Achievement Pioneer Blaze a trail Symbol Legend 娱乐休闲类 文化艺术 Napkin Beverage Gardening Excursion Performance TV channels Horror movie Broadcast Live broadcast Documentary Violence movie Commercial advertisement Entertainment industry TV theater 外出就餐 Waiter/waitress Pork Beef steak Menu Raw Medium Done Dessert Snack Join sb. for dinner Appetizer Make a reservation Cutlery Loaf Buffet Staple Go dutch Regular dinner Mutton Change 个人健康类 疾病和症状 Epidemic Sore throat Bird flu Runny nose SARS Stomachache Infectious illness Toothache Symptom Allergy Sneeze Fracture Diabetes Have a temperature Dental decay 医院和医生 Attending/chief doctor consultant Infirmary Physician Surgeon Clinic Anesthetist 减肥锻炼 Put on weight Watch your diet Overweight On diet Lose weight Physical exercise 身体状况 In good shape In a fit state Out of shape Fit as a fiddle In poor shape Feel under the weather 旅行交通类 Travel agency Flight number Check in Motel Book the ticket Platform Hiking Hitch-hike Conductor Skiing Mineral bath Streetcar Resort Visa Express train High-speed train Shuttle Ferry Tube/underground Expressway/freeway Roundtrip 热点话题类 Prosperous Decline Depression Recession Collapse Bankrupt Monetary Circulation Financier Surplus Inflation Deflation Economic crisis Potential Cyberspace Multimedia Hacker Server 气象环境类 Recycled water Renewable energy Sewage treatment Recyclable Deforestation rate Water and soil erosion Temperature Muggy Humidity Breeze Climate trend Climate variation Climate warming Climate watch Climate-sensitive ac","date":"2021-07-23","objectID":"https://blog.gethin.online/ielts-usually/:1:0","tags":["english"],"title":"Ielts Usually","uri":"https://blog.gethin.online/ielts-usually/"},{"categories":["语言与平台"],"content":"Ielts Words 3 Words 注： 不给原翻译，是为了进行联想推意义 aim -\u003e target ash -\u003e dust bay -\u003e baby: take baby to bay bet -\u003e beg /have a bet bid -\u003e bed: I bid for a bed. bow -\u003e bowl: 碗比较圆，半圆就是弓 bud -\u003e growth/ tree is bud cab -\u003e car: the cab of car dam -\u003e dam up: 坝起——阻拦 dew -\u003e drew: 画画要用水滴 dim -\u003e dark dip -\u003e drop dye -\u003e ink/red dye era -\u003e age flu -\u003e ill fry -\u003e dry: 炸干 fry checkin fur -\u003e skin gap -\u003e GAP gas -\u003e 瓦斯的音译 gum -\u003e 路飞 ham -\u003e 汉姆有非常厉害的腿-\u003e 火腿 hay -\u003e hey/dry grass hut -\u003e hurt: 受伤的心屋 ink -\u003e link：用墨水链接 inn -\u003e in hotal jaw -\u003e 教（训） jet -\u003e 路飞 喷气机关枪 jew -\u003e Jesus jog -\u003e dog jog lag -\u003e delay /lag behind lap -\u003e the lap of cap lid -\u003e cap/ tge lid of bottle lip -\u003e talk mat -\u003e Matt sit in the mat mop -\u003e 抹布 mud -\u003e 脏 mug -\u003e 马克杯 nap -\u003e cat nap/have a nap nod -\u003e knowed nor -\u003e not oak -\u003e 奥克tree oar -\u003e all oar/the oar of boat odd -\u003e (even in math) 1,3,5,7,11 ore -\u003e oar 船桨敲矿石 owl -\u003e bowl 带枭图案的碗 pin -\u003e 钉 pit -\u003e p it/dig it pot -\u003e hot pot rag -\u003e tag the rag raw -\u003e crude rib -\u003e rid rib rid -\u003e rider/remove rob -\u003e stick-up rod -\u003e power/wood rot -\u003e rod rot / decay rub -\u003e mop /rub away =remove rug -\u003e hug/footcloth sew -\u003e saw / seam sin -\u003e 贼 sly -\u003e sly spy sob -\u003e cry sow -\u003e slow/sow seed tan -\u003e brown/谈棕色 tin -\u003e tin can tip -\u003e keys ton -\u003e 吨 tub -\u003e bucket van -\u003e pioneer/car vex -\u003e 维克斯和维特 via -\u003e through a place wag -\u003e dog wags its tail wax -\u003e max / Candle wit -\u003e brain ","date":"2021-07-13","objectID":"https://blog.gethin.online/ielts-words-3-words/:1:0","tags":["english"],"title":"Ielts Words 3 Words","uri":"https://blog.gethin.online/ielts-words-3-words/"},{"categories":["语言与平台"],"content":"英语六种构词法 派生法 英语构词法中在词根前面加前缀或在词根后面加后缀，从而构成一个与原单词意义相近或截然相反的新词的方法叫作派生法。 前缀 除少数英语前缀外，前缀一般改变单词的意义，不改变词性；英语后缀一般改变词类，而不引起词义的变化。 表示否定意义的前缀常用的有dis-, il-, im-, in-, ir-, mis-, non-, un-等，在单词的前面加这类前缀常构成与该词意义相反的新词。例如： agree同意→disagree不同意 fair公平的→unfair不公平的 possible可能的→impossible不可能的 understand理解→misunderstand误解 表示其他意义的前缀常用的有a-(多构成表语形容词), anti- (反对；抵抗), auto- (自动), co- (共同), en- (使), inter- (互相), re- (再；又), sub- (下面的；次；小), tele- (强调距离)等。例如： co-worker 同事，帮手 enlarge 使变大 cooperate 合作 rewrite 重写 subway 地铁 后缀 给单词加后缀也是英语构词的一种重要方法。后缀通常会改变单词的词性，构成意义相近的其他词性；少数后缀还会改变词义，变为与原来词义相反的新词。下面仅作简单介绍。 构成名词的后缀常用的有-ence，-(e)r/ -or (从事某事的人),-ese (某地人)，-ess (雌性)，-ian (精通……的人)，-ist (专业人员)，-ment (性质；状态)，-ness (性质；状态)，-tion(动作；过程)等。例如： differ不同于→difference区别 write写→writer作家 China中国→Chinese中国人 act表演→actress女演员 music音乐→musician音乐家 构成动词的后缀常用的有-(e)n (多用于形容词之后)，-fy (使……化)，-ize (使……成为)。例如： wide→widen加宽 beauty→beautify美化 pure→purify提纯 real→realize意识到 organ→organize组织 sharp→sharpen使变锋利 构成形容词的后缀常用的有-al，-able (有能力的)，-(a)n(某国人的)，-en (多用于表示材料的名词后)，-ern (方向的)，-ese(某国人的)，-ful，-(ic)al，-ish，-ive，-less (表示否定)，-like (像……的)，-ly，-ous，-some，-y (表示天气)等。例如： nature自然→natural自然的 reason道理→reasonable有道理的 America美国→American美国的 China中国→Chinese中国人的 gold金子→golden金的 east东→eastern东方的 child孩子→childish孩子气的 snow雪→snowy雪的 构成副词的常用后缀有-ly (主要用于形容词之后表示方式或程度)，-ward(s) (主要用于表示方位的词之后表示方向)。例如： angry生气的→angrily生气地 to到→towards朝……，向…… east东方→eastward向东 构成数词的后缀有-teen (十几)，-ty (几十)，-th (构成序数词)。例如： six六→sixteen十六→sixteenth第十六 four四→forty四十→fortieth第四十 合成法 英语构词法中把两个单词连在一起合成一个新词，前一个词修饰或限定后一个词，这样的方法就是合成法。 合成名词 名词＋名词 weekend 周末 名词＋动词 daybreak 黎明 名词＋动名词 handwriting 书法 名词＋及物动词＋er／or pain-killer 止痛药 名词＋介词＋名词 sister-in-law 嫂子 代词＋名词 she-wolf 母狼 动词＋名词 typewriter 打字机 动名词＋名词 reading-room 阅览室 现在分词＋名词 flying-fish 飞鱼 形容词＋名词 freshman 大一新生 副词＋动词 outlook 景色，风光 介词＋名词 afterbrain 后脑 合成形容词 名词＋形容词 bloodred 血红的 名词＋现在分词 French-speaking 讲法语的 名词＋to＋名词 one-to-one 一对一的 名词＋过去分词 man-made 人造的 数词＋名词 one-way 单行道的 数词＋名词＋形容词 three-year-old 三岁的 数词＋名词＋ed ten-storeyed 十层的 动词＋副词 one-off 一次性的 形容词＋名词 high-quality 高质量的 形容词＋名词＋ed noble-minded 高尚的 形容词＋形容词 light-green 浅绿色的 形容词＋现在分词 ordinary-looking 相貌一般的 副词＋形容词 ever-green 常青的 副词＋现在分词 hard-working 辛勤的 副词＋过去分词 well-known 著名的 副词＋名词 fast-food 专门提供快餐服务的 介词＋名词 indoor 室内的 合成动词 名词＋动词 sleep-walk 梦游 形容词＋动词 white-wash 粉刷 副词＋动词 overwhelm 压倒，制服 合成副词 形容词＋名词 hotfoot 匆忙地 形容词＋副词 everywhere 到处 副词＋副词 however 尽管如此 介词＋名词 beforehand 事先 介词＋副词 forever 永远 合成代词 代词宾格＋self herself 她自己 物主代词＋self myself 我自己 形容词＋名词 anything 一切 合成介词 副词＋名词 outside 在……外面 介词＋副词 within 在……之内 副词＋介词 into 进入 混合法 英语构词还可以将两个词混合或各取一部分紧缩而成一个新词，前半部分表属性，后半部分表主体。这样的英语构词法就是混合法。 ex. news broadcast→newscast 新闻广播 television broadcast→telecast 电视播送 smoke and fog→smog 烟雾 photo and graphy→photography 摄影，摄影术 helicopter airport→heliport 直升飞机场 转化法 英语构词法中把一种词性用作另一种词性而词形不变的方法叫作转化法，有的名词可以作动词，有的形容词可以作副词或动词。 1. 动词转化为名词 1. **意思没有变化**，例如：I think we'd better finish the talk now.我想我们的谈话最好现在结束。 2. **意思有一定变化**，例如：He is a man of strong build.他是一个体格健壮的汉子。 3. **构成短语**，例如：Let's have a look first. 我们先看一下吧。 2. 名词转化为动词 1. **表示物体的**，如：Have you booked the ticket?你订好票了吗? 2. **表示身体部位的**，如：Hand in your papers please.请把你们的试卷交上来。 3. **表示一类人的**，如：She nursed her husband back to health.她看护丈夫，使他恢复了健康。 4. **抽象名词**，如：We breakfasted together.我们在一起吃了早餐。 3. 形容词转化为动词 **少数形容词可以转化为动词**。例如：We will try our best to better our living conditions.我们要尽力改善我们的生活状况。 4. 副词转化为动词 **有少数副词可以转化为动词**。例如：Murder will out.恶事终必将败露。 5. 形容词转化为名词 1. **表示颜色的形容词常可转化为名词**，如：The girl in black appears very beautiful.那个穿黑衣服的女孩子看上去非常漂亮。 2. **一些形容词如old, young, poor, rich, wounded, injured等与the连用，表示一类人，作主语时，谓语用复数**，如：We don't belong to the rich, but we dong't belong to the poor either. 我们不是有钱人，但我们也不是穷人。 截短法 将单词缩写，词义和词性保持不变的英语构词法称为截短法，主要有截头、去尾、截头去尾等形式。 1. 截头 telephone→phone airplane→plane 2. 去尾 mathematics→maths examination→exam kilogram→kilo laboratory→lab taxicab→taxi 3. 截头去尾 influenza→flu refrigerator→fridge 缩写法 用单词首尾字母组成一个新词的英语构词法叫做首尾字母缩略法。这种形式的英语构词生成的新词，读音主要有两种形式，即各字母分别读音；作为一个单词读音。 ex. Testing of English as a Foreign Language→TOEFL托福 Teach English ","date":"2021-07-12","objectID":"https://blog.gethin.online/language-and-platformlanguage-and-platform/:0:1","tags":["english"],"title":"英语构词法","uri":"https://blog.gethin.online/language-and-platformlanguage-and-platform/"},{"categories":["语言与平台"],"content":" -- ","date":"2021-07-12","objectID":"https://blog.gethin.online/ielts-words/:0:0","tags":["english"],"title":"Ielts Words","uri":"https://blog.gethin.online/ielts-words/"},{"categories":["语言与平台"],"content":"雅思词汇 学习方法，先从3，4，5，6，7个字母开始背， 后面的直接使用构词法来进行背诵。 ","date":"2021-07-12","objectID":"https://blog.gethin.online/ielts-words/:1:0","tags":["english"],"title":"Ielts Words","uri":"https://blog.gethin.online/ielts-words/"},{"categories":["语言与平台"],"content":"3字母 (238个) 0 1 2 3 4 5 6 7 8 9 dot sit row rot ash cup let ill cap rag ski not eve pot dog bay sew yes jaw god fog big son tin via bee six get ore sex you eye wag two flu wit jet too hug jew sea few out bow tie any mat per hut era arm boy win ice gun cow ant spy may van now pan cut lab web tap rod tag sad jar toe bed bit put fan fit gay map rob low oil rug oak fix old oar bet lot fur one wax job day sly inn car rid fee can lie sky pay hey sir top die try hit gum net egg vex lay ink say tub pit tax pie rat gas pen see end joy tip bud fry way dim log sin jog cat him buy pet cry but mad use lap new fat zip its ton war man beg nut lip saw far dad ham act ago tan sow yet why mop mug dye aid nap eat bar her fox bad raw ask toy fun hen box owe ear dry pin bus wet run pop sun tea owl law may aim nod sob sum pig bat lid fly mix nor how air own who all dam gap hay dip hat shy bag jam age ten set lag ray key bid kid odd due dig our hot mud art zoo leg his she cab rib add rub dew https://blog.gethin.online/ielts-words-3-words/ ","date":"2021-07-12","objectID":"https://blog.gethin.online/ielts-words/:1:1","tags":["english"],"title":"Ielts Words","uri":"https://blog.gethin.online/ielts-words/"},{"categories":["语言与平台"],"content":"4字母 0 1 2 3 4 5 6 7 8 9 pray tuna sway lame mess evil near dear whip lift fear bear turn coal most hour bang lamb past than tick luck noun baby wool gate pant loom joke cube mist shun full bowl each unit foot cafe heal zero seem area dash plug roll wall mean weep seed sock buzz chip neat sore poem toss rare bald whom some foam drop sign spin sink rail oral pest twin idea clue feed pear head tidy crop mend veto kite move sift hair keen dark wide fist pink tray shot thus levy stew mast moan milk film goat snob curb song army horn trip wake yawn folk glow fail stem duck deem rude bake slit back push germ undo loop feud sick calm vein hind once poet cone loan edit vain noon amid such hold tarp link roof user pore deer hard clap arch like rest heed earl ajar body cape snap skin watt task flow onto cite zone lace play soap hang bean moth bird ward bull gust bank fast tape wild disc dung sour tyre just king rain name damp mile fowl poll rise pork lazy plot pair thin navy yolk meal pump emit pond grin upon this cool what born solo snow dust spot knob wing male boss come beef rack dock left glad mock help copy mute lawn ever comb land clip inch open wine warm drag corn fair mark reed tail meat leak miss sack care hush soul fare bell gram cent file vest dine leap tame size self firm risk plus sure team diet defy well doom side hero make band loud heel lime limp tile dive chew bent memo veil cope drip acid want wave show heat grim draw hull fish soar chop cell halt grab flag deal Arab kilo duke swim knot brow sake cash data doze mode bark kiss your wife main vast suck cook core tell home hint daze town look obey week tram goal coil fork hate grip drug tent mass pick more gulf iron calf wrap cage nice bony with pain drum fool pint cart hand gown coin soon even menu over gaze same nine item heap edge norm know talk roam cave shop lend lion claw hawk lick reel deaf knit deed pool into quiz pawn cost seek dawn none shut dare fact crow fort bite slam boil send puff jump jeep exit mate blue year ripe pave weak from pour jack vase crew tiny fold bend dish ","date":"2021-07-12","objectID":"https://blog.gethin.online/ielts-words/:1:2","tags":["english"],"title":"Ielts Words","uri":"https://blog.gethin.online/ielts-words/"},{"categories":["云上漫谈"],"content":" 云上基础架构 Iaas \u0026 Paas \u0026 Saas 虚拟机和容器 Docker \u0026 Kubernetes 基础架构的关注点 Azure Kubernets Service - AKS ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:0:0","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"Iaas \u0026 Paas \u0026 Saas IaaS 基础架构即服务， 硬件相关的部分由第三方运营，如服务器，存储，网卡等。其他由拥有者来维护。 PaaS 平台即服务，部分与应用无关的部分由第三方运营，自己的应用程序是基于第三方提供的平台来进行开发维护，但数据和应用程序由拥有者本人来进行管理。 SaaS 软件即服务，将所有的部分都交给第三方管理，拥有者本身只需要基于应用程序进行配置或是二次开发。 啥是 azure-paas ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:1:0","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"虚拟机和容器 虚拟机，用传统开发和部署的方式来运行在服务器上，如IIS，Tomcat等 为什么要选用容器，容器有什么优势么？ 平台独立，一次build，可以运行在各个平台。 资源的效率和利用率比较高 有效的隔离性和可分享性 速度很快，可以在短时间内进行创建，复制和销毁 可以实现平滑的伸缩 操作便捷 改进开发人员的生产力和开发流程 语言独立性 ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:2:0","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"Docker \u0026 Kubernetes Docker是时下流行的来实现容器的一种方式。关于容器编排，市场上还有其他的方式，如Azure Service Fabric，Amazon Elastic Container Service 那么我们为什么要选用K8S? 容器编排 非常适合采用多云方式进行 大规模部署和更新应用程序，以加快产品上市时间（水平自动缩放，滚动更新，Canary部署） 天然支持云原生应用 降低基础设施成本 它可以在本地或混合环境中运行 您可以将Kubernetes集群从一个托管供应商移动到另一个托管供应商，而无需更改（几乎）任何部署和管理过程。 零停机时间部署，容错，高可用性，扩展，调度和自愈功能在Kubernetes中具有重要价值。 ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:3:0","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"基础架构的关注点 服务注册 服务发现 监控 限流 路由 负载均衡 超时重试 熔断 服务降级 故障迁移 ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:4:0","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"Azure Kubernets Service -AKS ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:5:0","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"1. 第一步 AKS云原生基本概念 - Key Words Pod: K8S 基本单位，一个Pod相当于一个容器 Node： 一个节点相当于一台服务器 Replication Controller： 弹性伸缩管理器 Service 服务，作为K8S内部调用的一个服务，使用标签选择符标识的一组Pod Namespace，命名空间，逻辑隔离级别 Ingress，应用程序入口，通常用来将内部service公开给外部使用的路由。 Deployment，一个 Deployment 控制器为 Pods和ReplicaSets提供声明式的更新能力。 StatefulSet 用来管理 Deployment 和扩展一组 Pod，并且能为这些 Pod 提供_序号和唯一性保证_。 DaemonSet 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。 Job 会创建一个或者多个 Pods，并确保指定数量的 Pods 成功终止 ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:5:1","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"2. 使用三方组件来改进系统 Helm, Traefik, Kubeapps, Prometheus, Grafana, ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:5:2","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":["云上漫谈"],"content":"3. 使用服务网格 (Istio) 来进行微服务管理 Gateway \u0026 Virtual Service Cert Kiali \u0026 Grafana 使用 CI/CD 来部署你的系统. Azure DevOps Scaling 智能路由与金丝雀发布 https://docs.microsoft.com/en-us/azure/aks/servicemesh-istio-scenario-routing?pivots=client-operating-system-linux ","date":"2021-07-08","objectID":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/:5:3","tags":["云上漫谈","Kubernetes"],"title":"云上基础架构","uri":"https://blog.gethin.online/introduce-microservice-infrastructure-on-cloud/"},{"categories":[],"content":"架构师论文摘要（自用） https://www.cnblogs.com/significantfrank/archive/2012/10/22/4875837.html ","date":"2021-07-08","objectID":"https://blog.gethin.online/architecture-paper/:1:0","tags":["架构"],"title":"架构师论文摘要","uri":"https://blog.gethin.online/architecture-paper/"},{"categories":["语言与平台"],"content":"CSS 语法 /*这是个注释*/ p {color:red;text-align:center;} ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:1:0","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"CSS 选择器 ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:2:0","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"id选择器 #para1 { text-align:center; color:red; } ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:2:1","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"class 选择器 .center {text-align:center;} ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:2:2","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"css样式表 ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:0","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"外部样式表(External style sheet) /* mystyle.css */ hr {color:sienna;} p {margin-left:20px;} body {background-image:url(\"/images/back40.gif\");} /* html*/ \u003chead\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"\u003e \u003c/head\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:1","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"内部样式表(Internal style sheet) \u003chead\u003e \u003cstyle\u003e hr {color:sienna;} p {margin-left:20px;} body {background-image:url(\"images/back40.gif\");} \u003c/style\u003e \u003c/head\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:2","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"内联样式(Inline style) \u003cp style=\"color:sienna;margin-left:20px\"\u003e这是一个段落。\u003c/p\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:3","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"多重样式优先级 （内联样式）Inline style \u003e （内部样式）Internal style sheet \u003e（外部样式）External style sheet \u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:4","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"盒子模型 ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:5","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"分组选择器 h1,h2,p { color:green; } ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:6","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"嵌套选择器 p{ }: 为所有 p 元素指定一个样式。 .marked{ }: 为所有 class=\"marked” 的元素指定一个样式。 .marked p{ }: 为所有 class=\"marked” 元素内的 p 元素指定一个样式。 p.marked{ }: 为所有 class=\"marked” 的 p 元素指定一个样式。 p { color:blue; text-align:center; } .marked { background-color:red; } .marked p { color:white; } p.marked{ text-decoration:underline; } ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:7","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"隐藏元素 visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。 display:none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 块元素是一个元素，占用了全部宽度，在前后都是换行符。 内联元素只需要必要的宽度，不强制换行。 块元素：\u003ch1\u003e \u003cp\u003e \u003cdiv\u003e 内联元素 \u003cspan\u003e \u003ca\u003e 如何改变一个元素显示 li {display:inline;} span {display:block;} ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:8","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"Position(定位) static 定位 HTML 元素的默认值，即没有定位，遵循正常的文档流对象。 fixed 定位 元素的位置相对于浏览器窗口是固定位置。 即使窗口是滚动的它也不会移动。 relative 定位 相对定位元素的定位是相对其正常位置。 absolute 定位 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于\u003chtml\u003e。 sticky 定位 sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。 position: sticky; 基于用户的滚动位置来定位。 粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。 重叠的元素 元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素 z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面） ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:9","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"Float(浮动) CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。 img { float:right; } 元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。 .text_line { clear:both; } ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:10","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"CSS 布局 - 水平 \u0026 垂直对齐 元素居中对齐： margin: auto; 文本居中对齐: text-align: center; 图片居中对齐：margin: auto; 左右对齐 - 使用定位方式: position: absolute;right: 0px; 左右对齐 - 使用 float 方式：float: right; 垂直居中对齐 - 使用 padding: padding: 70px 0; text-align: center 垂直居中 - 使用 line-height: line-height: 1.5; 垂直居中 - 使用 position 和 transform：position: absolute;transform: translate(-50%, -50%); ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:11","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"组合选择符 后代选择器(以空格 分隔) 子元素选择器(以大于 \u003e 号分隔） 相邻兄弟选择器（以加号 + 分隔） 普通兄弟选择器（以波浪号 ～ 分隔） ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:12","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"伪类(Pseudo-classes) \u0026 伪元素 selector:pseudo-class {property:value;} selector:pseudo-element {property:value;} ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:13","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"导航栏、下拉菜单、提示工具、图片廊、图像透明、图像拼合、表单、网页布局 参考：https://www.runoob.com/css/css-navbar.html ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:14","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"属性选择器 [title] { color:blue; } ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:3:15","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"CSS 基础 属性 描述 CSS 背景 background 简写属性，作用是将背景属性设置在一个声明中。 background-attachment 背景图像是否固定或者随着页面的其余部分滚动。 background-color 设置元素的背景颜色。 background-image 把图像设置为背景。 background-position 设置背景图像的起始位置。 ackground-repeat 设置背景图像是否及如何重复。 CSS 文本格式 color 设置文本颜色 direction 设置文本方向。 letter-spacing 设置字符间距 line-height 设置行高 text-align 对齐元素中的文本 text-decoration 向文本添加修饰 text-indent 缩进元素中文本的首行 text-shadow 设置文本阴影 text-transform 控制元素中的字母 unicode-bidi 设置或返回文本是否被重写 vertical-align 设置元素的垂直对齐 white-space 设置元素中空白的处理方式 word-spacing 设置字间距 CSS字体 font 在一个声明中设置所有的字体属性 font-family 指定文本的字体系列 font-size 指定文本的字体大小 font-style 指定文本的字体样式 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 指定字体的粗细。 链接样式 a:link 正常，未访问过的链接 a:visited 用户已访问过的链接 a:hover 当用户鼠标放在链接上时 a:active 链接被点击的那一刻 CSS列表属性 list-style 简写属性。用于把所有用于列表的属性设置于一个声明中 list-style-image 将图像设置为列表项标志。 list-style-position 设置列表中列表项标志的位置。 list-style-type 设置列表项标志的类型。 CSS 盒子模型 Margin(外边距) 清除边框外的区域，外边距是透明的。 Border(边框) 围绕在内边距和内容外的边框。 Padding(内边距) 清除内容周围的区域，内边距是透明的。 Content(内容) 盒子的内容，显示文本和图像。 CSS 边框属性 border 简写属性，用于把针对四个边的属性设置在一个声明。 border-style 用于设置元素所有边框的样式，或者单独地为各边设置边框样式。 border-width 简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。 border-color 简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。 CSS 尺寸 height 设置元素的高度。 line-height 设置行高。 max-height 设置元素的最大高度。 max-width 设置元素的最大宽度。 min-height 设置元素的最小高度。 min-width 设置元素的最小宽度。 width 设置元素的宽度。 CSS Overflow visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。 CSS 伪类 :checked 选择所有选中的表单元素 :disabled 选择所有禁用的表单元素 :empty 选择所有没有子元素的p元素 :enabled 选择所有启用的表单元素 :first-of-type 选择的每个 p 元素是其父元素的第一个 p 元素 :in-range 选择元素指定范围内的值 :invalid 选择所有无效的元素 :last-child 选择所有p元素的最后一个子元素 :last-of-type 选择每个p元素是其母元素的最后一个p元素 :not(selector) 选择所有p以外的元素 :nth-child(n) 选择所有 p 元素的父元素的第二个子元素 :nth-last-child(n) 选择所有p元素倒数的第二个子元素 :nth-last-of-type(n) 选择所有p元素倒数的第二个为p的子元素 :nth-of-type(n) 选择所有p元素第二个为p的子元素 :only-of-type 选择所有仅有一个子元素为p的元素 :only-child 选择所有仅有一个子元素的p元素 :optional 选择没有\"required\"的元素属性 :out-of-range 选择指定范围以外的值的元素属性 :read-only 选择只读属性的元素属性 :read-write 选择没有只读属性的元素属性 :required 选择有\"required\"属性指定的元素属性 :root 选择文档的根元素 :target 选择当前活动#news元素(点击URL包含锚的名字) :valid 选择所有有效值的属性 :link 选择所有未访问链接 :visited 选择所有访问过的链接 :active 选择正在活动链接 :hover 把鼠标放在链接上的状态 :focus 选择元素输入后具有焦点 :first-letter 选择每个\u003cp\u003e 元素的第一个字母 :first-line 选择每个\u003cp\u003e 元素的第一行 :first-child 选择器匹配属于任意元素的第一个子元素的 \u003cp\u003e 元素 :before 在每个\u003cp\u003e元素之前插入内容 :after 在每个\u003cp\u003e元素之后插入内容 :lang(language) 为\u003cp\u003e元素的lang属性选择一个开始值 CSS伪元素 :link 选择所有未访问链接 :visited 选择所有访问过的链接 :active 选择正在活动链接 :hover 把鼠标放在链接上的状态 :focus 选择元素输入后具有焦点 :first-letter 选择每个\u003cp\u003e 元素的第一个字母 :first-line 选择每个\u003cp\u003e 元素的第一行 :first-child 选择器匹配属于任意元素的第一个子元素的 \u003cp\u003e 元素 :before 在每个\u003cp\u003e元素之前插入内容 :after 在每个\u003cp\u003e元素之后插入内容 :lang(language) 为\u003cp\u003e元素的lang属性选择一个开始值 媒体类型 all 用于所有的媒体设备。 aural 用于语音和音频合成器。 braille 用于盲人用点字法触觉回馈设备。 embossed 用于分页的盲人用点字法打印机。 handheld 用于小的手持的设备。 print 用于打印机。 projection 用于方案展示，比如幻灯片。 screen 用于电脑显示器。 tty 用于使用固定密度字母栅格的媒体，比如电传打字机和终端。 tv 用于电视机类型的设备。 计数器 content 使用 ::before 和 ::after 伪元素来插入自动生成的内容 counter-increment 递增一个或多个值 counter-reset 创建或重置一个或多个计数器 ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:4:0","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"CSS3 基础 ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:5:0","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"图片、按钮、分页、框大小、弹性盒子、多媒体查询 参考：https://www.runoob.com/css3/css3-images.html ","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:5:1","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"基础属性如下 属性 描述 边框 border-image 设置所有边框图像的速记属性。 border-radius 一个用于设置所有四个边框- *-半径属性的速记属性 box-shadow 附加一个或多个下拉框的阴影 圆角 border-radius 所有四个边角 border---radius 属性的缩写 border-top-left-radius 定义了左上角的弧度 border-top-right-radius 定义了右上角的弧度 border-bottom-right-radius 定义了右下角的弧度 border-bottom-left-radius 定义了左下角的弧度 背景 background-clip 规定背景的绘制区域。 background-origin 规定背景图片的定位区域。 background-size 规定背景图片的尺寸。 渐变 background-image: linear-gradient(direction, color-stop1, color-stop2, ...); 线性渐变 background-image: linear-gradient(angle, color-stop1, color-stop2); 角度渐变 background-image: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); 透明度 background-image: repeating-linear-gradient(red, yellow 10%, green 20%); 重复线性渐变 background-image: radial-gradient(shape size at position, start-color, ..., last-color); 径向渐变 background-image: radial-gradient(circle, red, yellow, green); 设置形状 closest-side、farthest-side、closest-corner、farthest-corner 不同尺寸大小关键字 background-image: repeating-radial-gradient(red, yellow 10%, green 15%); 重复的径向渐变 新文本 hanging-punctuation 规定标点字符是否位于线框之外。 punctuation-trim 规定是否对标点字符进行修剪。 text-align-last 设置如何对齐最后一行或紧挨着强制换行符之前的行。 text-emphasis 向元素的文本应用重点标记以及重点标记的前景色。 text-justify 规定当 text-align 设置为 “justify” 时所使用的对齐方法。 text-outline 规定文本的轮廓。 text-overflow 规定当文本溢出包含元素时发生的事情。 text-shadow 向文本添加阴影。 text-wrap 规定文本的换行规则。 word-break 规定非中日韩文本的换行规则。 word-wrap 允许对长的不可分割的单词进行分割并换行到下一行。 新转换属性 transform 适用于2D或3D转换的元素 transform-origin 允许您更改转化元素位置 transform-style 规定被嵌套元素如何在 3D 空间中显示。 perspective 规定 3D 元素的透视效果。 perspective-origin 规定 3D 元素的底部位置 backface-visibility 定义元素在不面对屏幕时是否可见。 2D 转换方法 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 translate(x,y) 定义 2D 转换，沿着 X 和 Y 轴移动元素。 translateX(n) 定义 2D 转换，沿着 X 轴移动元素。 translateY(n) 定义 2D 转换，沿着 Y 轴移动元素。 scale(x,y) 定义 2D 缩放转换，改变元素的宽度和高度。 scaleX(n) 定义 2D 缩放转换，改变元素的宽度。 scaleY(n) 定义 2D 缩放转换，改变元素的高度。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 skew(x-angle,y-angle) 定义 2D 倾斜转换，沿着 X 和 Y 轴。 skewX(angle) 定义 2D 倾斜转换，沿着 X 轴。 skewY(angle) 定义 2D 倾斜转换，沿着 Y 轴。 3D 转换方法 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate3d(x,y,z) 定义 3D 转化。 translateX(x) 定义 3D 转化，仅使用用于 X 轴的值。 translateY(y) 定义 3D 转化，仅使用用于 Y 轴的值。 translateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 定义 3D 缩放转换，通过给定一个 X 轴的值。 scaleY(y) 定义 3D 缩放转换，通过给定一个 Y 轴的值。 scaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿 X 轴的 3D 旋转。 rotateY(angle) 定义沿 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿 Z 轴的 3D 旋转。 perspective(n) 定义 3D 转换元素的透视视图。 过渡属性 transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。默认是 0。 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 transition-delay 规定过渡效果何时开始。默认是 0。 动画属性 @keyframes 规定动画。 animation 所有动画属性的简写属性。 animation-name 规定 @keyframes 动画的名称。 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 animation-fill-mode 规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。 animation-delay 规定动画何时开始。默认是 0。 animation-iteration-count 规定动画被播放的次数。默认是 1。 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 多列属性 column-count 指定元素应该被分割的列数。 column-fill 指定如何填充列 column-gap 指定列与列之间的间隙 column-rule 所有 column-rule-* 属性的简写 column-rule-color 指定两列间边框的颜色 column-rule-style 指定两列间边框的样式 column-rule-width 指定两列间边框的厚度 column-span 指定元素要跨越多少列 column-width 指定列的宽度 columns column-width 与 column-count 的简写属性。 用户界面特性 appearance 允许您使一个元素的外观像一个标准的用户界面元素 box-sizing 允许你以适应区域而用某种方式定义某些元素 icon 为创作者提供了将元素设置为图标等价物的能力。 nav-down 指定在何处使用箭头向下导航键时进行导航 nav-index 指定一个元素的Tab的顺序 nav-left 指定在何处使用左侧的箭头导航键进行导航 nav-right 指定在何处使用右侧的箭头导航键进行导航 nav-up 指定在何处使用箭头向上导航键时进行导航 outline-offset 外轮廓修饰并绘制超出边框的边缘 resize 指定一个元素是否是由用户调整大小 弹性盒子属性 display 指定 HTML 元素盒子类型。 flex-direction 指定了弹性容器中子元素的排列方式 justify-content 设置弹性盒子元素在主轴（横轴）方向上的对齐方式。 align-items 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。 flex-wrap 设置弹性盒子的子元素超出父容器时是否换行。 align-content 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 flex-flow flex-direction 和 flex-wrap 的简写 order 设置弹性盒子的子元素排列顺序。 align-self 在弹性子元素上使用。覆盖容器的 align-","date":"2021-06-24","objectID":"https://blog.gethin.online/css_basic/:5:2","tags":["前端"],"title":"CSS 基础","uri":"https://blog.gethin.online/css_basic/"},{"categories":["语言与平台"],"content":"HTML的基础标签 ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:0","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"基础标签 \u003c!-- 定义 HTML 文档 --\u003e \u003chtml\u003e \u003c!-- 头部标签元素 --\u003e \u003chead\u003e \u003c!-- 元数据（不显示在页面上，但会被浏览器解析，用于指定网页的描述，关键词） --\u003e \u003cmeta charset=\"utf-8\"\u003e \u003c!-- 描述了基本的链接地址/链接目标 --\u003e \u003cbase href=\"http://www.runoob.com/images/\" target=\"_blank\"\u003e \u003c!-- 标签定义了文档与外部资源之间的关系 --\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"\u003e \u003c!-- 标题 --\u003e \u003ctitle\u003e文档标题\u003c/title\u003e \u003c!-- 定义文档的主体 --\u003e \u003cbody\u003e \u003c!-- h1 - h6 --\u003e \u003ch1\u003e这是一个标题\u003c/h1\u003e \u003ch2\u003e这是一个标题\u003c/h2\u003e \u003ch3\u003e这是一个标题\u003c/h3\u003e \u003c!-- 段落 --\u003e \u003cp\u003e这是一个段落。\u003c/p\u003e \u003c!-- 链接 --\u003e \u003ca href=\"https://www.baidu.com\"\u003e这是一个链接\u003c/a\u003e \u003c!-- 图像 --\u003e \u003cimg loading=\"lazy\" src=\"/images/logo.png\" width=\"258\" height=\"39\" /\u003e \u003c!-- map 与 area --\u003e \u003cimg loading=\"lazy\" src=\"planets.gif\" width=\"145\" height=\"126\" alt=\"Planets\" usemap=\"#planetmap\"\u003e \u003cmap name=\"planetmap\"\u003e \u003carea shape=\"rect\" coords=\"0,0,82,126\" alt=\"Sun\" href=\"sun.htm\"\u003e \u003carea shape=\"circle\" coords=\"90,58,3\" alt=\"Mercury\" href=\"mercur.htm\"\u003e \u003carea shape=\"circle\" coords=\"124,58,8\" alt=\"Venus\" href=\"venus.htm\"\u003e \u003c/map\u003e \u003c!-- 换行 --\u003e \u003cbr\u003e \u003c!-- 水平线 --\u003e \u003chr\u003e \u003c!-- 区块 --\u003e \u003cdiv\u003e \u003cspan\u003e \u003c!-- 注释 --\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:1","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"表格、列表、表单、框架、脚本 \u003c!-- 表格 --\u003e \u003ctable border=\"1\"\u003e \u003ctr\u003e \u003ctd\u003eRow 1, cell 1\u003c/td\u003e \u003ctd\u003eRow 1, cell 2\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c!-- 无序列表 --\u003e \u003cul\u003e \u003cli\u003eCoffee\u003c/li\u003e \u003cli\u003eMilk\u003c/li\u003e \u003c/ul\u003e \u003c!-- 有序列表 --\u003e \u003col\u003e \u003cli\u003eCoffee\u003c/li\u003e \u003cli\u003eMilk\u003c/li\u003e \u003c/ol\u003e \u003c!-- 自定义列表 --\u003e \u003cdl\u003e \u003cdt\u003eCoffee\u003c/dt\u003e \u003cdd\u003e- black hot drink\u003c/dd\u003e \u003cdt\u003eMilk\u003c/dt\u003e \u003cdd\u003e- white cold drink\u003c/dd\u003e \u003c/dl\u003e \u003c!-- 表单 --\u003e \u003cform\u003e \u003c!-- Text Fields --\u003e Name: \u003cinput type=\"text\" name=\"name\"\u003e\u003cbr\u003e \u003c!-- password --\u003e Password: \u003cinput type=\"password\" name=\"pwd\"\u003e\u003cbr\u003e \u003c!-- Radio Buttons --\u003e \u003cinput type=\"radio\" name=\"sex\" value=\"male\"\u003eMale\u003cbr\u003e \u003c!-- Checkboxes --\u003e \u003cinput type=\"checkbox\" name=\"vehicle\" value=\"Bike\"\u003eI have a bike\u003cbr\u003e \u003c!-- Submit Button --\u003e \u003cinput type=\"submit\" value=\"Submit\"\u003e \u003c/form\u003e \u003c!-- 框架 --\u003e \u003ciframe src=\"URL\"\u003e\u003c/iframe\u003e \u003c!-- 脚本 --\u003e \u003cscript\u003e document.write(\"Hello World!\"); \u003c/script\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:2","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"常用属性 class： 为html元素定义一个或多个类名（classname）(类名从样式文件引入) id： 定义元素的唯一id style： 规定元素的行内样式（inline style） title： 描述了元素的额外信息 (作为工具条使用) ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:3","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"文本格式化 标签 描述 文本格式化标签 \u003cb\u003e 定义粗体文本 \u003cem\u003e 定义着重文字 \u003ci\u003e 定义斜体字 \u003csmall\u003e 定义小号字 \u003cstrong\u003e 定义加重语气 \u003csub\u003e 定义下标字 \u003csup\u003e 定义上标字 \u003cins\u003e 定义插入字 \u003cdel\u003e 定义删除字 “计算机输出” 标签 \u003ccode\u003e 定义计算机代码 \u003ckbd\u003e 定义键盘码 \u003csamp\u003e 定义计算机代码样本 \u003cvar\u003e 定义变量 \u003cpre\u003e 定义预格式文本 引文, 引用, 及标签定义 \u003cabbr\u003e 定义缩写 \u003caddress\u003e 定义地址 \u003cbdo\u003e 定义文字方向 \u003cblockquote\u003e 定义长的引用 \u003cq\u003e 定义短的引用语 \u003ccite\u003e 定义引用、引证 \u003cdfn\u003e 定义一个定义项目。 ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:4","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"HTML5 新元素 标签 描述 \u003ccanvas\u003e 新元素 \u003ccanvas\u003e 标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API 新多媒体元素 \u003caudio\u003e 定义音频内容 \u003cvideo\u003e 定义视频（video 或者 movie） \u003csource\u003e 定义多媒体资源 \u003cvideo\u003e 和 \u003caudio\u003e \u003cembed\u003e 定义嵌入的内容，比如插件。 \u003ctrack\u003e 为诸如 \u003cvideo\u003e 和 \u003caudio\u003e 元素之类的媒介规定外部文本轨道。 新表单元素 \u003cdatalist\u003e 定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。 \u003ckeygen\u003e 规定用于表单的密钥对生成器字段。 \u003coutput\u003e 定义不同类型的输出，比如脚本的输出。 新的语义和结构元素 \u003carticle\u003e 定义页面独立的内容区域。 \u003caside\u003e 定义页面的侧边栏内容。 \u003cbdi\u003e 允许您设置一段文本，使其脱离其父元素的文本方向设置。 \u003ccommand\u003e 定义命令按钮，比如单选按钮、复选框或按钮 \u003cdetails\u003e 用于描述文档或文档某个部分的细节 \u003cdialog\u003e 定义对话框，比如提示框 \u003csummary\u003e 标签包含 details 元素的标题 \u003cfigure\u003e 规定独立的流内容（图像、图表、照片、代码等等）。 \u003cfigcaption\u003e 定义 \u003cfigure\u003e 元素的标题 \u003cfooter\u003e 定义 section 或 document 的页脚。 \u003cheader\u003e 定义了文档的头部区域 \u003cmark\u003e 定义带有记号的文本。 \u003cmeter\u003e 定义度量衡。仅用于已知最大和最小值的度量。 \u003cnav\u003e 定义导航链接的部分。 \u003cprogress\u003e 定义任何类型的任务的进度。 \u003cruby\u003e 定义 ruby 注释（中文注音或字符）。 \u003crt\u003e 定义字符（中文注音或字符）的解释或发音。 \u003crp\u003e 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。 \u003csection\u003e 定义文档中的节（section、区段）。 \u003ctime\u003e 定义日期或时间。 \u003cwbr\u003e 规定在文本中的何处适合添加换行符。 ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:5","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"HTML5 本地储存 客户端存储数据的两个对象为： localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。 sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。 //保存数据 function save(){ var siteurl = document.getElementById(\"siteurl\").value; var sitename = document.getElementById(\"sitename\").value; localStorage.setItem(sitename, siteurl); alert(\"添加成功\"); } //查找数据 function find(){ var search_site = document.getElementById(\"search_site\").value; var sitename = localStorage.getItem(search_site); var find_result = document.getElementById(\"find_result\"); find_result.innerHTML = search_site + \"的网址是：\" + sitename; ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:6","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"HTML5 Web SQL Web SQL 数据库 API 并不是 HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用 SQL 操作客户端数据库的 APIs。 以下是规范中定义的三个核心方法： openDatabase：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。 transaction：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。 executeSql：这个方法用于执行实际的 SQL 查询。 var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024); var msg; db.transaction(function (tx) { tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, \"菜鸟教程\")'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, \"www.runoob.com\")'); msg = '\u003cp\u003e数据表已创建，且插入了两条数据。\u003c/p\u003e'; document.querySelector('#status').innerHTML = msg; }); db.transaction(function (tx) { tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) { var len = results.rows.length, i; msg = \"\u003cp\u003e查询记录条数: \" + len + \"\u003c/p\u003e\"; document.querySelector('#status').innerHTML += msg; for (i = 0; i \u003c len; i++){ msg = \"\u003cp\u003e\u003cb\u003e\" + results.rows.item(i).log + \"\u003c/b\u003e\u003c/p\u003e\"; document.querySelector('#status').innerHTML += msg; } }, null); }); ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:7","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"HTML5 Web Workers // demo_workers.js var i=0; function timedCount() { i=i+1; postMessage(i); setTimeout(\"timedCount()\",500); } timedCount(); // web_worker.html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003eWeb Worker\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e计数： \u003coutput id=\"result\"\u003e\u003c/output\u003e\u003c/p\u003e \u003cbutton onclick=\"startWorker()\"\u003e开始工作\u003c/button\u003e \u003cbutton onclick=\"stopWorker()\"\u003e停止工作\u003c/button\u003e \u003cp\u003e\u003cstrong\u003e注意：\u003c/strong\u003e Internet Explorer 9 及更早 IE 版本浏览器不支持 Web Workers.\u003c/p\u003e \u003cscript\u003e var w; function startWorker() { if(typeof(Worker) !== \"undefined\") { if(typeof(w) == \"undefined\") { w = new Worker(\"demo_workers.js\"); } w.onmessage = function(event) { document.getElementById(\"result\").innerHTML = event.data; }; } else { document.getElementById(\"result\").innerHTML = \"抱歉，你的浏览器不支持 Web Workers...\"; } } function stopWorker() { w.terminate(); w = undefined; } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:8","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"HTML5 服务器发送事件(Server-Sent Events) Server-Sent 事件 - 单向消息传递 \u003c!-- demo_sse.php --\u003e \u003c?php header('Content-Type: text/event-stream'); header('Cache-Control: no-cache'); $time = date('r'); echo \"data: The server time is: {$time}\\n\\n\"; flush(); ?\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003eServer-Sent Events\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e获取服务端更新数据\u003c/h1\u003e \u003cdiv id=\"result\"\u003e\u003c/div\u003e \u003cscript\u003e if(typeof(EventSource)!==\"undefined\") { var source=new EventSource(\"demo_sse.php\"); source.onmessage=function(event) { document.getElementById(\"result\").innerHTML+=event.data + \"\u003cbr\u003e\"; }; } else { document.getElementById(\"result\").innerHTML=\"抱歉，你的浏览器不支持 server-sent 事件...\"; } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:9","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["语言与平台"],"content":"HTML5 WebSocket WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003eWebSocket\u003c/title\u003e \u003cscript type=\"text/javascript\"\u003e function WebSocketTest() { if (\"WebSocket\" in window) { alert(\"您的浏览器支持 WebSocket!\"); // 打开一个 web socket var ws = new WebSocket(\"ws://localhost:9998/echo\"); ws.onopen = function() { // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(\"发送数据\"); alert(\"数据发送中...\"); }; ws.onmessage = function (evt) { var received_msg = evt.data; alert(\"数据已接收...\"); }; ws.onclose = function() { // 关闭 websocket alert(\"连接已关闭...\"); }; } else { // 浏览器不支持 WebSocket alert(\"您的浏览器不支持 WebSocket!\"); } } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"sse\"\u003e \u003ca href=\"javascript:WebSocketTest()\"\u003e运行 WebSocket\u003c/a\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e HTML 参考手册 ","date":"2021-06-24","objectID":"https://blog.gethin.online/html_basic/:1:10","tags":["前端"],"title":"HTML 基础","uri":"https://blog.gethin.online/html_basic/"},{"categories":["架构艺术"],"content":"UML 的各种图 UML 又称为统一建模语言，是为面向对象开发系统进行说明、可视化的一种标准语言。 UML 的分类如下： UML 用例视图 用例图 设计视图 类图 对象图 进程视图 时序图 协作图 状态图 活动图 实现视图 构件图 拓扑视图 部署图 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:1:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"用例图 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:2:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"类图 类图是描述类与类之间的关系，在类图里有常见的六种关系。分别是泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency) 各种关系的强弱顺序： 泛化 = 实现 \u003e 组合 \u003e 聚合 \u003e 关联 \u003e 依赖 泛化（一种继承关系） 例如：动物 -\u003e 老虎 实现（类与接口的关系，表示接口的实现） 例如：鸟 -\u003e 燕子 聚合（部分和整体的关系，但部分可以脱离整体单独存在） 【代码体现】：成员变量 例如：汽车 -\u003e 轮子 组合（部分和整体的关系，但部分不能脱离整体单独存在，整体没了部分也无法独活） 【代码体现】：成员变量 例如：公司 -\u003e 部门 关联（类和类之间知道彼此的存在【属性、方法之类】，关联可以是单项的，也可以是双向的） 【代码体现】：成员变量 例如：夫妻、师生 依赖（使用的关系，类与类独立，仅存在协助关系，并且尽量不使用双向互相依赖） 【代码表现】：局部变量、方法的参数或者对静态方法的调用 例如：人 -\u003e 锤子 各种类图的关系 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:3:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"对象图 描述的是参与交互的各个对象在交互过程中某一时刻的状态。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:4:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"状态图（Statechart Diagrams） 是描述一个实体基于事件反应的动态行为，显示了该实体如何根据当前所处的状态对不同的事件做出反应。 框里是状态，线是行为。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:5:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"活动图（Activity Diagrams） 用于表示系统中各种活动的次序。 实圆圈是开始，框里是行为，菱形是选择，套圈是结束。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:6:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"时序图（equence Diagrams） 描述了对象之间消息发送的先后顺序，强调时间顺序。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:7:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"协作图（Collaboration Diagrams） 描述了收发消息的对象的组织关系，强调对象之间的合作关系。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:8:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"构件图（Component Diagrams） 构件图是用来表示系统中构件与构件之间，类或接口与构件之间的关系图。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:9:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["架构艺术"],"content":"部署图（Deployment Diagrams） 描述了系统运行时进行处理的结点以及在结点上活动的构件的配置。强调了物理设备以及之间的连接关系。 ","date":"2021-06-23","objectID":"https://blog.gethin.online/uml-design/:10:0","tags":["UML"],"title":"UML设计与基本概念","uri":"https://blog.gethin.online/uml-design/"},{"categories":["计算机基础"],"content":"HTTP 响应代码 HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。 响应分为五类： 信息响应(100–199) 成功响应(200–299) 重定向(300–399) 客户端错误(400–499) 服务器错误 (500–599) 状态代码由 section 10 of RFC 2616定义 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:1:0","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"信息响应 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:2:0","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"100 Continue 这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:2:1","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"101 Switching Protocol 该代码是响应客户端的 Upgrade (en-US) 标头发送的，并且指示服务器也正在切换的协议。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:2:2","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"102 Processing (WebDAV (en-US)) 此代码表示服务器已收到并正在处理该请求，但没有响应可用。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:2:3","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"103 Early Hints 此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:2:4","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"成功响应 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:0","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"200 OK 请求成功。成功的含义取决于HTTP方法： GET：资源已被提取并在消息正文中传输。 HEAD：实体标头位于消息正文中。 POST：描述动作结果的资源在消息体中传输。 TRACE：消息正文包含服务器收到的请求消息 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:1","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"201 Created 该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:2","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"202 Accepted 请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:3","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"203 Non-Authoritative Information 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:4","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"204 No Content 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:5","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"205 Reset Content 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:6","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"206 Partial Content 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:7","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"207 Multi-Status (WebDAV (en-US)) 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 208 Already Reported (WebDAV (en-US)) 在 DAV 里面使用: propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:8","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"226 IM Used (HTTP Delta encoding) 服务器已经完成了对资源的 GET 请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:3:9","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"重定向 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:0","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"300 Multiple Choice 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:1","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:2","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"302 Found 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:3","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"303 See Other 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:4","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"304 Not Modified 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:5","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"305 Use Proxy 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:6","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"306 unused 在最新版的规范中，306 状态码已经不再被使用。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:7","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"307 Temporary Redirect 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:8","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"308 Permanent Redirect 这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:4:9","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"客户端响应 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:0","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"400 Bad Request 语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 请求参数有误。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:1","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"401 Unauthorized 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:2","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"402 Payment Required 此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:3","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"403 Forbidden 服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:4","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:5","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"405 Method Not Allowed 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:6","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"406 Not Acceptable 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:7","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"407 Proxy Authentication Required 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:8","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"408 Request Timeout 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:9","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"409 Conflict 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:10","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"410 Gone 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:11","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"411 Length Required 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:12","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"412 Precondition Failed 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:13","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"413 Payload Too Large 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:14","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"414 URI Too Long 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:15","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"415 Unsupported Media Type 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:16","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"416 Range Not Satisfiable 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:17","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"417 Expectation Failed 此响应代码意味着服务器无法满足 Expect 请求标头字段指示的期望值。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:18","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"418 I’m a teapot 服务器拒绝尝试用 “茶壶冲泡咖啡”。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:19","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"421 Misdirected Request 该请求针对的是无法产生响应的服务器。 这可以由服务器发送，该服务器未配置为针对包含在请求 URI 中的方案和权限的组合产生响应。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:20","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"422 Unprocessable Entity (WebDAV (en-US)) 请求格式良好，但由于语义错误而无法遵循。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:21","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"423 Locked (WebDAV (en-US)) 正在访问的资源被锁定。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:22","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"424 Failed Dependency (WebDAV (en-US)) 由于先前的请求失败，所以此次请求失败。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:23","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"425 Too Early 服务器不愿意冒着风险去处理可能重播的请求。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:24","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"426 Upgrade Required 服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做。 服务器在 426 响应中发送 Upgrade (en-US) 头以指示所需的协议。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:25","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"428 Precondition Required 原始服务器要求该请求是有条件的。 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:26","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"429 Too Many Requests 用户在给定的时间内发送了太多请求（“限制请求速率”）。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:27","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"431 Request Header Fields Too Large 服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:28","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"451 Unavailable For Legal Reasons 用户请求非法资源，例如：由政府审查的网页。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:5:29","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"服务端响应 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:0","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"500 Internal Server Error 服务器遇到了不知道如何处理的情况。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:1","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"501 Not Implemented 此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:2","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"502 Bad Gateway 此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:3","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"503 Service Unavailable 服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:4","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"504 Gateway Timeout 当服务器作为网关，不能及时得到响应时返回此错误代码。 505 HTTP Version Not Supported 服务器不支持请求中所使用的HTTP协议版本。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:5","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"506 Variant Also Negotiates 服务器有一个内部配置错误：对请求的透明内容协商导致循环引用。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:6","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"507 Insufficient Storage 服务器有内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:7","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"508 Loop Detected (WebDAV (en-US)) 服务器在处理请求时检测到无限循环。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:8","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"510 Not Extended 客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:9","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["计算机基础"],"content":"511 Network Authentication Required 511状态码指示客户端需要进行身份验证才能获得网络访问权限。 ","date":"2021-06-10","objectID":"https://blog.gethin.online/http-status-code/:6:10","tags":[],"title":"HTTP 响应代码","uri":"https://blog.gethin.online/http-status-code/"},{"categories":["数据与算法"],"content":"1. 封装集合 概念：本文所讲的封装集合就是把集合进行封装，只提供调用端需要的接口。 正文：在很多时候，我们都不希望把一些不必要的操作暴露给调用端，只需要给它所需要的操作或数据就行，那么做法就是封装。这个重构在微软的代码库也经常遇到。比如最经典的属性对字段的封装就是一个很好的例子，那么下面我们将看到对集合的封装，如下代码所示，调用端只需要一个集合的信息，而我们则提供了一个IList的集合，大家都知道IList具有对集合的所有操作，所以这会带来很多隐患，最好的做法就是对它进行重构。 那么重构之后，我们把IList换成了IEnumerable，大家都知道只包括一个返回值为IEnumerator的GetEnumerator()方法，所以这样只能遍历取出它的值，而不能对这个集合做出改变，这正是我们所需要的结果，具体代码如下： using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.EncapsulateCollection.Before { public class Order { private List\u003cOrderLine\u003e _orderLines; private double _orderTotal; public IList\u003cOrderLine\u003e OrderLines { get { return _orderLines; } } public void AddOrderLine(OrderLine orderLine) { _orderTotal += orderLine.Total; _orderLines.Add(orderLine); } public void RemoveOrderLine(OrderLine orderLine) { orderLine = _orderLines.Find(o =\u003e o == orderLine); if (orderLine == null) return; _orderTotal -= orderLine.Total; _orderLines.Remove(orderLine); } } public class OrderLine { public double Total { get; private set; } } using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.EncapsulateCollection.After { public class Order { private List\u003cOrderLine\u003e _orderLines; private double _orderTotal; public IEnumerable\u003cOrderLine\u003e OrderLines { get { return _orderLines; } } public void AddOrderLine(OrderLine orderLine) { _orderTotal += orderLine.Total; _orderLines.Add(orderLine); } public void RemoveOrderLine(OrderLine orderLine) { orderLine = _orderLines.Find(o =\u003e o == orderLine); if (orderLine == null) return; _orderTotal -= orderLine.Total; _orderLines.Remove(orderLine); } } public class OrderLine { public double Total { get; private set; } } } 总结：这个例子很容易让我们想到以前系统间耦合常喜欢用数据库。每个系统都会操作数据库，并且有些系统还会对数据库的表结构或字段进行修改，那么这很容易就会造成维护的地狱，很明智的一个做法就是使用SOA来隔开这些耦合，让一些只需要数据展示的系统得到自己需要的数据即可。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:1:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"2. 移动方法 概念：本文所讲的移动方法就是方法放在合适的位置（通常指放在合适的类中）。 正文：移动方法是一个很简单也很常见的重构，只要是系统就会存在很多类，那么类里面包括很多方法，如果一个方法经常被另外一个类使用（比本身的类使用还多）或者这个方法本身就不应该放在这个类里面，那么这个适合应该考虑把它移到合适的类中。代码如下： 移动以后大家可以看到BankAccount类的职责也单一，同时CalculateInterestRate也放到了经常使用且适合它的类中了，所以此重构是一个比较好的重构，能让整个代码变得更加合理。 namespace LosTechies.DaysOfRefactoring.MoveMethod.Before { public class BankAccount { public BankAccount(int accountAge, int creditScore, AccountInterest accountInterest) { AccountAge = accountAge; CreditScore = creditScore; AccountInterest = accountInterest; } public int AccountAge { get; private set; } public int CreditScore { get; private set; } public AccountInterest AccountInterest { get; private set; } public double CalculateInterestRate() { if (CreditScore \u003e 800) return 0.02; if (AccountAge \u003e 10) return 0.03; return 0.05; } } public class AccountInterest { public BankAccount Account { get; private set; } public AccountInterest(BankAccount account) { Account = account; } public double InterestRate { get { return Account.CalculateInterestRate(); } } public bool IntroductoryRate { get { return Account.CalculateInterestRate() \u003c 0.05; } } } } namespace LosTechies.DaysOfRefactoring.MoveMethod.After { public class AccountInterest { public BankAccount Account { get; private set; } public AccountInterest(BankAccount account) { Account = account; } public double InterestRate { get { return CalculateInterestRate(); } } public bool IntroductoryRate { get { return CalculateInterestRate() \u003c 0.05; } } public double CalculateInterestRate() { if (Account.CreditScore \u003e 800) return 0.02; if (Account.AccountAge \u003e 10) return 0.03; return 0.05; } } } namespace LosTechies.DaysOfRefactoring.MoveMethod.After { public class BankAccount { public BankAccount(int accountAge, int creditScore, AccountInterest accountInterest) { AccountAge = accountAge; CreditScore = creditScore; AccountInterest = accountInterest; } public int AccountAge { get; private set; } public int CreditScore { get; private set; } public AccountInterest AccountInterest { get; private set; } } } 总结：这个重构法则在很多时候能让我们把代码组织的结构调整得更合理，同时也能给以后的维护带来方便。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:2:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"3. 提升方法 概念：提升方法是指将一个很多继承类都要用到的方法提升到基类中。 正文：提升方法是指将一个很多继承类都要用到的方法提升到基类中，这样就能减少代码量，同时让类的结构更清晰。如下代码所示，Turn方法在子类Car和Motorcycle 都会用到，因为Vehicle 都会有这个方法，所以我们就会想到把它提到基类中。 重构后的代码如下，那么现在Car 和Motorcycle 都具有Turn这个方法，如果这个方法修改也只需要修改基类即可，所以给维护和以后的重构带来了方便。 namespace LosTechies.DaysOfRefactoring.PullUpMethod.Before { public abstract class Vehicle { // other methods } public class Car : Vehicle { public void Turn(Direction direction) { // code here } } public class Motorcycle : Vehicle { } public enum Direction { Left, Right } } namespace LosTechies.DaysOfRefactoring.PullUpMethod.After { public abstract class Vehicle { public void Turn(Direction direction) { // code here } } public class Car : Vehicle { } public class Motorcycle : Vehicle { } public enum Direction { Left, Right } } 总结：这个重构要根据具体情况使用，如果不是每个子类都有这个方法的话，可以考虑使用接口或者其他方式。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:3:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"4. 降低方法 概念：本文中的降低方法和前篇的提升方法整好相反，也就是把个别子类使用到的方法从基类移到子类里面去。 正文：如下代码所示，Animal 类中的方法Bark只有在其子类Dog 中使用，所以最好的方案就是把这个方法移到子类Dog 中。 重构后的代码如下，同时如果在父类Animal 中如果没有其他的字段或者公用方法的话，可以考虑把Bark方法做成一个接口，从而去掉Animal 类。 namespace LosTechies.DaysOfRefactoring.PushDownMethod.Before { public abstract class Animal { public void Bark() { // code to bark } } public class Dog : Animal { } public class Cat : Animal { } } namespace LosTechies.DaysOfRefactoring.PushDownMethod.After { public abstract class Animal { } public class Dog : Animal { public void Bark() { // code to bark } } public class Cat : Animal { } } 总结：面向对象三大特征（继承、封装、多态）很多时候可以帮助我们，但同时也可能会造成使用过度或者使用不当，所以如何把握好设计，这个就变得至关重要。在什么时候使用继承的方式，在什么时候使用组合和聚合，接口和继承类的选择等久成了我们的重点。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:4:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"5. 提升字段 概念：本文中的提升字段和前面的提升方法颇为相似，就是把子类公用的字段提升到基类中，从而达到公用的目的。 正文：如下代码所示， Account 的两个子类CheckingAccount 和SavingsAccount 都有minimumCheckingBalance 字段，所以可以考虑把这个字段提到基类中。 重构后的代码如下，这样提的前提是这些子类有一个基类或者有很多相似的字段和方法，不然为了一个字段而单独建立一个抽象类是不可取的，所以这个就需要具体权衡。 using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace LosTechies.DaysOfRefactoring.PullUpField.Before { public abstract class Account { } public class CheckingAccount : Account { private decimal _minimumCheckingBalance = 5m; } public class SavingsAccount : Account { private decimal _minimumSavingsBalance = 5m; } } using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace LosTechies.DaysOfRefactoring.PullUpField.After { public abstract class Account { protected decimal _minimumBalance = 5m; } public class CheckingAccount : Account { } public class SavingsAccount : Account { } } 总结：这个重构的策略比较简单，同时也是比较常用的一些做法，最主要就是要注意权衡是否真的有这个必要，看这样做究竟有没有什么好处（比如只需要改一个地方，维护简便了，同时代码量也更少了等）。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:5:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"6. 降低字段 概念：本文中的降低字段和前篇的提升字段正好相反，就是把基类中只有某些少数类用到的字段降低到使用它们的子类中。 正文：如下代码所示，基类Task 类中的_resolution字段只会在子类BugTask 中用到，所以就考虑把它放到BugTask 类中。 重构后的代码如下所示，这样做的好处可以简化基类，同时让其他没有使用它的子类也变得更加简单，如果这样的字段比较多的话，使用此重构也能节约一部分内存。 namespace LosTechies.DaysOfRefactoring.PushDownField.Before { public abstract class Task { protected string _resolution; } public class BugTask : Task { } public class FeatureTask : Task { } } namespace LosTechies.DaysOfRefactoring.PushDownField.After { public abstract class Task { } public class BugTask : Task { private string _resolution; } public class FeatureTask : Task { } } 总结：此重构也是一个非常简单的重构，在很多时候我们都会不自觉的使用它。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:6:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"7. 重命名（方法，类，参数） 概念：本文中的改名（方法，类，参数）是指在写代码的时候对类、方法、参数、委托、事件等等元素取一个有意义的名称。 正文：如下代码所示，加入一个公司建立一个员工的类，类中有一个员工名字的字段和一个按照小时计算员工收入的方法，那么下面代码的取名就显得很难理解了，所以我们会重构名称。 重构后代码如下所示，这样看起来就非常清晰，如果有新进项目组的成员，也会变得很乐意看这个代码。 namespace LosTechies.DaysOfRefactoring.Rename.Before { public class Person { public string FN { get; set; } public decimal ClcHrlyPR() { // code to calculate hourly payrate return 0m; } } } namespace LosTechies.DaysOfRefactoring.Rename.After { // Changed the class name to Employee public class Employee { public string FirstName { get; set; } public decimal CalculateHourlyPay() { // code to calculate hourly payrate return 0m; } } } 总结：此重构经常被广大程序员所忽视，但是带来的隐患是不可估量的，也许老板要修改功能，那我们来看这段没有重构的代码（就算是自己写的，但由于时间和项目多等关系，我们也很难理解了），然后就会变得焦头烂额。相反重构后的代码就会觉得一目了然、赏心悦目。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:7:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"8. 使用委派代替继承 概念：本文中的“使用委派代替继承”是指在根本没有父子关系的类中使用继承是不合理的，可以用委派的方式来代替。 如下代码所示，Child 和Sanitation（公共设施）是没有逻辑上的父子关系，因为小孩不可能是一个公共设施吧！所以我们为了完成这个功能可以考虑使用委派的方式。 重构后的代码如下，把Sanitation 委派到Child 类中，从而可以使用WashHands这个方法，这种方式我们经常会用到，其实IOC也使用到了这个原理，可以通过构造注入和方法注入等。 namespace LosTechies.DaysOfRefactoring.ReplaceInheritance.Before { public class Sanitation { public string WashHands() { return \"Cleaned!\"; } } public class Child : Sanitation { } } namespace LosTechies.DaysOfRefactoring.ReplaceInheritance.After { public class Sanitation { public string WashHands() { return \"Cleaned!\"; } } public class Child { private Sanitation Sanitation { get; set; } public Child() { Sanitation = new Sanitation(); } public string WashHands() { return Sanitation.WashHands(); } } } 总结：这个重构是一个很好的重构，在很大程度上解决了滥用继承的情况，很多设计模式也用到了这种思想（比如桥接模式、适配器模式、策略模式等）。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:8:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"9. 提取接口 概念：本文中的“提取接口” 是指超过一个的类要使用某一个类中部分方法时，我们应该解开它们之间的依赖，让调用者使用接口，这很容易实现也可以降低代码的耦合性。 正文：如下代码所示，RegistrationProcessor 类只使用到了ClassRegistration 类中的Create方法和Total 字段，所以可以考虑把他们做成接口给RegistrationProcessor 调用。 重构后的代码如下，我们提取了一个IClassRegistration 接口，同时让ClassRegistration 继承此接口，然后调用端RegistrationProcessor 就可以直接通过IClassRegistration 接口进行调用。 namespace LosTechies.DaysOfRefactoring.ExtractInterface.Before { public class ClassRegistration { public void Create() { // create registration code } public void Transfer() { // class transfer code } public decimal Total { get; private set; } } public class RegistrationProcessor { public decimal ProcessRegistration(ClassRegistration registration) { registration.Create(); return registration.Total; } } } namespace LosTechies.DaysOfRefactoring.ExtractInterface.After { public interface IClassRegistration { void Create(); decimal Total { get; } } public class ClassRegistration : IClassRegistration { public void Create() { // create registration code } public void Transfer() { // class transfer code } public decimal Total { get; private set; } } public class RegistrationProcessor { public decimal ProcessRegistration(IClassRegistration registration) { registration.Create(); return registration.Total; } } } 总结：这个重构策略也是一个常见的运用，很多设计模式也会在其中运用此思想（如简单工程、抽象工厂等都会通过接口来解开依赖）。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:9:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"10. 提取方法 概念：本文中的把某些计算复杂的过程按照功能提取成各个小方法，这样就可以使代码的可读性、维护性得到提高。 正文：如下代码所示，CalculateGrandTotal方法里面包含了多个逻辑，第一计算subTotal的总和，第二subTotal 要循环减去discount，也就是计算Discounts，第三就是计算Tax。所以我们可以根据功能把他们拆分成三个小方法。 重构后的代码如下，然后CalculateGrandTotal方法就直接调用CalculateSubTotal、CalculateDiscounts、CalculateTax，从而是整个逻辑看起来更加清晰，并且可读性和维护性也得到了大大提高。 using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.ExtractMethod.Before { public class Receipt { private IList\u003cdecimal\u003e Discounts { get; set; } private IList\u003cdecimal\u003e ItemTotals { get; set; } public decimal CalculateGrandTotal() { decimal subTotal = 0m; foreach (decimal itemTotal in ItemTotals) subTotal += itemTotal; if (Discounts.Count \u003e 0) { foreach (decimal discount in Discounts) subTotal -= discount; } decimal tax = subTotal * 0.065m; subTotal += tax; return subTotal; } } } using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.ExtractMethod.After { public class Receipt { private IList\u003cdecimal\u003e Discounts { get; set; } private IList\u003cdecimal\u003e ItemTotals { get; set; } public decimal CalculateGrandTotal() { decimal subTotal = CalculateSubTotal(); subTotal = CalculateDiscounts(subTotal); subTotal = CalculateTax(subTotal); return subTotal; } private decimal CalculateTax(decimal subTotal) { decimal tax = subTotal * 0.065m; subTotal += tax; return subTotal; } private decimal CalculateDiscounts(decimal subTotal) { if (Discounts.Count \u003e 0) { foreach (decimal discount in Discounts) subTotal -= discount; } return subTotal; } private decimal CalculateSubTotal() { decimal subTotal = 0m; foreach (decimal itemTotal in ItemTotals) subTotal += itemTotal; return subTotal; } } } 总结：这个重构在很多公司都有一些的代码规范作为参考，比如一个类不能超过多少行代码，一个方法里面不能超过多少行代码，这在一定程度上也能使程序员把这些复杂的逻辑剥离成意义很清楚的小方法。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:10:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"11. 使用策略类 概念：本文中的“使用策略类” 是指用设计模式中的策略模式来替换原来的switch case和if else语句，这样可以解开耦合，同时也使维护性和系统的可扩展性大大增强。 正文：如下面代码所示，ClientCode 类会更加枚举State的值来调用ShippingInfo 的不同方法，但是这样就会产生很多的判断语句，如果代码量加大，类变得很大了的话，维护中改动也会变得很大，每次改动一个地方，都要对整个结构进行编译（假如是多个工程），所以我们想到了对它进行重构，剥开耦合。 重构后的代码如下所示，抽象出一个IShippingCalculation 接口，然后把ShippingInfo 类里面的GetAlaskaShippingAmount、GetNewYorkShippingAmount、GetFloridaShippingAmount三个方法分别提炼成三个类，然后继承自IShippingCalculation 接口，这样在调用的时候就可以通过IEnumerable\u003cIShippingCalculation\u003e 来解除之前的switch case语句，这和IOC的做法颇为相似。 namespace LosTechies.DaysOfRefactoring.SwitchToStrategy.Before { public class ClientCode { public decimal CalculateShipping() { ShippingInfo shippingInfo = new ShippingInfo(); return shippingInfo.CalculateShippingAmount(State.Alaska); } } public enum State { Alaska, NewYork, Florida } public class ShippingInfo { public decimal CalculateShippingAmount(State shipToState) { switch (shipToState) { case State.Alaska: return GetAlaskaShippingAmount(); case State.NewYork: return GetNewYorkShippingAmount(); case State.Florida: return GetFloridaShippingAmount(); default: return 0m; } } private decimal GetAlaskaShippingAmount() { return 15m; } private decimal GetNewYorkShippingAmount() { return 10m; } private decimal GetFloridaShippingAmount() { return 3m; } } } using System; using System.Collections.Generic; using System.Linq; namespace LosTechies.DaysOfRefactoring.SwitchToStrategy.After_WithIoC { public interface IShippingInfo { decimal CalculateShippingAmount(State state); } public class ClientCode { [Inject] public IShippingInfo ShippingInfo { get; set; } public decimal CalculateShipping() { return ShippingInfo.CalculateShippingAmount(State.Alaska); } } public enum State { Alaska, NewYork, Florida } public class ShippingInfo : IShippingInfo { private IDictionary\u003cState, IShippingCalculation\u003e ShippingCalculations { get; set; } public ShippingInfo(IEnumerable\u003cIShippingCalculation\u003e shippingCalculations) { ShippingCalculations = shippingCalculations.ToDictionary(calc =\u003e calc.State); } public decimal CalculateShippingAmount(State shipToState) { return ShippingCalculations[shipToState].Calculate(); } } public interface IShippingCalculation { State State { get; } decimal Calculate(); } public class AlaskShippingCalculation : IShippingCalculation { public State State { get { return State.Alaska; } } public decimal Calculate() { return 15m; } } public class NewYorkShippingCalculation : IShippingCalculation { public State State { get { return State.NewYork; } } public decimal Calculate() { return 10m; } } public class FloridaShippingCalculation : IShippingCalculation { public State State { get { return State.Florida; } } public decimal Calculate() { return 3m; } } } 总结：这种重构在设计模式当中把它单独取了一个名字——策略模式，这样做的好处就是可以隔开耦合，以注入的形式实现功能，这使增加功能变得更加容易和简便，同样也增强了整个系统的稳定性和健壮性。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:11:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"12. 分解依赖 概念：本文中的“分解依赖” 是指对部分不满足我们要求的类和方法进行依赖分解，通过装饰器来达到我们需要的功能。 正文：正如下面代码所示，如果你要在你的代码中加入单元测试但有一部分代码是你不想测试的，那么你应用使用这个的重构。下面的例子中我们应用静态类来完成某些工作，但问题是在单元测试时我们无法mock静态类，所以我们只能引入静态类的装饰接口来分解对静态类的依赖。从而我们使我们的调用类只需要依赖于装饰接口就能完成这个操作。 重构后代码如下，我们添加一个接口和一个实现类，在实现类中调用静态类的方法，所以说具体做什么事情没有改变，改变的只是形式，但这样做的一个好处是增加了了代码的可测试性。在应用了分解依赖模式后，我们就可以在单元测试的时候mock一个IFeederService对象并通过AnimalFeedingService的构造函数传递给它。这样就可以完成我们需要的功能。 namespace LosTechies.DaysOfRefactoring.BreakDependencies.Before { public class AnimalFeedingService { private bool FoodBowlEmpty { get; set; } public void Feed() { if (FoodBowlEmpty) Feeder.ReplenishFood(); // more code to feed the animal } } public static class Feeder { public static void ReplenishFood() { // fill up bowl } } } namespace LosTechies.DaysOfRefactoring.BreakDependencies.After { public class AnimalFeedingService { public IFeederService FeederService { get; set; } public AnimalFeedingService(IFeederService feederService) { FeederService = feederService; } private bool FoodBowlEmpty { get; set; } public void Feed() { if (FoodBowlEmpty) FeederService.ReplenishFood(); // more code to feed the animal } } public interface IFeederService { void ReplenishFood(); } public class FeederService : IFeederService { public void ReplenishFood() { Feeder.ReplenishFood(); } } public static class Feeder { public static void ReplenishFood() { // fill up bowl } } } 总结：这个重构在很多时候和设计模式中的一些思想类似，使用中间的装饰接口来分解两个类之间的依赖，对类进行装饰，然后使它满足我们所需要的功能。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:12:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"13. 提取方法对象 概念：本文中的“提取方法对象”是指当你发现一个方法中存在过多的局部变量时，你可以通过使用“提取方法对象”重构来引入一些方法，每个方法完成任务的一个步骤，这样可以使得程序变得更具有可读性。 正文：如下代码所示，Order 类中的Calculate方法要完成很多功能，在之前我们用“提取方法”来进行重构，现在我们采取“提取方法对象”来完成重构。 正如下代码所示，我们引入了OrderCalculator类，该类实现了所有的计算方法，Order类将自身传递给 OrderCalculator类并调用Calculate方法完成计算过程。 using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.ExtractMethodObject.Before { public class OrderLineItem { public decimal Price { get; private set; } } public class Order { private IList\u003cOrderLineItem\u003e OrderLineItems { get; set; } private IList\u003cdecimal\u003e Discounts { get; set; } private decimal Tax { get; set; } public decimal Calculate() { decimal subTotal = 0m; // Total up line items foreach (OrderLineItem lineItem in OrderLineItems) { subTotal += lineItem.Price; } // Subtract Discounts foreach (decimal discount in Discounts) subTotal -= discount; // Calculate Tax decimal tax = subTotal * Tax; // Calculate GrandTotal decimal grandTotal = subTotal + tax; return grandTotal; } } } using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.ExtractMethodObject.After { public class OrderLineItem { public decimal Price { get; private set; } } public class Order { public IEnumerable\u003cOrderLineItem\u003e OrderLineItems { get; private set; } public IEnumerable\u003cdecimal\u003e Discounts { get; private set; } public decimal Tax { get; private set; } public decimal Calculate() { return new OrderCalculator(this).Calculate(); } } public class OrderCalculator { private decimal SubTotal { get; set; } private IEnumerable\u003cOrderLineItem\u003e OrderLineItems { get; set; } private IEnumerable\u003cdecimal\u003e Discounts { get; set; } private decimal Tax { get; set; } public OrderCalculator(Order order) { OrderLineItems = order.OrderLineItems; Discounts = order.Discounts; Tax = order.Tax; } public decimal Calculate() { CalculateSubTotal(); SubtractDiscounts(); CalculateTax(); return SubTotal; } private void CalculateSubTotal() { // Total up line items foreach (OrderLineItem lineItem in OrderLineItems) SubTotal += lineItem.Price; } private void SubtractDiscounts() { // Subtract Discounts foreach (decimal discount in Discounts) SubTotal -= discount; } private void CalculateTax() { // Calculate Tax SubTotal += SubTotal * Tax; } } } 总结：本文的重构方法在有的时候还是比较有用，但这样会造成字段的增加，同时也会带来一些维护的不便，它和“提取方法”最大的区别就是一个通过方法返回需要的数据，另一个则是通过字段来存储方法的结果值，所以在很大程度上我们都会选择“提取方法”。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:13:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"14. 分离职责 概念：本文中的“分离职责”是指当一个类有许多职责时，将部分职责分离到独立的类中，这样也符合面向对象的五大特征之一的单一职责原则，同时也可以使代码的结构更加清晰，维护性更高。 正文：如下代码所示，Video类有两个职责，一个是处理video rental，另一个是计算每个客户的总租金。我们可以将这两个职责分离出来，因为计算每个客户的总租金可以在Customer计算，这也比较符合常理。 重构后的代码如下，这样Video 的职责就变得很清晰，同时也使代码维护性更好。 using System.Collections.Generic; using System.Linq; namespace LosTechies.DaysOfRefactoring.BreakResponsibilities.Before { public class Video { public void PayFee(decimal fee) { } public void RentVideo(Video video, Customer customer) { customer.Videos.Add(video); } public decimal CalculateBalance(Customer customer) { returncustomer.LateFees.Sum(); } } public class Customer { public IList\u003cdecimal\u003e LateFees { get; set; } public IList\u003cVideo\u003e Videos { get; set; } } } using System.Collections.Generic; using System.Linq; namespace LosTechies.DaysOfRefactoring.BreakResponsibilities.After { public class Video { public void RentVideo(Video video, Customer customer) { customer.Videos.Add(video); } } public class Customer { public IList\u003cdecimal\u003e LateFees { get; set; } public IList\u003cVideo\u003e Videos { get; set; } public void PayFee(decimal fee) { } public decimal CalculateBalance(Customer customer) { return customer.LateFees.Sum(); } } } 总结：这个重构经常会用到，它和之前的“移动方法”有几分相似之处，让方法放在合适的类中，并且简化类的职责，同时这也是面向对象五大原则之一和设计模式中的重要思想。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:14:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"15.移除重复内容 概念：本文中的“移除重复内容”是指把一些很多地方都用到的逻辑提炼出来，然后提供给调用者统一调用。 正文：如下代码所示，ArchiveRecord和CloseRecord都会用到Archived = true; 和DateArchived = DateTime.Now; 这两条语句，所以我们就可以对它进行重构。 重构后的代码如下所示，我们提炼了SwitchToArchived方法来封装公用的操作，然后给ArchiveRecord和CloseRecord统一调用。 using System; namespace LosTechies.DaysOfRefactoring.RemoveDuplication.Before { public class MedicalRecord { public DateTime DateArchived { get; private set; } public bool Archived { get; private set; } public void ArchiveRecord() { Archived = true; DateArchived = DateTime.Now; } public void CloseRecord() { Archived = true; DateArchived = DateTime.Now; } } } sing System; namespace LosTechies.DaysOfRefactoring.RemoveDuplication.After { public class MedicalRecord { public DateTime DateArchived { get; private set; } public bool Archived { get; private set; } public void ArchiveRecord() { SwitchToArchived(); } public void CloseRecord() { SwitchToArchived(); } private void SwitchToArchived() { Archived = true; DateArchived = DateTime.Now; } } } 总结：这个重构很简单，绝大多数程序员都会使用这种重构方法，但有时由于习惯、时间、赶进度等原因而忽略它，所以会使得整个系统杂乱无章，到处都是Ctrl+C和Ctrl+V的痕迹。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:15:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"16. 封装条件 概念：本文中的“封装条件”是指条件关系比较复杂时，代码的可读性会比较差，所以这时我们应当根据条件表达式是否需要参数将条件表达式提取成可读性更好的属性或者方法，如果条件表达式不需要参数则可以提取成属性，如果条件表达式需要参数则可以提取成方法。 正文：如下代码所示，PerformCoolFunction里面的if条件判断比较复杂，看起来有点杂乱，所以就把它提出来。 如下代码所示，我们把条件表达式封装成HasExtraFunctions属性，这样先前的条件判断就成了if (HasExtraFunctions) ，所以这样就在很大程度上提高了可读性。 using System; namespace LosTechies.DaysOfRefactoring.EncapsulateConditional.Before { public class RemoteControl { private string[] Functions { get; set; } private string Name { get; set; } private int CreatedYear { get; set; } public string PerformCoolFunction(string buttonPressed) { // Determine if we are controlling some extra function // that requires special conditions if (Functions.Length \u003e 1 \u0026\u0026 Name == \"RCA\" \u0026\u0026 CreatedYear \u003e DateTime.Now.Year - 2) return \"doSomething\"; } } } using System; namespace LosTechies.DaysOfRefactoring.EncapsulateConditional.After { public class RemoteControl { private string[] Functions { get; set; } private string Name { get; set; } private int CreatedYear { get; set; } private bool HasExtraFunctions { get { return Functions.Length \u003e 1 \u0026\u0026 Name == \"RCA\" \u0026\u0026 CreatedYear \u003e DateTime.Now.Year - 2; } } public string PerformCoolFunction(string buttonPressed) { // Determine if we are controlling some extra function // that requires special conditions if (HasExtraFunctions) return \"doSomething\"; } } } 总结：这个重构在很大程度上能改善代码的可读性，尤其是在一个逻辑很复杂的应用中，把这些条件判断封装成一个有意义的名字，这样很复杂的逻辑也会立刻变得简单起来。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:16:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"17. 提取父类 正文：Dog 类中的EatFood和Groom有可能被其他类用到，因为他们都是动物的一些公有性质，所以这个时候我们就会考虑对它进行提炼。 代码如下所示，提取了Animal 方法来封装公用的EatFood和Groom类，从而使其他继承了Animal 类的子类都可以使用这两个方法了。 namespace LosTechies.DaysOfRefactoring.ExtractSuperclass.Before { public class Dog { public void EatFood() { // eat some food } public void Groom() { // perform grooming } } } namespace LosTechies.DaysOfRefactoring.ExtractSuperclass.After { public class Animal { public void EatFood() { // eat some food } public void Groom() { // perform grooming } } public class Dog : Animal { } } 总结：这个重构是典型的继承用法，很多程序员都会选择这样做，但是要注意正确的使用，不要造成过度使用了继承，如果过度使用了，请考虑用接口、组合和聚合来实现。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:17:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"18.使用条件判断代替异常 概念：本文中的“使用条件判断代替异常”是指把没有必要使用异常做判断的条件尽量改为条件判断。 正文：如下代码所示，在日常的编码中我们经常需要用到异常来控制程序流，Start方法里面用try catch 做条件判断，我们知道这里没有必要使用这种方式，因为你不需要做类型不可控的类型转换，也不需要处理异常行为，所以我们应该对它进行重构。 重构后的代码如下所示，try catch做条件判断的语句改成了if return的方式，这样在很多程度上统一了代码的书写，同时也提高了性能。 } namespace LosTechies.DaysOfRefactoring.ReplaceException.Before { public class Microwave { private IMicrowaveMotor Motor { get; set; } public bool Start(object food) { bool foodCooked = false; try { Motor.Cook(food); foodCooked = true; } catch (InUseException) { foodcooked = false; } return foodCooked; } } } namespace LosTechies.DaysOfRefactoring.ReplaceException.After { public class Microwave { private IMicrowaveMotor Motor { get; set; } public bool Start(object food) { if (Motor.IsInUse) return false; Motor.Cook(food); return true; } } } 总结： 这个重构在项目代码中也经常用到，因为对于一部分程序员，是很难把握什么时候用try catch ，什么地方该用try catch。记得之前大家还专门讨论过这些，比如如何用好以及在大中型项目中应该把它放在哪一个组件中等。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:18:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"19.提取工厂类 概念：本文中的“提取工厂类”是指如果要创建的对象很多，则代码会变的很复杂。一种很好的方法就是提取工厂类。 正文：一般来说我们需要在代码中设置一些对象，以便获得它们的状态，从而使用对象，所谓的设置通常来说就是创建对象的实例并调用对象的方法。有时如果要创建的对象很多，则代码会变的很复杂。这便是工厂模式发挥作用的情形。工厂模式的复杂应用是使用抽象工厂创建对象集，但我们在这里只是使用基本的工厂类创建对象的一个简单应用。 如下代码所示，New方法包含创建类的整个逻辑，如果现在要创建的类比较多而且逻辑比较复杂的话（如根据不同条件创建对象，什么时候创建对象），我们的New方法逻辑会变得很大，同时代码也变得很难维护。所以我们就会采用提取工厂类的方式进行提炼。 那么重构后的代码如下，New方法变得很简单了，指需要调用实现接IPoliceCarFactory 接口的PoliceCarFactory 类就可以返回对象，这样就隔开了创建对象的逻辑，如果需求现在变为根据不同的条件创建不同的对象，什么时候创建对象等都变成了比较简单的事情，在后期可以把对象都配置在XML里面，使用反射的方式实现IOC注入创建。 namespace LosTechies.DaysOfRefactoring.ExtractServiceClass.Before { public class PoliceCarController { public PoliceCar New(int mileage, bool serviceRequired) { PoliceCar policeCar = new PoliceCar(); policeCar.ServiceRequired = serviceRequired; policeCar.Mileage = mileage; return policeCar; } } } namespace LosTechies.DaysOfRefactoring.ExtractServiceClass.After { public interface IPoliceCarFactory { PoliceCar Create(int mileage, bool serviceRequired); } public class PoliceCarFactory : IPoliceCarFactory { public PoliceCar Create(int mileage, bool serviceRequired) { PoliceCar policeCar = new PoliceCar(); policeCar.ReadForService = serviceRequired; policeCar.Mileage = mileage; return policeCar; } } public class PoliceCarController { public IPoliceCarFactory PoliceCarFactory { get; set; } public PoliceCarController(IPoliceCarFactory policeCarFactory) { PoliceCarFactory = policeCarFactory; } public PoliceCar New(int mileage, bool serviceRequired) { return PoliceCarFactory.Create(mileage, serviceRequired); } } } 总结：这个重构经常会在项目中使用，如果要创建的对象是一个，你可以采用简单工厂，但是这种方式还是会存在很多依赖，维护起来也比较不方便。所以推荐使用工厂方法模式，把实例化延迟到子类。如果你要创建一系列的对象，那么就推荐你使用抽象工厂模式，但是要注意不要过度设计，只要能满足不断变化的需求和给以后的维护和重构带来方便即可。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:19:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"20.提取子类 概念：本文中的”提取子类”是指把基类中的一些不是所有子类都需要访问的方法调整到子类中。 正文：当你的基类中存在一些方法不是所有的子类都需要访问，你想将它们调整到子类中时，这个重构会变得很有用了。如下代码所示，我们需要一个 Registration类用来处理学生选课的信息。但是当Registration类开始工作后，我们意识到我们会在两种不同的上下文中使用 Registration类，NonRegistrationAction和Notes只有在我们处理未注册情况下才用到。 所以我们将NonRegistration和Notes提到单独的NonRegistration类中。 重构后的代码如下所示，这样也满足面向对象五大原则之一的单一职责。同时也让类的结构变得更加清晰，增强了可维护性。 using System; namespace LosTechies.DaysOfRefactoring.SampleCode.ExtractSubclass.Before { public class Registration { public NonRegistrationAction Action { get; set; } public decimal RegistrationTotal { get; set; } public string Notes { get; set; } public string Description { get; set; } public DateTime RegistrationDate { get; set; } } } using System; namespace LosTechies.DaysOfRefactoring.SampleCode.ExtractSubclass.After { public class Registration { public decimal RegistrationTotal { get; set; } public string Description { get; set; } public DateTime RegistrationDate { get; set; } } public class NonRegistration : Registration { public NonRegistrationAction Action { get; set; } public string Notes { get; set; } } } 总结：这个重构方法经常用来规范类的职责，和之前的一些重构方法也有些类似。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:20:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"21.合并继承 概念：本文中的”合并继承”是指如果子类的属性和方法也适合于基类，那么就可以移除子类，从而减少依赖关系。 正文：上一篇我们讲到“提取子类”重构是指当基类中的一个责任不被所有的子类所需要时，将这些责任提取到合适的子类中。而我们今天所要讲的的“合并继承”重构一般用在当我们觉得不需要子类的时候。 如下代码所示，StudentWebSite子类除了有一个属性用来说明网站是否是活动的外没有别的责任，在这种情形下我们意识到IsActive属性可以应用到所有的网站，所以我们可以将IsActive属性上移到基类中，并去掉StudentWebSite类。 重构后的代码如下： using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.SampleCode.CollapseHierarchy.Before { public class Website { public string Title { get; set; } public string Description { get; set; } public IEnumerable\u003cWebpage\u003e Pages { get; set; } } public class StudentWebsite : Website { public bool IsActive { get; set; } } } using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.SampleCode.CollapseHierarchy.After { public class Website { public string Title { get; set; } public string Description { get; set; } public IEnumerable\u003cWebpage\u003e Pages { get; set; } public bool IsActive { get; set; } } } 总结： 这篇和上篇其实最主要论述了子类和父类的继承关系以及如何判断什么时候需要使用继承，一般我们都能处理好这些关系，所以相对比较简单。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:21:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"22.分解方法 概念：本文中的”分解方法”是指把我们所做的这个功能不停的分解方法，直到将一个大方法分解为名字有意义且可读性更好的若干个小方法。 正文：如下代码所示，因为现实中AcceptPayment方法不会做这么多的事情。，所以我们通过几次分解将 AcceptPayment拆分成若干个名字有意义且可读性更好的小方法。 重构后的代码如下，我们把AcceptPayment的内部逻辑拆分成了CalculateSubtotal、SubtractDiscounts、AddTax、SubtractFromCustomerBalance四个功能明确且可读性更好的小方法。 using System.Collections.Generic; using System.Linq; namespace LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.Before { public class CashRegister { public CashRegister() { Tax = 0.06m; } private decimal Tax { get; set; } public void AcceptPayment(Customer customer, IEnumerable\u003cProduct\u003e products, decimal payment) { decimal subTotal = 0m; foreach (Product product in products) { subTotal += product.Price; } foreach (Product product in products) { subTotal -= product.AvailableDiscounts; } decimal grandTotal = subTotal * Tax; customer.DeductFromAccountBalance(grandTotal); } } public class Customer { public void DeductFromAccountBalance(decimal amount) { // deduct from balance } } public class Product { public decimal Price { get; set; } public decimal AvailableDiscounts { get; set; } } } using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After { public class CashRegister { public CashRegister() { Tax = 0.06m; } private decimal Tax { get; set; } private IEnumerable\u003cProduct\u003e Products { get; set; } public void AcceptPayment(Customer customer, IEnumerable\u003cProduct\u003e products, decimal payment) { decimal subTotal = CalculateSubtotal(); subTotal = SubtractDiscounts(subTotal); decimal grandTotal = AddTax(subTotal); SubtractFromCustomerBalance(customer, grandTotal); } private void SubtractFromCustomerBalance(Customer customer, decimal grandTotal) { customer.DeductFromAccountBalance(grandTotal); } private decimal AddTax(decimal subTotal) { return subTotal * Tax; } private decimal SubtractDiscounts(decimal subTotal) { foreach (Product product in Products) { subTotal -= product.AvailableDiscounts; } return subTotal; } private decimal CalculateSubtotal() { decimal subTotal = 0m; foreach (Product product in Products) { subTotal += product.Price; } return subTotal; } } public class Customer { public void DeductFromAccountBalance(decimal amount) { // deduct from balance } } public class Product { public decimal Price { get; set; } public decimal AvailableDiscounts { get; set; } } } 总结：其实这个重构和我们前面讲的“提取方法”和“提取方法对象”如出一辙，尤其是“提取方法”，所以大家只要知道用这种思想重构就行。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:22:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"23.引入参数对象 概念：本文中的“引入参数对象”是指当一个方法的参数过多或者过为复杂时，可以考虑把这些参数封装成一个单独的类。 正文：如果一个方法所需要的参数大于5个，理解该方法的签名就变得比较困难，因为这样感觉参数很长、样式不好并且没有分类，所以我们有必要把参数进行封装。 通常这种情形下创建一个用户传递参数的类是很有帮助的，这会使得代码更容易明白也更灵活，因为当你需要增加参数时，只需要给参数类添加一个属性即可。请注意只有当你发现方法的参数比较多时才应该应用该重构，如果方法的参数比较少，就没有必要应用此重构，因为该重构会增加系统中类的数量，同时也会加大维护负担。所以要看参数情况而定。 重构后的代码如下： namespace LosTechies.DaysOfRefactoring.SampleCode.ParameterObject.Before { public class Registration { public void Create(decimal amount, Student student, IEnumerable\u003cCourse\u003e courses, decimal credits) { // do work } } } using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.SampleCode.ParameterObject.After { public class RegistrationContext { public decimal Amount { get; set; } public Student Student { get; set; } public IEnumerable\u003cCourse\u003e Courses { get; set; } public decimal Credits { get; set; } } public class Registration { public void Create(RegistrationContext registrationContext) { // do work } } } 总结：这种重构很重要，尤其是当一个方法的参数比较多的时候，不管是大中型项目还是小型项目，都会遇到这种场景，所以建议大家多使用这个重构。这种封装的思想在SOA 里面也经常运用到，封装输入Message，封装输出Message，消息来和消息去以及消息间的交互就构成了整个应用体系。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:23:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"24.分解复杂判断 概念：本文中的”分解复杂判断”是指把原来复杂的条件判断等语句用尽快返回等方式简化代码。 正文：简单的来说，当你的代码中有很深的嵌套条件时，花括号就会在代码中形成一个长长的箭头。我们经常在不同的代码中看到这种情况，并且这种情况也会扰乱代码的可读性。 如下代码所示，HasAccess方法里面包含一些嵌套条件，如果再加一些条件或者增加复杂度，那么代码就很可能出现几个问题：1，可读性差。 2，很容易出现异常。 3，性能较差。 那么重构上面的代码也很简单，如果有可能的话，尽量将条件从方法中移除，我们让代码在做处理任务之前先检查条件，如果条件不满足就尽快返回，不继续执行。下面是重构后的代码： using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace LosTechies.DaysOfRefactoring.SampleCode.ArrowheadAntipattern.Before { public class Security { public ISecurityChecker SecurityChecker { get; set; } public Security(ISecurityChecker securityChecker) { SecurityChecker = securityChecker; } public bool HasAccess(User user, Permission permission, IEnumerable\u003cPermission\u003e exemptions) { bool hasPermission = false; if (user != null) { if (permission != null) { if (exemptions.Count() == 0) { if (SecurityChecker.CheckPermission(user, permission) || exemptions.Contains(permission)) { hasPermission = true; } } } } return hasPermission; } } } using System.Collections.Generic; using System.Linq; namespace LosTechies.DaysOfRefactoring.SampleCode.ArrowheadAntipattern.After { public class Security { public ISecurityChecker SecurityChecker { get; set; } public Security(ISecurityChecker securityChecker) { SecurityChecker = securityChecker; } public bool HasAccess(User user, Permission permission, IEnumerable\u003cPermission\u003e exemptions) { if (user == null || permission == null) return false; if (exemptions.Contains(permission)) return true; return SecurityChecker.CheckPermission(user, permission); } } } 总结：这个重构很重要，它和后面讲的”尽快返回“有些类似，我们在做复杂的处理过程时，要经常考虑这个重构，用好了它，会对我们的帮助很大。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:24:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"25.引入契约式设计 概念：本文中的”引入契约式设计”是指我们应该对应该对输入和输出进行验证，以确保系统不会出现我们所想象不到的异常和得不到我们想要的结果。 正文：契约式设计规定方法应该对输入和输出进行验证，这样你便可以保证你得到的数据是可以工作的，一切都是按预期进行的，如果不是按预期进行，异常或是错误就应该被返回，下面我们举的例子中，我们方法中的参数可能会值为null的情况，在这种情况下由于我们没有验证，NullReferenceException异常会报出。另外在方法的结尾处我们也没有保证会返回一个正确的decimal值给调用方法的对象。 对上面的代码重构是很简单的，首先我们处理不会有一个null值的customer对象，检查我们最少会有一个product对象。在返回订单总和 之前先确保我们会返回一个有意义的值。如果上面说的检查有任何一个失败，我们就抛出对应的异常，并在异常里说明错误的详细信息，而不是直接抛出 NullReferenceException。 上面的代码中添加了额外的代码来进行验证，虽然看起来代码复杂度增加了，但我认为这是非常值得做的，因为当NullReferenceException发生时去追查异常的详细信息真是很令人讨厌的事情。 using System;using System.Collections.Generic; using System.Linq;using System.Text; namespace LosTechies.DaysOfRefactoring.SampleCode.Day25_DesignByContract { public class CashRegister { public decimal TotalOrder(IEnumerable\u003cProduct\u003e products, Customer customer) { decimal orderTotal = products.Sum(product =\u003e product.Price); customer.Balance += orderTotal; return orderTotal; } } } using System; using System.Collections.Generic; using System.Linq; using System.Text; using Microsoft.Contracts; namespace LosTechies.DaysOfRefactoring.SampleCode.DesignByContract.After { public class CashRegister { public decimal TotalOrder(IEnumerable\u003cProduct\u003e products, Customer customer) { if (customer == null) throw new ArgumentNullException(\"customer\", \"Customer cannot be null\"); if (products.Count() == 0) throw new ArgumentException(\"Must have at least one product to total\", \"products\"); decimal orderTotal = products.Sum(product =\u003e product.Price); customer.Balance += orderTotal; if (orderTotal == 0) throw new ArgumentOutOfRangeException(\"orderTotal\", \"Order Total should not be zero\"); return orderTotal; } } } 总结：微软在处理代码乃至产品的时候，很喜欢应用此重构，你如果认真看它的代码库，认真看一下WCF的设计，就不难发现了。这个重构建议大家经常使用，这会增强整个系统的稳定性和健壮性。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:25:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"26.避免双重否定 概念：本文中的”避免双重否定”是指把代码中的双重否定语句修改成简单的肯定语句，这样即让代码可读，同时也给维护带来了方便。 正文：避免双重否定重构本身非常容易实现，但我们却在太多的代码中见过因为双重否定降低了代码的可读性以致于非常让人容易误解真正意图。存在双重否定的代码具有非常大的危害性，因为这种类型的代码容易引起错误的假设，错误的假设又会导致书写出错误的维护代码，最终会导致bug产生。具 体可以看下面的代码： 如上代码中的双重否定可读性非常低，因为我们很难搞明白双重否定的正确值。要重构它也非常容易，如下是重构后的代码： using System.Collections.Generic; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; namespace LosTechies.DaysOfRefactoring.SampleCode.DoubleNegative.Before { public class Order { public void Checkout(IEnumerable\u003cProduct\u003e products, Customer customer) { if (!customer.IsNotFlagged) { // the customer account is flagged // log some errors and return return; } // normal order processing } } public class Customer { public decimal Balance { get; private set; } public bool IsNotFlagged { get { return Balance \u003c 30m; } } } } using System.Collections.Generic; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; namespace LosTechies.DaysOfRefactoring.SampleCode.DoubleNegative.After { public class Order { public void Checkout(IEnumerable\u003cProduct\u003e products, Customer customer) { if (customer.IsFlagged) { // the customer account is flagged // log some errors and return return; } // normal order processing } } public class Customer { public decimal Balance { get; private set; } public bool IsFlagged { get { return Balance \u003e= 30m; } } } } 总结： ”双重否定“很容易让人产生错误的判断，也很难让人理解你的代码，所以这个重构在我们的代码中是很重要的，尤其是在判断条件很多且业务复杂的时候。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:26:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"27.去除上帝类 概念：本文中的”去除上帝类”是指把一个看似功能很强且很难维护的类，按照职责把自己的属性或方法分派到各自的类中或分解成功能明确的类，从而去掉上帝类。 正文：我们经常可以在一些原来的代码中见到一些类明确违反了SRP原则（单一原则），这些类通常以“Utils”或“Manager”后缀 结尾，但有时这些类也没有这些特征，它仅仅是多个类多个方法的组合。另一个关于上帝类的特征是通常这些类中的方法被用注释分隔为不同的分组。那么久而久之，这些类被转换为那些没有人愿意进行归并到合适类的方法的聚集地，对这些类进行重构是将类中的代码按照职责分派到各自的类中，这样就解除了上帝类，也减轻了维护的负担。 我们看到要重构上面的代码是很简单的，只要将相关的方法按职责分派到对应的类中即可，带来的好处就是这会降低代码的颗粒度并减少未来维护代码的成本。下面是重构后的代码，它将上面的代码按照职责分为了两个不同的类。 using System.Collections.Generic; using LosTechies.DaysOfRefactoring.EncapsulateCollection.After; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; using Customer = LosTechies.DaysOfRefactoring.BreakResponsibilities.After.Customer; namespace LosTechies.DaysOfRefactoring.SampleCode.RemoveGodClasses.Before { public class CustomerService { public decimal CalculateOrderDiscount(IEnumerable\u003cProduct\u003e products, Customer customer) {$$ // do work } public bool CustomerIsValid(Customer customer, Order order) { // do work } public IEnumerable\u003cstring\u003e GatherOrderErrors(IEnumerable\u003cProduct\u003e products, Customer customer) { // do work } public void Register(Customer customer) { // do work } public void ForgotPassword(Customer customer) { // do work } } } using System.Collections.Generic; using LosTechies.DaysOfRefactoring.EncapsulateCollection.After; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; using Customer = LosTechies.DaysOfRefactoring.BreakResponsibilities.After.Customer; namespace LosTechies.DaysOfRefactoring.SampleCode.RemoveGodClasses.After { public class CustomerOrderService { public decimal CalculateOrderDiscount(IEnumerable\u003cProduct\u003e products, Customer customer) { // do work } public bool CustomerIsValid(Customer customer, Order order) { // do work } public IEnumerable\u003cstring\u003e GatherOrderErrors(IEnumerable\u003cProduct\u003e products, Customer customer) { // do work } } public class CustomerRegistrationService { public void Register(Customer customer) { // do work } public void ForgotPassword(Customer customer) { // do work } } } 总结： ”去除上帝类“是我们经常容易造成的，第一是因为简便，看到有一个现成的类，大家都会喜欢把代码往里面写，最后导致越写越大，并且声明功能都有，这样即降低了可读性，也造成了维护的负担。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:27:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"28.为布尔方法命名 概念：本文中的”为布尔方法命名”是指如果一个方法带有大量的bool 参数时，可以根据bool 参数的数量，提取出若干个独立的方法来简化参数。 正文：我们现在要说的重构并不是普通字面意义上的重构，它有很多值得讨论的地方。当一个方法带有大量的bool 参数时，会导致方法很容易被误解并产生非预期的行为， 根据布尔型参数的数量，我们可以决定提取出若干个独立的方法来。具体代码如下： 我们可以将上面的bool参数以独立方法的形式暴露给调用端以提高代码的可读性，同时我们还需要将原来的方法改为private以限制其可访问性。显然我们关于要 提取的独立方法会有一个很大的排列组合，这是一大缺点，所以我们可以考虑引入”参数对象“重构。 using LosTechies.DaysOfRefactoring.BreakResponsibilities.After; namespace LosTechies.DaysOfRefactoring.SampleCode.RenameBooleanMethod.Before { public class BankAccount { public void CreateAccount(Customer customer, bool withChecking, bool withSavings, bool withStocks) { // do work } } } using LosTechies.DaysOfRefactoring.BreakResponsibilities.After; namespace LosTechies.DaysOfRefactoring.SampleCode.RenameBooleanMethod.After { public class BankAccount { public void CreateAccountWithChecking(Customer customer) { CreateAccount(customer, true, false); } public void CreateAccountWithCheckingAndSavings(Customer customer) { CreateAccount(customer, true, true); } private void CreateAccount(Customer customer, bool withChecking, bool withSavings) { // do work } } } 总结： ”为布尔方法命名“这个重构在很多时候都不常用，如果用户的参数可枚举，我们一般会枚举它的值，不过使用这种重构也有好处，就是分解开来以后，方法多了，参数少了，代码维护起来方便了一些。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:28:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"29.去除中间人对象 概念：本文中的”去除中间人对象”是指把在中间关联而不起任何其他作用的类移除，让有关系的两个类直接进行交互。 正文：有些时候在我们的代码会存在一些”幽灵类“，设计模式大师Fowler称它们为“中间人”类，“中间人”类除了调用别的对象之外不做任何事情，所以“中间人”类没有存在的必要，我们可以将它们从代码中删除，从而让交互的两个类直接关联。 如下代码所示，Consumer 类要得到AccountDataProvider 的数据，但中间介入了没起任何作用的AccountManager 类来关联，所以我们应当移除。 重构后的代码如下所示，Consumer 和AccountDataProvider 直接进行关联，这样代码就简单了。 using LosTechies.DaysOfRefactoring.PullUpField.After; namespace LosTechies.DaysOfRefactoring.SampleCode.RemoveMiddleMan.Before { public class Consumer { public AccountManager AccountManager { get; set; } public Consumer(AccountManager accountManager) { AccountManager = accountManager; } public void Get(int id) { Account account = AccountManager.GetAccount(id); } } public class AccountManager { public AccountDataProvider DataProvider { get; set; } public AccountManager(AccountDataProvider dataProvider) { DataProvider = dataProvider; } public Account GetAccount(int id) { return DataProvider.GetAccount(id); } } public class AccountDataProvider { public Account GetAccount(int id) { // get account } } } using LosTechies.DaysOfRefactoring.PullUpField.After; namespace LosTechies.DaysOfRefactoring.SampleCode.RemoveMiddleMan.After { public class Consumer { public AccountDataProvider AccountDataProvider { get; set; } public Consumer(AccountDataProvider dataProvider) { AccountDataProvider = dataProvider; } public void Get(int id) { Account account = AccountDataProvider.GetAccount(id); } } public class AccountDataProvider { public Account GetAccount(int id) { // get account } } } 总结： ”去除中间人对象“很多时候都会很有作用，尤其是在误用设计模式的代码中最容易见到，设计模式中的适配器模式和代理模式等都用中间的类是两者进行关联，这是比较合理的，因为中间类做了很多事情，而对于没有任何作用的中间类应该移除。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:29:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"30.尽快返回 概念： 本文中的”尽快返回”是指把原来复杂的条件判断等语句用尽快返回的方式简化代码。 正文：如首先声明的是前面讲的”分解复杂判断“，简单的来说，当你的代码中有很深的嵌套条件时，花括号就会在代码中形成一个长长的箭头。我们经常在不同的代码中看到这种情况，并且这种情况也会扰乱代码的可读性。下代码所示，HasAccess方法里面包含一些嵌套条件，如果再加一些条件或者增加复杂度，那么代码就很可能出现几个问题：1，可读性差 2，很容易出现异常 3，性能较差 那么重构上面的代码也很简单，如果有可能的话，尽量将条件判断从方法中移除，我们让代码在做处理任务之前先检查条件，如果条件不满足就尽快返回，不继续执行。 下面是重构后的代码： using System.Collections.Generic; using System.Linq; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; using Customer = LosTechies.DaysOfRefactoring.BreakResponsibilities.After.Customer; namespace LosTechies.DaysOfRefactoring.SampleCode.ReturnASAP.Before { public class Order { public Customer Customer { get; private set; } public decimal CalculateOrder(Customer customer, IEnumerable\u003cProduct\u003e products, decimal discounts) { Customer = customer; decimal orderTotal = 0m; if (products.Count() \u003e 0) { orderTotal = products.Sum(p =\u003e p.Price); if (discounts \u003e 0) { orderTotal -= discounts; } } return orderTotal; } } } using System.Collections.Generic; using System.Linq; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; using Customer = LosTechies.DaysOfRefactoring.BreakResponsibilities.After.Customer; namespace LosTechies.DaysOfRefactoring.SampleCode.ReturnASAP.After { public class Order { public Customer Customer { get; private set; } public decimal CalculateOrder(Customer customer, IEnumerable\u003cProduct\u003e products, decimal discounts) { if (products.Count() == 0) return 0; Customer = customer; decimal orderTotal = products.Sum(p =\u003e p.Price); if (discounts == 0) return orderTotal; orderTotal -= discounts; return orderTotal; } } } 总结： 总结：这个重构很重要，它和前面讲的”分解复杂判断“有些类似，我们在做复杂的处理过程时，要经常考虑这个重构，用好了它，会对我们的帮助很大。 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:30:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["数据与算法"],"content":"31.使用多态代替条件判断 概念：本文中的”使用多态代替条件判断”是指如果你需要检查对象的类型或者根据类型执行一些操作时，一种很好的办法就是将算法封装到类中，并利用多态性进行抽象调用。 正文：本文展示了面向对象编程的基础之一“多态性”， 有时你需要检查对象的类型或者根据类型执行一些操作时，一种很好的办法就是将算法封装到类中，并利用多态性进行抽象调用。 如下代码所示，OrderProcessor 类的ProcessOrder方法根据Customer 的类型分别执行一些操作，正如上面所讲的那样，我们最好将OrderProcessor 类中这些算法（数据或操作）封装在特定的Customer 子类中。 重构后的代码如下，每个Customer 子类都封装自己的算法，然后OrderProcessor 类的ProcessOrder方法的逻辑也变得简单并且清晰了。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; namespace LosTechies.DaysOfRefactoring.SampleCode.ReplaceWithPolymorphism.Before { public abstract class Customer { } public class Employee : Customer { } public class NonEmployee : Customer { } public class OrderProcessor { public decimal ProcessOrder(Customer customer, IEnumerable\u003cProduct\u003e products) { // do some processing of order decimal orderTotal = products.Sum(p =\u003e p.Price); Type customerType = customer.GetType(); if (customerType == typeof(Employee)) { orderTotal -= orderTotal * 0.15m; } else if (customerType == typeof(NonEmployee)) { orderTotal -= orderTotal * 0.05m; } return orderTotal; } } } using System; using System.Collections.Generic; using System.Linq; using System.Text; using LosTechies.DaysOfRefactoring.SampleCode.BreakMethod.After; namespace LosTechies.DaysOfRefactoring.SampleCode.ReplaceWithPolymorphism.After { public abstract class Customer { public abstract decimal DiscountPercentage { get; } } public class Employee : Customer { public override decimal DiscountPercentage { get { return 0.15m; } } } public class NonEmployee : Customer { public override decimal DiscountPercentage { get { return 0.05m; } } } public class OrderProcessor { public decimal ProcessOrder(Customer customer, IEnumerable\u003cProduct\u003e products) { // do some processing of order decimal orderTotal = products.Sum(p =\u003e p.Price); orderTotal -= orderTotal * customer.DiscountPercentage; return orderTotal; } } } 总结： ”使用多态代替条件判断“这个重构在很多时候会出现设计模式中（常见的工厂家族、策略模式等都可以看到它的影子），因为运用它可以省去很多的条件判断，同时也能简化代码、规范类和对象之间的职责。 版权声明：本文为CSDN博主「kunlong0909」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/kunlong0909/article/details/47606791 ","date":"2021-06-05","objectID":"https://blog.gethin.online/refactoring-reprinted/:31:0","tags":["重构"],"title":"[转载]C#重构经典全面汇总","uri":"https://blog.gethin.online/refactoring-reprinted/"},{"categories":["架构艺术"],"content":"概述 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"什么是Redis Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。 Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。 与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis有哪些优缺点 优点 读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。 支持数据持久化，支持AOF和RDB两种持久化方式。 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。 数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。 缺点 数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。 Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"为什么要用 Redis /为什么要用缓存 主要从“高性能”和“高并发”这两点来看待这个问题。 高性能： 假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！ 高并发： 直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"为什么要用 Redis 而不用 map/guava 做缓存? 缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。 使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis为什么这么快 1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)； 2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的； 3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 4、使用多路 I/O 复用模型，非阻塞 IO； 5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:1:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"数据类型 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:2:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis有哪些数据类型 Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求 数据类型 可以存储的值 操作 应用场景 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作, 对整数和浮点数执行自增或者自减操作 做简单的键值对缓存 LIST 列表 从两端压入或者弹出元素,对单个或者多个元素进行修剪;只保留一个范围内的元素 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据 SET 无序集合 添加、获取、移除单个元素;检查一个元素是否存在于集合中;计算交集、并集、差集; 从集合里面随机获取元素 交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对;获取所有键值对;检查某个键是否存在 结构化的数据，比如一个对象 ZSET 有序集合 添加、获取、删除元素;根据分值范围或者成员来获取元素;计算一个键的排名 去重但可以排序，如获取排名前几名的用户 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:2:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis的应用场景 总结一 计数器: 可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 缓存: 将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 会话缓存: 可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。 全页缓存（FPC）: 除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 查找表: 例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 消息队列(发布/订阅功能): List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。 分布式锁实现: 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。 其它: Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。 总结二 Redis相比其他缓存，有一个非常大的优势，就是支持多种数据类型。 数据类型说明string字符串，最简单的k-v存储hashhash格式，value为field和value，适合ID-Detail这样的场景。list简单的list，顺序列表，支持首位或者末尾插入数据set无序list，查找速度快，适合交集、并集、差集处理sorted set有序的set 其实，通过上面的数据类型的特性，基本就能想到合适的应用场景了。 string——适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。 hash——一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。 list——因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。 set——可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。 Sorted Set——是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。 如上所述，虽然Redis不像关系数据库那么复杂的数据结构，但是，也能适合很多场景，比一般的缓存数据结构要多。了解每种数据结构适合的业务场景，不仅有利于提升开发效率，也能有效利用Redis的性能。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:2:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"持久化 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"什么是Redis持久化？ 持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis 的持久化机制是什么？各自的优缺点？ Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制: RDB：是Redis DataBase缩写快照 RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。 优点： 1、只有一个文件 dump.rdb，方便持久化。 2、容灾性好，一个文件可以保存到安全的磁盘。 3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能 4.相对于数据集大时，比 AOF 的启动效率更高。 缺点： 1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候) 2、AOF（Append-only file)持久化方式： 是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。 AOF：持久化 AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。 当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。 优点： 1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。 2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。 3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）) 缺点： 1、AOF 文件比 RDB 文件大，且恢复速度慢。 2、数据集大的时候，比 rdb 启动效率低。 优缺点是什么？ AOF文件比RDB更新频率高，优先使用AOF还原数据。 AOF比RDB更安全也更大 RDB性能比AOF好 如果两个都配了优先加载AOF ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"如何选择合适的持久化方式 一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用RDB持久化。 有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。 如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis持久化数据和缓存怎么做扩容？ 如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。 如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:3:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"过期键的删除策略 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:4:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis的过期键的删除策略 我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。 过期策略通常有以下三种： 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。) Redis中同时使用了惰性过期和定期过期两种过期策略。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:4:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis key的过期时间和永久有效分别怎么设置？ EXPIRE和PERSIST命令。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:4:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢? 除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种： 定时去清理过期的缓存； 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:4:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"内存相关 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据 redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis的内存淘汰策略有哪些 Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。 全局的键空间选择性移除 noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的） allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。 设置过期时间的键空间选择性移除 volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。 volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。 volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。 总结 Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis主要消耗什么物理资源？ 内存。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis的内存用完了会发生什么？ 如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis如何做内存优化？ 可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:5:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"线程模型 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:6:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis线程模型 Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。 文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。 虽然文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性。 参考：https://www.cnblogs.com/barrywxx/p/8570821.html ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:6:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"事务 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"什么是事务？ 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis事务的概念 Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。 总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis事务的三个阶段 事务开始 MULTI 命令入队 事务执行 EXEC 事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis事务相关命令 Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。 redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。 如果在一个事务中的命令出现错误，那么所有的命令都不会执行； 如果在一个事务中出现运行错误，那么正确的命令会被执行。 WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。 MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。 EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。 UNWATCH命令可以取消watch对所有key的监控。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"事务管理（ACID）概述 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务前后数据的完整性必须保持一致。 隔离性（Isolation） 多个事务并发执行时，一个事务的执行不应影响其他事务的执行 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在_AOF_持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis事务支持隔离性吗 Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:6","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis事务保证原子性吗，支持回滚吗 Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:7","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis事务其他实现 基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行， 其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完 基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:7:8","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"集群方案 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"哨兵模式 哨兵的介绍 sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能： 集群监控：负责监控 redis master 和 slave 进程是否正常工作。 消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。 哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。 故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。 哨兵的核心知识 哨兵至少需要 3 个实例，来保证自己的健壮性。 哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。 对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"官方Redis Cluster 方案(服务端路由查询) redis 集群模式的工作原理能说一下么？在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？ 简介 Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。Redis Cluster并没有使用一致性hash，而是采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行 方案说明 通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位 每份数据分片会存储在多个互为主从的多节点上 数据写入先写主节点，再同步到从节点(支持配置为阻塞同步) 同一分片多个节点间的数据不保持一致性 读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点 扩容时时需要需要把旧节点的数据迁移一部分到新节点 在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。 16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。 节点间的内部通信机制 基本通信原理 集群元数据的维护有两种方式：集中式、Gossip 协议。redis cluster 节点间采用 gossip 协议进行通信。 分布式寻址算法 hash 算法（大量缓存重建） 一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡） redis cluster 的 hash slot 算法 优点 无中心架构，支持动态扩容，对业务透明 具备Sentinel的监控和自动Failover(故障转移)能力 客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可 高性能，客户端直连redis服务，免去了proxy代理的损耗 缺点 运维也很复杂，数据迁移需要人工干预 只能使用0号数据库 不支持批量操作(pipeline管道操作) 分布式逻辑和存储模块耦合等 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"基于客户端分配 简介 Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool 优点 优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强 缺点 由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。 客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"基于代理服务器分片 简介 客户端发送请求到一个代理组件，代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端 特征 透明接入，业务程序不用关心后端Redis实例，切换成本低 Proxy 的逻辑和存储的逻辑是隔离的 代理层多了一次转发，性能有所损耗 业界开源方案 Twtter开源的Twemproxy 豌豆荚开源的Codis ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis 主从架构 单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。 redis replication -\u003e 主从架构 -\u003e 读写分离 -\u003e 水平扩容支撑读高并发 redis replication 的核心机制 redis 采用异步方式复制数据到 slave 节点，不过 redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量； 一个 master node 是可以配置多个 slave node 的； slave node 也可以连接其他的 slave node； slave node 做复制的时候，不会 block master node 的正常工作； slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了； slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。 注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。 另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。 redis 主从复制的核心原理 当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。 如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件， 同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中， 接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。 slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。 过程原理 当从库和主库建立MS关系后，会向主数据库发送SYNC命令 主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来 当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis 从Redis接收到后，会载入快照文件并且执行收到的缓存的命令 之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致 缺点 所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis集群的主从复制模型是怎样的？ 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:6","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"生产环境中的 redis 是怎么部署的？ redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。 机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是10g内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。 5 台机器对外提供读写，一共有 50g 内存。 因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。 你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。 其实大型的公司，会有基础架构的 team 负责缓存集群的运维。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:7","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"说说Redis哈希槽的概念？ Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:8","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis集群会有写操作丢失吗？为什么？ Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:9","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis集群之间是如何复制的？ 异步复制 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:10","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis集群最大节点个数是多少？ 16384个 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:11","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis集群如何选择数据库？ Redis集群目前无法做数据库选择，默认在0数据库。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:8:12","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"分区 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis是单线程的，如何提高多核CPU的利用率？ 可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"为什么要做Redis分区？ 分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升，Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"你知道有哪些Redis分区实现方案？ 客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。 代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy 查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis分区有什么缺点？ 涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。 同时操作多个key,则不能使用Redis事务. 分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set） 当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。 分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:9:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"分布式问题 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis实现分布式锁 Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。 当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作 SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。 返回值：设置成功，返回 1 。设置失败，返回 0 。 使用SETNX完成同步锁的流程及事项如下： 使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功 为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间 释放锁，使用DEL命令将锁数据删除 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"如何解决 Redis 的并发竞争 Key 问题 所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！ 推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能） 基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。 在实践中，当然是从以可靠性为主。所以首推Zookeeper。 参考：https://www.jianshu.com/p/8bddd381de06 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"分布式Redis是前期做还是后期规模上来了再做好？为什么？ 既然Redis是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。 一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。 这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"什么是 RedLock Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性： 安全特性：互斥访问，即永远只有一个 client 能拿到锁 避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区 容错性：只要大部分 Redis 节点存活就可以正常提供服务 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:10:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存异常 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存雪崩 缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。 解决方案 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。 给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存穿透 缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。 解决方案 接口层增加校验，如用户鉴权校验，id做基础校验，id\u003c=0的直接拦截； 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力 附加 对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。 Bitmap： 典型的就是哈希表 缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。 布隆过滤器（推荐） 就是引入了k(k\u003e1)k(k\u003e1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。 Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。 Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。 Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存击穿 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 解决方案 设置热点数据永远不过期。 加互斥锁，互斥锁 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存预热 缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 解决方案 直接写个缓存刷新页面，上线时手工操作一下； 数据量不大，可以在项目启动的时候自动进行加载； 定时刷新缓存； ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存降级 当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 缓存降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。 在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案： 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警； 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。 服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"热点数据和冷数据 热点数据，缓存才有价值 对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存 对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。 数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。 那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:6","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"缓存热点key 缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 解决方案 对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:11:7","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"常用工具 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:12:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis支持的Java客户端都有哪些？官方推荐用哪个？ Redisson、Jedis、lettuce等等，官方推荐使用Redisson。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:12:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis和Redisson有什么关系？ Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:12:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Jedis与Redisson对比有什么优缺点？ Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:12:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"其他问题 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:0","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis与Memcached的区别 两者都是非关系型内存键值数据库，现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！Redis 与 Memcached 主要有以下不同： 对比参数 Redis Memcached 类型 1. 支持内存 2. 非关系型数据库 1. 支持内存 2. 键值对形式 3. 缓存形式 数据存储类型 1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】 1. 文本型 2. 二进制类型 查询【操作】类型 1. 批量操作 2. 事务支持 3. 每个类型不同的CRUD 1.常用的CRUD 2. 少量的其他命令 附加功能 1. 发布/订阅模式 2. 主从分区 3. 序列化支持 4. 脚本支持【Lua脚本】 1. 多线程服务支持 网络IO模型 1. 单线程的多路 IO 复用模型 1. 多线程，非阻塞IO模式 事件库 自封转简易事件库AeEvent 贵族血统的LibEvent事件库 持久化支持 1. RDB 2. AOF 不支持 集群模式 原生支持 cluster 模式，可以实现主从复制，读写分离 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据 内存管理机制 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘 Memcached 的数据则会一直在内存中，Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 适用场景 复杂数据结构，有持久化，高可用需求，value存储内容较大 纯key-value，数据量非常大，并发量非常大的业务 (1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 (2) redis的速度比memcached快很多 (3) redis可以持久化其数据 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:1","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"如何保证缓存与数据库双写时的数据一致性？ 你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？ 一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况 串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。 还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后再删除缓存。 问题场景 描述 解决 先写缓存，再写数据库，缓存写成功，数据库写失败 缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读 这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存 先写数据库，再写缓存，数据库写成功，缓存写失败 写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据 缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现 需要缓存异步刷新 指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候 确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:2","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis常见性能问题和解决方案？ Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。 如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。 为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。 尽量避免在压力较大的主库上增加从库 Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。 为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master\u003c–Slave1\u003c–Slave2\u003c–Slave3…，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:3","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis官方为什么不提供Windows版本？ 因为目前Linux版本已经相当稳定，而且用户量很大，无需开发windows版本，反而会带来兼容性等问题。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:4","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"一个字符串类型的值能存储最大容量是多少？ 512M ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:5","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis如何做大量数据插入？ Redis2.6开始redis-cli支持一种新的被称之为pipe mode的新模式用于执行大量数据插入工作。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:6","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？ 使用keys指令可以扫出指定模式的key列表。 对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？ 这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:7","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"使用Redis做过异步队列吗，是如何实现的 使用list类型保存数据信息，rpush生产消息，lpop消费消息，当lpop没有消息时，可以sleep一段时间，然后再检查有没有信息，如果不想sleep的话，可以使用blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis可以通过pub/sub主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:8","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis如何实现延时队列 使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:9","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis回收进程如何工作的？ 一个客户端运行了新的命令，添加了新的数据。 Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收。 一个新的命令被执行，等等。 所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。 如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:10","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"Redis回收使用的是什么算法？ LRU算法 版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/ThinkWon/article/details/103522351 ","date":"2021-06-04","objectID":"https://blog.gethin.online/redis-reprinted/:13:11","tags":[],"title":"[转载]Redis面试题","uri":"https://blog.gethin.online/redis-reprinted/"},{"categories":["架构艺术"],"content":"为什么使用MQ？MQ的优点 简答 异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。 流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。 日志处理 - 解决大量日志传输。 消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。 详答 主要是：解耦、异步、削峰。 解耦：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。 就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。 异步：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。 削峰：减少高峰时期对服务器压力。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:1:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息队列有什么优缺点？RabbitMQ有什么优缺点？ 优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。 缺点有以下几个： 系统可用性降低 本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低； 系统复杂度提高 加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。 一致性问题 A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。 所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:2:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"你们公司生产环境用的是什么消息中间件？ 这个首先你可以说下你们公司选用的是什么消息中间件，比如用的是RabbitMQ，然后可以初步给一些你对不同MQ中间件技术的选型分析。 举个例子：比如说ActiveMQ是老牌的消息中间件，国内很多公司过去运用的还是非常广泛的，功能很强大。 但是问题在于没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企业，用ActiveMQ做异步调用和系统解耦。 然后你可以说说RabbitMQ，他的好处在于可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。 另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。 而且经过调研，国内各大互联网公司落地大规模RabbitMQ集群支撑自身业务的case较多，国内各种中小型互联网公司使用RabbitMQ的实践也比较多。 除此之外，RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化，因此综合考虑过后，公司采取了RabbitMQ。 但是RabbitMQ也有一点缺陷，就是他自身是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以。 然后可以聊聊RocketMQ，是阿里开源的，经过阿里的生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。 而且RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。 另外就是Kafka。Kafka提供的消息中间件的功能明显较少一些，相对上述几款MQ中间件要少很多。 但是Kafka的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。 因此Kafka在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:3:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？ ActiveMQ RabbitMQ RocketMQ Kafka ZeroMQ 单机吞吐量 比RabbitMQ低 2.6w/s（消息做持久化） 11.6w/s 17.3w/s 29w/s 开发语言 Java Erlang Java Scala/Java C 主要维护者 Apache Mozilla/Spring Alibaba Apache iMatix，创始人已去世 成熟度 成熟 成熟 开源版本不够成熟 比较成熟 只有C、PHP等版本成熟 订阅形式 点对点(p2p)、广播（发布-订阅） 提供了4种：direct, topic ,Headers和fanout。fanout就是广播模式 基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式 基于topic以及按照topic进行正则匹配的发布订阅模式 点对点(p2p) 持久化 支持少量堆积 支持少量堆积 支持大量堆积 支持大量堆积 不支持 顺序消息 不支持 不支持 支持 支持 不支持 性能稳定性 好 好 一般 较差 很好 集群方式 支持简单集群模式，比如’主-备’，对高级集群模式支持不好。 支持简单集群，‘复制’模式，对高级集群模式支持不好。 常用 多对’Master-Slave’ 模式，开源版本需手动切换Slave变成Master 天然的‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave 不支持 管理界面 一般 较好 一般 无 无 综上，各种对比之后，有如下建议： 一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了； 后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高； 不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。 所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。 如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:4:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"MQ 有哪些常见问题？如何解决这些问题？ MQ 的常见问题有： 消息的顺序问题 消息的重复问题 消息的顺序问题 消息有序指的是可以按照消息的发送顺序来消费。 假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？ 解决方案： （1）保证生产者 - MQServer - 消费者是一对一对一的关系 缺陷： 并行度就会成为消息系统的瓶颈（吞吐量不够） 更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。 （2）通过合理的设计或者将问题分解来规避。 不关注乱序的应用实际大量存在 队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。 消息的重复问题 造成消息重复的根本原因是：网络不可达。 所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？ 消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:5:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"什么是RabbitMQ？ RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:6:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"rabbitmq 的使用场景 （1）服务间异步通信 （2）顺序消费 （3）定时任务 （4）请求削峰 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:7:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"RabbitMQ基本概念 Broker： 简单来说就是消息队列服务器实体 Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 Routing Key： 路由关键字，exchange根据这个关键字进行消息投递 VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。 Producer： 消息生产者，就是投递消息的程序 Consumer： 消息消费者，就是接受消息的程序 Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务 由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:8:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"RabbitMQ的工作模式 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"一.simple模式（即最简单的收发模式） 1.消息产生消息，将消息放入队列 2.消息的消费者(consumer) 监听 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失，这里可以设置成手动的ack,但如果设置成手动ack，处理完后要及时发送ack消息给队列，否则会造成内存溢出)。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:1","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"二.work工作模式(资源的竞争) 1.消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2同时监听同一个队列,消息被消费。C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用)。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:2","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"三.publish/subscribe发布订阅(共享资源) 1、每个消费者监听自己的队列； 2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:3","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"四.routing路由模式 1.消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息; 2.根据业务功能定义路由字符串 3.从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中。 4.业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误; ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:4","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"五.topic 主题模式(路由模式的一种) 1.星号井号代表通配符 2.星号代表多个单词,井号代表一个单词 3.路由功能添加模糊匹配 4.消息产生者产生消息,把消息交给交换机 5.交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费 （在我的理解看来就是routing查询的一种模糊匹配，就类似sql的模糊查询方式） ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:5","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证RabbitMQ消息的顺序性？ 拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:10:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息如何分发？ 若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:11:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息怎么路由？ 消息提供方-\u003e路由-\u003e一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）； 常用的交换器主要分为一下三种： fanout：如果交换器收到消息，将会广播到所有绑定的队列上 direct：如果路由键完全匹配，消息就被投递到相应的队列 topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:12:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息基于什么传输？ 由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:13:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？ 先说为什么会重复消费：正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除； 但是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。 针对以上问题，一个解决思路是：保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；保证消息等幂性； 比如：在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过； 假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:14:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？ 发送方确认模式 将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。 一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。 如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（notacknowledged，未确认）消息。 发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。 接收方确认机制 消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。 这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性； 下面罗列几种特殊情况 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重） 如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:15:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证RabbitMQ消息的可靠传输？ 消息不可靠的情况可能是消息丢失，劫持等原因； 丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息； 生产者丢失消息：从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息； transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降； confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后； rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了； 如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。 消息队列丢数据：消息持久化。 处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。 这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。 这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。 那么如何持久化呢？ 这里顺便说一下吧，其实也很容易，就下面两步 将queue的持久化标识durable设置为true,则代表是一个持久的队列 发送消息的时候将deliveryMode=2 这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据 消费者丢失消息：消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！ 消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息； 如果这时处理消息失败，就会丢失该消息； 解决方案：处理消息成功后，手动回复确认消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:16:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"为什么不应该对所有的 message 都使用持久化机制？ 首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多，message 的吞吐量可能有 10 倍的差距。 其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现“坑爹”问题。矛盾点在于，若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed ；若 message 设置了 persistent 属性，同时 queue 也设置了 durable 属性，那么当 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在这段时间内发送给该 queue 的 message 将被 blackholed 。 所以，是否要对 message 进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条/秒以上的消息吞吐量（单 RabbitMQ 服务器），则要么使用其他的方式来确保 message 的可靠 delivery ，要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。另外一种处理原则是：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:17:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证高可用的？RabbitMQ 的集群 RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。 单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式 普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。 镜像集群模式：这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:18:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？ 消息积压处理办法：临时紧急扩容： 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。 MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。 mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:19:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"设计MQ思路 比如说这个消息队列系统，我们从以下几个角度来考虑一下： 首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -\u003e topic -\u003e partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？ 其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。 其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -\u003e leader \u0026 follower -\u003e broker 挂了重新选举 leader 即可对外服务。 能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。 版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/ThinkWon/article/details/104588612 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:20:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"1 软件架构概述 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"1.1 软件架构的定义 架构是对系统的抽象，由多个架构组成，任何软件都存在架构，元素与其行为的集合构成架构内容，架构具有“基础性”，架构隐含有“决策”。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"1.2 软件架构重要性 项目关系人之间交流平台； 早期设计决策； 在较高层面上实现软件复用； 架构对开发的指导与规范意义不容忽略。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"1.3 架构的模型 结构模型；框架模型；动态模型；过程模型；功能模型； 逻辑视图，开发视图，进程视图，物理视图，场景。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"2 架构需求与软件质量属性 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:2:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"2.1 软件质量属性 功能性；可靠性；易用性；效率；可维护性；可移植性； 1 运行期质量属性 性能；安全性；易用性；可伸缩性；互操作性；可靠性；持续可用性；鲁棒性； 2 开发期质量属性 易理解性；可扩展性；可重用性；可测试性；可维护性； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:2:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"2.2 六个质量属性与实现 质量属性：可用性；可修改性；性能；安全性；可测试性；易用性； 质量属性场景组件：刺激源；刺激；环境；制品；响应；响应度量； 1 可用性与其实现战术 可用性描述 可用性战术 错误检测：命令/响应；心跳；异常； 错误恢复 表决；主动冗余；被动冗余；备件；状态再同步；检查点/回滚； 错误预防 从服务中删除；事务；进程监视器； 2 可修改性与其实现战术 可修改性描述 可修改性战术 局部化修改；(维持语义的一致性；预期期望的变更；泛化该模块；限制可能的选择) 防止连锁反应；（信息隐藏；维持现有的接口；限制通信路径；仲裁者的使用） 推迟绑定时间；（运行时注册；配置文件；多态；构件更换；） 3 性能与其实现技术 性能描述 性能战术 资源消耗：闭锁时间； 资源需求：减少处理事件流所需的资源；减少所处理事件的数量；控制资源的使用； 资源管理：引入并发；维持数据或计算的多个副本；增加可用资源； 资源仲裁：先进先出；固定优先级调度；动态优先级调度；静态调度； 4 安全性与其实现技术 安全性描述 安全性战术 抵抗攻击：对用户进行身份验证；对用户进行授权；维护数据的机密性；维护完整性；限制暴露的信息；限制访问； 检测攻击 从攻击中恢复：恢复；识别攻击者； 5 可测试性与其实现战术 可测试性描述 可测试性战术 输入/输出：记录回放；将接口与现实分离；优化访问线路 内部监控 6 易用性与实现战术 易用性描述 易用性战术 运行时战术：任务的模型；用户的模型；系统的模型； 设计时战术 支持用户主动操作 常见的六个质量属性:可用性、可修改性、性能、安全性、可测试性、易用性。 质量属性场景是一种面向特定的质量属性的需求，由6部分组成：刺激源、刺激、环境、制品、响应、响应度量。 以《淘宝网》为例： (1)可用性: 场景：天猫双十一购物狂欢节 刺激源：海量用户 刺激：过多用户涌入抢购，系统出现崩溃的状态 制品：处理系统崩溃的处理器 环境：正常操作 响应：淘宝网监控系统记录，处理人员进行紧急处理 响应度量：短时间内恢复系统正常运行 （2）可修改性： 场景：系统进行升级 刺激源：开发人员 刺激：改变页面的形态，增加少许功能、 制品：升级完后的系统 环境：设计时 响应：修改了用户的操作页面，未产生副作用 响应度量：在15分钟左右完成升级更改 （3）性能： 场景：天猫双十一购物狂欢节 刺激源：用户 刺激：进行疯狂购物交易 制品：系统 环境：在正常操作下 响应：大量的交易同时被处理 响应度量：每个交易平均等待时间为3s (4)安全性: 场景：黑客想要盗窃用户信息 刺激源：黑客 刺激：试图通过某些手段窃取用户的信息 制品：淘宝用户信息 环境：用户不在线时 响应：对访问者进行身份上的验证 响应度量：淘宝安全系统阻止黑客访问用户信息 （5）可测试性： 场景：一个马上要执行的系统功能 刺激源：系统测试人员 刺激：对系统功能执行测试 制品：系统的某个功能 环境：功能要部署时 响应：提供对状态值的访问、提供所要计算的值，准备测试环境 响应度量：3个小时测试了85% （6）易用性： 场景：用户误将某物品移入到购物车 刺激源：用户 刺激：用户想要将物品移出 制品：系统 环境；系统运行时 响应：希望快速完成操作 响应度量：在1s内完成撤销操作 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:2:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3 软件架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.1 软件架构风格分类 数据流风格：批处理序列；管道\\过滤器； 调用/返回风格：主程序、子程序；面型对象风格；层次结构； 独立构件风格：进程通信；事件系统； 虚拟机风格：解释器；基于规则的系统； 仓库风格：数据库系统；超文本系统；黑板系统； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.2 数据流风格 批处理序列：批处理风格的每一步处理都是独立的，并且每一步都是顺序的。 管道和过滤器：每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。 好处：良好的隐蔽性；高内聚低耦合；简单合成；支持重用；性能简单；允许死锁分析；支持并行执行； 弊端：导致进程成为批处理；不适合处理交互式应用； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.3 调用/返回风格 主程序/子程序 面向对象风格：对负责维护其表示的完整性；对象的表示对其他对象而言是隐蔽的； 层次结构风格：支持基于抽象程度递增的系统设计；支持功能增强；支持重用； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.4 独立构件风格 进程通信架构风格：构件是独立的过程，连接件是消息传递 事件系统风格：为软件重用提供了强大的支持；为还进系统带来了方便 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.5 虚拟机风格 解释器：包括完成解释工作的解释引擎，一个包含将被解释的代码储存区，一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的 规划为中心：基于规则的系统包括规则集、规则解释器，规则/数据选择器及工作内存 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:5","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.6 仓库风格 数据库系统、超文本系统、黑板风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:6","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4 层次系统架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.1 二层及三层C/S架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.2 B/S架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.3 MVC架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.4 MVP架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5 面向服务的架构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.1 SOA概述 5.1.1 服务基本结构 5.1.2 SOA设计原则 明确定义的接口、自包含和模块化、粗粒度、松耦合、互操作性。 5.1.3 服务构件和传统构件 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.2 SOA关键技术 UUDI（统一描述、发现集成） 数据模型、API、注册服务 WSDL（web服务描述语言） 服务实现定义：服务、端口 服务接口定义：绑定、端口类型、消息、类型 SOAP（简单对象访问协议） 封装；编码规则；RPC表示；绑定； SOAP消息：封装；SOAP头；SOAP体； REST（表述性状态转移） 网络上的所有事物都被抽象为资源 每个资源对应一个唯一资源标识 通过通用链接件接口对资源进行操作 对资源各种操作不会改变资源标识 所有操作都是无状态的 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.3 SOA的实现方法 Web Service 架构：服务提供者，服务请求者，服务注册者。 操作：发布，查找，绑定。 层次：底层传输层，服务通信协议层，服务描述层，服务层，业务流程层，服务注册层 服务注册表 服务注册，服务位置，服务绑定。 企业服务总线 功能： 支持异构环境中的服务，消息和基于事件的交互，并且具有适当的服务级别和可管理级别。 可以在几乎不更改代码的情况下，以一种无缝的非入侵方式使现有系统具有全新的服务接口，并能够在部署环境中支持任何标准 充当缓冲器的ESB于服务逻辑和分离，从而使不同的系统可以同时使用同一服务，不用在系统或数据变化时改动服务代码 ESB还提供服务代码和协议转换等功能，多种传输方式，发现和使用企业服务或界面提供基础设施。 提供可配置的消息转换翻译机制和基于消息内容的消息路由服务，传输消息到不同的目的地 提供安全和拥有者机制，保证消息和服务使用的认证，授权和完整性。 优势: 扩展的、基于标准的连接。 灵活的、服务导向的应用组合。 提高复用率。 减少市场的反应时间。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.4 微服务 优势： 技术异构性，弹性，扩展，简单部署，与组织结构相匹配，可组合性，对可替代的优化。 挑战： 分布式系统的复杂度，运维成本，部署自动化，DEVOPS与组织结构，服务间的依赖测试，服务间的依赖管理 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"6 架构设计 演变交付生命周期 属性驱动设计法ADD 按架构组织开发团队 开发骨架系统 利用商业构件进行开发 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:6:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"7 软件架构文档化 架构文档的使用者 合理的编写规则 从读者角度编写文档，避免出现不必要的重复，避免歧义，使用标准结构，记录基本原理，文档保持更新但注意频率，针对目标的适宜性对文档进行评审 视图编档 视图概述，元素目录，上下文图，可变性指南，架构背景，术语表，其他信息。 跨视图文档 UML 软件架构重构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:7:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8 软件架构评估 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8.1 软件架构评估方法 基于调查问卷 基于场景 基于度量 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8.2 架构的权衡分析法ATAM 一个简洁的架构表述 表达清楚的业务目标 用场景集合捕获质量需求 架构决策到质量需求的映射 所确定的敏感点与权衡点的集合 有风险决策和无风险决策 风险主题集合 产生一些附属结果 产生一些无形的结果 步骤： ATAM方法表述 商业动机表述 架构表述 对架构方法进行分类 生成质量属性效用树 分析架构方法 集体讨论并确定场景优先级 分析架构方法 结果的表述 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8.3 成本效益分析法CBAM 步骤： 整理场景，对场景进行求精，确定场景优先级，分配效用，策略-场景-响应，质量属性响应级别效用，各架构策略的总收益， ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9 构件及其复用 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9.1 商用构件标准规范 CORBA，J2EE，DNA 2000 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9.2 应用系统簇与构件系统 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9.3 基于服用开发的组织结构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10 产品线及系统演化 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.1 复用与产品线 需求，架构设计，元素，建模与分析，测试，项目规划，过程、方法和工具，人员，样本系统，缺陷消除 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.2 基于产品线的架构 三个方面：确定变化点，支持变化点，对产品线架构的适宜性进行评估 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.3 产品线的开发模型 前瞻性产品线，反应性模型 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.4 特定领域软件架构 领域模型为需求定义率领域知识和领域词汇 软件界面的设计往往和领域模型关系密切 领域模型的合理性将严重影响软件系统的可扩展性 在分层架构指导下，领域模型精华后即成为业务层骨架 领域模型也是其数据模型的基础 领域模型是团队交流的基础 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.4 架构及系统演化 需求变动归类，制订架构演化计划，修改增加删除构件，更新构件的互相作用，构架组装和测试，技术评审，产生演化后的架构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:5","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11 软件架构视图 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.1 软件视图分类 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.2 模块视图类型及其风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.3 C\u0026C视图类型及其风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.4 分配视图类型及其风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.5 各视图类型间的映射关系 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:5","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["概要"],"content":"自定义扩展 ","date":"2021-05-26","objectID":"https://blog.gethin.online/second-post/:1:0","tags":[],"title":"自定义扩展功能测试","uri":"https://blog.gethin.online/second-post/"},{"categories":["概要"],"content":"脑图测试 Root l1 l11 l12 l2 l12 l121 l122 l13 l3 l31 l313 l323 Test1 ABC 2021 function non0plural(number, name) { if (number == 0) { return \"\" } if (number == 1 || number == -1) { return number + \" \" +name } return number + \" \" + name + \"s\" } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2021-05-01\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 let years = 0 if (months Test 11 months ABC 2020 ","date":"2021-05-26","objectID":"https://blog.gethin.online/second-post/:1:1","tags":[],"title":"自定义扩展功能测试","uri":"https://blog.gethin.online/second-post/"},{"categories":["概要"],"content":"网站功能 文章加密 自定义域名 网站分析 脑图 时间轴 评论的优化 关于页面的优化 版权声明 运行时间 赞赏 网站流量统计 ","date":"2021-05-22","objectID":"https://blog.gethin.online/blog-todo/:1:0","tags":["待办事项"],"title":"博客代办事项","uri":"https://blog.gethin.online/blog-todo/"},{"categories":["概要"],"content":"编辑 新文章头部模板 ","date":"2021-05-22","objectID":"https://blog.gethin.online/blog-todo/:2:0","tags":["待办事项"],"title":"博客代办事项","uri":"https://blog.gethin.online/blog-todo/"},{"categories":["语言与平台"],"content":"自然拼读 ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:0","tags":["english"],"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["语言与平台"],"content":"元音 a am pam sam ad dad at cat rat an van man ran ap cap nap lap ab cab lab tab ag bag rag wag ack jack back sack pack ant pant Kant rant ang bang hang sang ank bank rank sank tank amp lamp camp ramp e ed Ted red en ten hen ell bell sell eg egg meg leg beg et jet get wet ess Bess less mess end bend mend send ent Kent bent sent went tent est best pest nest test west eck neck peck deck i id Sid kid ig pig dig ill Jill hill kill it sit fit hit pit im Tim Jim Kim dim in fin win tin pin ing ding ring king sing ink pink sink link ish fish dish wish ick pick kick sick tick Rick o ox fox box ot pot hot op hop top ob Bob job rob od nod pod rod og hog jog log om Tom mom ock rock sock lock u ug bug mug un run sun ut hut nut ub cub rub tub um gum hum mum uck duck luck tunk ump bump hump jump unch lunch munch punch ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:1","tags":["english"],"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["语言与平台"],"content":"辅音 辅音 bl black blink block blush cl clock clap click club class fl flag flex flip flop flush gl glass glad glob pl plan plane plant plot plum br Brad brick bring brush cr crab crack crash crop dr dress drip drop drum fr frog frank fresh Fred gr grass grab grand grid tr track trap trick truck sk skip skin skill sl sled slam slip slot sp spot spell spin spill st stand step stop stick sw swim swing swell ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:2","tags":["english"],"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["语言与平台"],"content":"元音组合 元音组合 ead read bead lead ean jean dean lean clean eat heat meat neat treat eal meal seal deal real oa goat toad oat coat goat boat moat oad road toad load oap soap oak soak oast toast roast coast boast oal goal oaf loaf ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:3","tags":["english"],"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["概要"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容。 此文章用于测试。 以下内容仅用于测试主题功能 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:0:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"LoveIt 的文章列表参考如下 hugoloveit https://hugoloveit.com/zh-cn/posts/ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:0:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"1 内容组织 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:1:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"2 前置参数 ---title:\"我的第一篇文章\"subtitle:\"\"# 文章副标题date:2020-03-04T15:58:26+08:00# 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置.lastmod:2020-03-04T15:58:26+08:00# 上次修改内容的日期时间.draft:true# 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染.author:\"\"# 文章作者.authorLink:\"\"# 文章作者的链接.description:\"\"# 文章内容的描述.license:\"\"# 这篇文章特殊的许可.images:[]# 页面图片, 用于 Open Graph 和 Twitter Cards.tags:[]# 文章的标签.categories:[]# 文章所属的类别.featuredImage:\"\"# 文章的特色图片.featuredImagePreview:\"\"# 用在主页预览的文章特色图片.hiddenFromHomePage:false# 如果设为 true, 这篇文章将不会显示在主页上.hiddenFromSearch:false# 如果设为 true, 这篇文章将不会显示在搜索结果中.twemoji:false# 如果设为 true, 这篇文章会使用 twemoji.lightgallery:true# 如果设为 true, 文章中的图片将可以按照画廊形式呈现.ruby:true# 如果设为 true, 这篇文章会使用 上标注释扩展语法.fraction:true# 如果设为 true, 这篇文章会使用 分数扩展语法.fontawesome:true# 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法.linkToMarkdown:true# 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接.rssFullText:false# 如果设为 true, 在 RSS 中将会显示全文内容.toc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位于 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位于 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...## featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法.resources:- name:featured-imagesrc:featured-image.jpg- name:featured-image-previewsrc:featured-image-preview.jpg--- ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:2:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3 内容摘要 文章摘要预览文章摘要预览 \" 文章摘要预览 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.1 自动摘要拆分 网站设置 summaryLength ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.2 手动摘要拆分 添加 \u003c!--more--\u003e ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.3 前置参数摘要 前置参数 summary ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.4 使用文章描述作为摘要 前置参数 description ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"4 Markdown 基本语法 ignore ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:4:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5 Markdown 扩展语法 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.1 Emoji 支持 https://hugoloveit.com/zh-cn/emoji-support/ 😀,😄,😆,🤣,😅,😂 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.2 数学公式 $$ c = \\pm\\sqrt{a^2 + b^2} $$ $$ c = \\pm\\sqrt{a^2 + b^2} $$ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.3 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\) $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.4 mhchem $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.5 字符注音或者注释 [Hugo]^(一个开源的静态网站生成工具) Hugo一个开源的静态网站生成工具 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:5","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.6 分数 [99]/[100] 99/100 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:6","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.7 Font Awesome 真开心! :(far fa-grin-tears): 真开心! ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:7","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.8 转义字符 {?:}joy: :joy: ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:8","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6 内置 Shortcodes https://hugoloveit.com/zh-cn/theme-documentation-built-in-shortcodes/ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.1 figure {{\u003c figure src=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.2 gist {{\u003c gist spf13 7896402 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.3 highlight {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.4 instagram instagram 的文档 {{\u003c instagram BWNjjyYFxVx hidecaption \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.5 param param 的文档 {{\u003c param description \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:5","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.6 ref 和 relref ref 和 relref 的文档 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:6","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.7 tweet tweet 的文档 {{\u003c tweet 877500564405444608 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:7","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.8 vimeo vimeo 的文档 {{\u003c vimeo 146022717 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:8","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.9 youtube youtube 的文档 {{\u003c youtube w7Ft2ymGmfc \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:9","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7 扩展shortcodes ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.1 style {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} This is a right-aligned paragraph. ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.2 link href [必需] content [可选] title [可选] rel [可选] class [可选] {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} Upstage ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.3 image src [必需] 图片的 URL. alt [可选] 图片无法显示时的替代文本, 默认值是 src 参数的值. caption [可选] 图片标题. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} lighthouse (image)\" lighthouse (image) ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.4 admonition 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] admonition 横幅的类型, 默认值是 note. title [可选] admonition 横幅的标题, 默认值是 type 参数的值. open [可选] 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.5 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 7.5.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:5","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.5.8 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:6","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.6 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:7","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.7 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. 7.7.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"music/wind.mp3\" name=起风了 artist=买辣椒也用券 cover=\"images/wind.png\" \u003e}} 呈现的输出效果如下: 7.7.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: 7.7.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] [netease, tencent, kugou, xiami, baidu]音乐平台. type [必需] [song, playlist, album, search, artist]音乐类型. id [必需] 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: 7.7.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme *[可选]*音乐播放器的主题色, 默认值是 #448aff. fixed *[可选]*是否开启固定模式, 默认值是 false. mini *[可选]*是否开启迷你模式, 默认值是 false. autoplay *[可选]*是否自动播放音乐, 默认值是 false. volume *[可选]*第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex *[可选]*是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选][all, one, none]音乐列表的循环模式, 默认值是 none. order [可选][list, random]音乐列表的播放顺序, 默认值是 list. list-folded *[可选]*初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height *[可选]*音乐列表的最大高度, 默认值是 340px. ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:8","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.8 bilibili {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:9","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.9 typeit typeit shortcode 基于 TypeIt 提供了打字动画. {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:10","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.10 script {{\u003c script \u003e}} console.log('Hello LoveIt!'); {{\u003c /script \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:11","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["语言与平台"],"content":" 声明：本文仅用做复习整理知识，在下列文章中进行二次加工，大部分内容整理自： https://www.cnblogs.com/edisonchou/p/4787775.html https://zhuanlan.zhihu.com/p/38799766 .NET 本质论 .NET中所有类型的基类是什么 值类型和引用类型的区别 装箱和拆箱的原理 struct和class的区别，struct适用于哪些场合 C#中方法的参数传递有哪几种方式 浅复制和深复制的区别 .NET中栈和堆的差异 执行string abc=\"aaa\"+\"bbb\"+\"ccc\"共分配了多少内存 托管堆内存分配 简要说说.NET中GC的运行机制 GC机制中如何判断一个对象仍然在被使用（如何标记） GC中代（Generation）是什么，分为几代（如何移动） GC有什么问题 托管与非托管资源是什么 托管资源 非托管资源 Dispose和Finalize方法在何时被调用（非托管资源回收方法） .NET中的托管堆中是否可能出现内存泄露的现象 大对象的分配 不恰当地保存根引用 不正确的Finalize方法 .NET 本质论 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:0:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":".NET中所有类型的基类是什么 System.Object ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:1:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"值类型和引用类型的区别 所有继承自System.ValueType的类型是值类型，而其他类型都是引用类型。 常用的值类型包括：结构、枚举、整数型、浮点型、布尔型等等。 赋值时的区别 值类型的变量直接将获得一个真实的数据副本，而对引用类型的赋值仅仅是把对象的引用赋给变量，这样就可能导致多个变量引用到一个对象实例上。 内存分配的区别 引用类型的对象将会在堆上分配内存，而值类型的对象则会在堆栈上分配内存 继承结构的区别 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:2:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"装箱和拆箱的原理 装箱：CLR需要做额外的工作把堆栈上的值类型移动到堆上，这个操作就被称为装箱。 拆箱：装箱操作的反操作，把堆中的对象复制到堆栈中，并且返回其值。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:3:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"struct和class的区别，struct适用于哪些场合 struct（结构）是值类型，而class（类）是引用类型。 struct与class相比，不具备继承的特性 struct不能有无参数的构造方法（class默认就有），也不能为成员变量定义初始值。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:4:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"C#中方法的参数传递有哪几种方式 ref关键字：引用传递参数，需要在传递前初始化；（ref 要求参数在传入前被初始化） out关键字：引用传递参数，需要在返回前初始化；（out 要求参数在方法返回前被初始化） params关键字：允许方法在定义时不确定参数的数量。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:5:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"浅复制和深复制的区别 浅复制：复制一个对象的时候，仅仅复制原始对象中所有的非静态类型成员和所有的引用类型成员的引用。（新对象和原对象将共享所有引用类型成员的实际对象） 深复制：复制一个对象的时候，不仅复制所有非静态类型成员，还要复制所有引用类型成员的实际对象。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:6:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":".NET中栈和堆的差异 .NET 中的栈 堆栈用来存储值类型的对象和引用类型对象的引用（地址），其分配的是一块连续的地址，堆栈上的地址从高位向低位分配内存。 .NET 中的堆 托管堆的分配也是连续的（从低位到高位），但是堆中却存在着暂时不能被分配却已经无用的对象内存块。 当一个引用类型对象被初始时，会通过指向堆上可用空间的指针分配一块连续的内存，然后使堆栈上的引用指向堆上刚刚分配的这块内存块。 .NET中的非托管堆 非托管的堆需要程序员用指针手动地分配和释放内存，.NET中的GC和内存管理不适用于非托管堆。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:7:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"执行string abc=\"aaa\"+\"bbb\"+\"ccc\"共分配了多少内存 string是引用类型，其内存分配会遵照引用类型的规范。字符串具有不可变性。 string first = \"aaa\" + \"bbb\" + \"ccc\"; string second = \"aaabbbccc\"; int num = 1; string str = \"aaa\" + num.ToString(); Console.WriteLine(str); string str = \"aaa\"; str += \"bbb\"; str += \"ccc\"; Console.WriteLine(str) ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:8:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"托管堆内存分配 CLR在进程中分配一块保留地址控件-即托管堆 托管堆有分为多个区域-垃圾回收堆（GC Heap）和加载堆（Loader Heap）[High-Frequency Heap、Low-Frequency Heap和Stub Heap] Loader Heap最重要的信息就是元数据相关的信息 每个Type在Loader Heap上体现一个Method Table，而Method Table中则记录了存储的元数据信息 Loader Heap不受GC控制。 TypeHandle：类型句柄，指向对应实例的方法表，每个对象创建时都包含该附加成员，并占用4个字节的内存空间。 SyncBlockIndex：用于线程同步，每个对象创建时也包含该附加成员la。它指向一块呗称为Synchronization Block的内存块，用于管理对象同步，同样占用4个字节的内存空间。 NextObjPtr:由托管堆维护的一个指针，用于标识下一个新建对象分配时在托管堆中所处的位置。CLR初始化时，NextObjPtr位于托管堆的及地址。 首先，将声明一个引用类型变量aUser：（堆栈4字节） VIPUser aUser;; 它仅是一个引用（指针），保存在线程的堆栈上，占用4Byte的内存空间，将用于保存VIPUser对象的有效地址，其执行过程正是上文描述的在线程栈上的分配过程。此时aUser未指向任何有效的实例，因此被自行初始化为null，试图对aUser的任何操作将抛出NullReferenceException异常。 然后，通过new操作执行对象创建：（GC托管堆20字节） aUser = new VIPUser(); 如上文所言，该操作对应于执行newobj指令，其执行过程又可细分为以下几步： 1、CLR按照其继承层次进行搜索，计算类型及其所有父类的字段，该搜索将一直递归到System.Object类型，并返回字节总数，以本例而言类型VIPUser需要的字节总数为 15 Bytes，具体计算为：VIPUser类型本身字段isVip（bool型）为 1 Bytes；父类User类型的字段id（Int32型）为 4 Bytes，字段user保存了指向UserInfo型的引用，因此占 4 Bytes，而同时还要为UserInfo分配 6 Bytes字节的内存。 2、实例对象所占的字节总数还要加上对象附加成员所需的字节总数，其中附加成员包括TypeHandle和SyncBlockIndex，共计 8 Bytes（在32位CPU平台下）。因此，需要在托管堆上分配的字节总数为 23 Bytes，而堆上的内存块总是按照 4 Bytes的倍数进行分配，因此本例中将分配 24 Bytes的地址空间。 3、CLR在当前AppDomain对应的托管堆上搜索，找到一个未使用的 20 Bytes 的连续空间，并为其分配该内存地址。事实上，GC使用了非常高效的算法来满足该请求，NextObjPtr指针只需要向前推进 20 Bytes，并清零原NextObjPtr指针和当前NextObjPtr指针之间的字节，然后返回原NextObjPtr指针地址即可，该地址正是新创建对象的托管堆地址，也就是aUser引用指向的实例地址。而此时的NextObjPtr仍指向下一个新建对象的位置。注意，栈的分配是向低地址扩展，而堆的分配是向高地址扩展。 最后，调用对象构造器，进行对象初始化操作，完成创建过程。该构造过程，又可细分为以下几个环节： （a）构造VIPUser类型的Type对象，主要包括静态字段、方法表、实现的接口等，并将其分配在上文提到托管堆的Loader Heap上。 （b）初始化aUser的两个附加成员：TypeHandle 和 SyncBlockIndex。 （解析类型）将TypeHandle指针指向Loader Heap上的MethodTable，CLR将根据TypeHandle来定位具体的Type； （实现对象实例同步）将SyncBlockIndex指针指向Synchronization Block的内存块，用于在多线程环境下对实例对象的同步操作。 （c）调用VIPUser的构造器，进行实例字段的初始化。 实例初始化时，会首先向上递归执行父类初始化，直到完成System.Object类型的初始化，然后再返回执行子类的初始化，直到执行VIPUser类为止。 以本例而言，初始化过程为首先执行System.Object类，再执行User类，最后才是VIPUser类。最终，newobj分配的托管堆的内存地址，被传递给VIPUser的this参数，并将其引用传给栈上声明的aUser。(System.Object-\u003eUser-\u003eVIPUser-\u003e封装成aUser-\u003e地址丢给线程堆栈) ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:9:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"简要说说.NET中GC的运行机制 GC是垃圾回收（Garbage Collect）的缩写,.NET中的垃圾回收是指清理托管堆上不会再被使用的对象内存，并且移动仍在被使用的对象使它们紧靠托管堆的一边。 标记：找到所有不再被使用的对象：对象A和对象C，并标记为垃圾； 移动：移动仍在被使用的对象：对象B和对象D; 通常情况下，我们不需要手动干预垃圾回收的执行，不过CLR仍然提供了一个手动执行垃圾回收的方法：GC.Collect()。当我们需要在某一批对象不再使用并且及时释放内存的时候可以调用该方法来实现。But，垃圾回收的运行成本较高（涉及到了对象块的移动、遍历找到不再被使用的对象、很多状态变量的设置以及Finalize方法的调用等等），对性能影响也较大，因此我们在编写程序时，应该避免不必要的内存分配，也尽量减少或避免使用GC.Collect()来执行垃圾回收。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:10:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"GC机制中如何判断一个对象仍然在被使用（如何标记） Mark-Compact 标记压缩算法 在.NET中引用类型对象实例通常通过引用来访问，而GC判断堆中的对象是否仍然在被使用的依据也是引用。简单地说：当没有任何引用指向堆中的某个对象实例时，这个对象就被视为不再使用。 在GC执行垃圾回收时，会把引用分为以下两类： （1）根引用：往往指那些静态字段的引用，或者存活的局部变量的引用； （2）非根引用：指那些不属于根引用的引用，往往是对象实例中的字段。 垃圾回收时，GC从所有仍在被使用的根引用出发遍历所有的对象实例，那些不能被遍历到的对象将被视为不再被使用而进行回收。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:11:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"GC中代（Generation）是什么，分为几代（如何移动） GC会把所有托管堆内的对象按照其已经不再被使用的可能性分为三类，并且从最有可能不被使用的类别开始扫描，.NET对这样的分类类别有一个称呼：代（Generation）。 第0代，新近分配在堆上的对象，从来没有被垃圾收集过。任何一个新对象，当它第一次被分配在托管堆上时，就是第0代。 第1代，经历过一次垃圾回收后，依然保留在堆上的对象。 第2代，经历过两次或以上垃圾回收后，依然保留在堆上的对象。如果第2代对象在进行完垃圾回收后空间仍然不够用，则会抛出OutOfMemoryException异常。 并不是每次垃圾回收都会同时回收3个代的所有对象，越小的代拥有着越多被释放的机会。 CLR对于代的基本算法是：每执行N次0代的回收，才会执行一次1代的回收，而每执行N次1代的回收，才会执行一次2代的回收。 根据.NET的垃圾回收机制，0代、1代和2代的初始分配空间分别为256KB、2M和10M。 一个对象实例存活的时间越长，那么它就具有更大的机率去存活更长的时间。 因为一次GC回收之后仍然被使用的对象会被移动到更高的代上，因此我们需要避免保留已经不再被使用的对象引用，将对象的引用置为null是告诉.NET该对象不需要再使用的最直接的方法。 在前面我们提到Finalize方法会大幅影响性能，通过结合对代的理解，我们可以知道：在带有Finalize方法的对象被回收时，该对象会被视为正在被使用从而被留在托管堆中，且至少要等一个GC循环才能被释放（为什么是至少一个？因为这取决于执行Finalize方法的线程的执行速度）。很明显，需要执行Finalize方法的那些对象实例，被真正释放时最乐观的情况下也已经位于1代的位置上了，而如果它们是在1代上才开始释放或者执行Finalize方法的线程运行得慢了一点，那该对象就在第2代上才被释放，相对于0代，这样的对象实例在堆中存留的时间将长很多。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:12:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"GC有什么问题 首先，GC并不是能释放所有的资源。它不能自动释放非托管资源。 第二，GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。 GC并不是实时性的，这会造成系统性能上的瓶颈和不确定性。所以有了IDisposable接口，IDisposable接口定义了Dispose方法，这个方法用来供程序员显式调用以释放非托管资源。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:13:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"托管与非托管资源是什么 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:14:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"托管资源 .NET中的所有类型都是（直接或间接）从System.Object类型派生的。.NET中超过80%的资源都是托管资源。 CTS中的类型被分成两大类——引用类型（reference type，又叫托管类型[managed type]），分配在内存堆上；值类型（value type），分配在堆栈上。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:14:1","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"非托管资源 ApplicationContext, Brush, Component, ComponentDesigner, Container, Context, Cursor, FileStream, Font, Icon, Image, Matrix, Object, OdbcDataReader, OleDBDataReader, Pen, Regex, Socket, StreamWriter, Timer, Tooltip, 文件句柄, GDI资源, 数据库连接等等资源。可能在使用的时候很多都没有注意到！ ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:14:2","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"Dispose和Finalize方法在何时被调用（非托管资源回收方法） Dispose方法 我们会在Dispose方法中实现一些托管对象和非托管对象的释放以及业绩业务逻辑的结束工作等等。 But，即使我们实现了Dispose方法，也不能得到任何有关释放的保证，Dispose方法的调用依赖于类型的使用者，当类型被不恰当地使用，Dispose方法将不会被调用,我们一般会借助using等语法来帮助Dispose方法被正确调用。 Finalize方法 Finalize在GC执行垃圾回收时被调用 ①当每个包含Finalize方法的类型的实例对象被分配时，.NET会在一张特定的表结构中添加一个引用并且指向这个实例对象，暂且称该表为“带析构方法的对象表”； ②当GC执行并且检测到一个不被使用的对象时，需要进一步检查“带析构方法的对象表”来查询该对象类型是否含有Finalize方法，如果没有则将该对象视为垃圾，如果存在则将该对象的引用移动到另外一张表，暂且称其为“待析构的对象表”，并且该对象实例仍然被视为在被使用。 ③CLR将有一个单独的线程负责处理“待析构的对象表”，其执行方法内部就是依次通过调用其中每个对象的Finalize方法，然后删除引用，这时托管堆中的对象实例就被视为不再被使用。 ④下一个GC执行时，将释放已经被调用Finalize方法的那些对象实例。 结合使用Dispose和Finalize方法：标准Dispose模式 Finalize方法由于有CLR保证调用，因此比Dispose方法更加安全（这里的安全是相对的，Dispose需要类型使用者的及时调用），但在性能方面Finalize方法却要差很多。因此，我们在类型设计时一般都会使用标准Dispose模式：Finalize方法作为Dispose方法的后备，只有在使用者没有调用Dispose方法的情况下，Finalize方法才被视为需要执行。这一模式保证了对象能够被高效和安全地释放，已经被广泛使用。 标准dispose模式模板 public class BaseTemplate : IDisposable { // 标记对象是否已经被释放 private bool isDisposed = false; // Finalize方法 ~BaseTemplate() { Dispose(false); } // 实现IDisposable接口的Dispose方法 public void Dispose() { Dispose(true); // 告诉GC此对象的Finalize方法不再需要被调用 GC.SuppressFinalize(this); } // 虚方法的Dispose方法做实际的析构工作 protected virtual void Dispose(bool isDisposing) { // 当对象已经被析构，则不必再继续执行 if(isDisposed) { return; } if(isDisposing) { // Step1:在这里释放托管资源 } // Step2:在这里释放非托管资源 // Step3:最后标记对象已被释放 isDisposed = true; } public void MethodA() { if(isDisposed) { throw new ObjectDisposedException(\"对象已经释放\"); } // Put the logic code of MethodA } public void MethodB() { if (isDisposed) { throw new ObjectDisposedException(\"对象已经释放\"); } // Put the logic code of MethodB } } public sealed class SubTemplate : BaseTemplate { // 标记子类对象是否已经被释放 private bool disposed = false; protected override void Dispose(bool isDisposing) { // 验证是否已被释放，确保只被释放一次 if(disposed) { return; } if(isDisposing) { // Step1:在这里释放托管的并且在这个子类型中申明的资源 } // Step2:在这里释放非托管的并且这个子类型中申明的资源 // Step3:调用父类的Dispose方法来释放父类中的资源 base.Dispose(isDisposing); // Step4:设置子类的释放标识 disposed = true; } } 真正做释放工作的只是受保护的虚方法Dispose，它接收一个bool参数，主要用于区分调用者是类型的使用者还是.NET的GC机制。两者的区别在于通过Finalize方法释放资源时不能再释放或使用对象中的托管资源，这是因为这时的对象已经处于不被使用的状态，很有可能其中的托管资源已经被释放掉了。在Dispose方法中GC.SuppressFinalize(this)告诉GC此对象在被回收时不需要调用Finalize方法，这一句是改善性能的关键，记住实现Dispose方法的本质目的就在于避免所有释放工作在Finalize方法中进行。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:15:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":".NET中的托管堆中是否可能出现内存泄露的现象 首先，必须明确一点：即使在拥有垃圾回收机制的.NET托管堆上，仍然是有可能发生内存泄露现象的。 其次，什么是内存泄露？内存泄露是指内存空间上产生了不再被实际使用却又不能被分配的内存空间，其意义很广泛，像内存碎片、不彻底的对象释放等都属于内存泄露现象。内存泄露将导致主机的内存随着程序的运行而逐渐减少，无论其表现形式怎样，它的危害是很大的，因此我们需要努力地避免。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:0","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"大对象的分配 NET中所有的大对象（这里主要是指对象的大小超过指定数值[85000字节]）将分配在托管堆内一个特殊的区域内，暂且将其称为“大对象堆”（这也算是CLR对于GC的一个优化策略）。大对象堆中最重要的一个特点就是：没有代级的概念，所有对象都被视为第2代。在回收大对象堆内的对象时，其他的大对象不会被移动，这是考虑到大规模地移动对象需要耗费过多的资源。这样，在程序过多地分配和释放大对象之后，就会产生很多内存碎片。 随着对象的分配和释放不断进行，在不进行对象移动的大对象堆内，将不可避免地产生小的内存碎片。我们所需要做的就是尽量减少大对象的分配次数，尤其是那些作为局部变量的，将被大规模分配和释放的大对象，典型的例子就是String类型。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:1","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"不恰当地保存根引用 最简单的一个错误例子就是不恰当地把一个对象申明为公共静态变量，一个公共的静态变量将一直被GC视为一个在使用的根引用。更糟糕的是：当这个对象内部还包含更多的对象引用时，这些对象同样不会被释放。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:2","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"不正确的Finalize方法 不正确的Finalize方法将导致Finalize方法不能被正确执行。如果系统中所有的Finalize方法不能被正确执行，包含它们的对象也只能驻留在托管堆内不能被释放，这样的情况将会导致严重的后果。 Finalize方法应该只致力于快速而简单地释放非托管资源，并且尽可能快地返回。相反，不正确的Finalize方法则可能包含： 1. 没有保护地写文件日志； 2. 访问数据库； 3. 访问网络； 4. 把当前对象赋给某个存活的引用； 例如，当Finalize方法试图访问文件系统、数据库或者网络时，将会有资源争用和等待的潜在危险。试想一个不断尝试访问离线数据库的Finalize方法，将会在长时间内不会返回，这不仅影响了对象的释放，也使得排在Finalize方法队列中的所有后续对象得不到释放，这个连锁反应将会导致很快地造成内存耗尽。此外，如果在Finalize方法中把对象自身又赋给了另外一个存活的引用，这时对象内的一部分资源已经被释放掉了，而另外一部分还没有，当这样一个对象被激活后，将导致不可预知的后果。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:3","tags":["dotnet"],"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["数据与算法"],"content":" 这个篇文章主要是算法学习大纲。 主要参考 https://github.com/youngyangyang04/leetcode-master 的学习路线，标号||均为leetcode题号。 算法 数组 二分查找 搜索插入位置|35| 双指针 移除元素|27| 滑动窗口 长度最小的子数组|209| 链表 链表的理论 链表的种类 链表的存储方式 链表操作 数组和链表在不同场景下的性能分析 链表的经典题目 虚拟头节点(哨兵节点) 链表的基本操作 反转链表 环形链表 哈希表 哈希表介绍 哈希函数 哈希碰撞 常见的三种哈希结构 数组作为哈希表 set作为哈希表 map作为哈希表 字符串 什么是字符串 要不要使用库函数 双指针法、反转系列 KMP 栈和队列 栈与队列的理论基础 栈经典题目 栈在系统中的应用 括号匹配问题 字符串去重问题 逆波兰表达式问题 队列的经典题目 滑动窗口最大值问题 求前 K 个高频元素 二叉树 二叉树的遍历方式 前序遍历|144| 中序遍历|145| 后序遍历|94| 层级遍历|102| 二叉树的属性 对称二叉树|101| 二叉树最大深度|104| 二叉树最小深度|111| 完全二叉树的节点个数|222| 平衡二叉树|110| 二叉树的所有路径|157| 左叶子之和|404| 找树左下角的值|513| 路径总和|112| 二叉树的修改与构造 翻转二叉树|226| 从中序与后续遍历序列构造二叉树|106| 最大二叉树|654| 合并二叉树|617| 求二叉搜索树的属性 二叉搜索树中的搜索|700| 验证二叉搜索树|98| 二叉搜索树的最小绝对差|530| 二叉搜索树中的众数|501| 把二叉搜索树转换为累加树|538| 二叉树公共祖先问题 二叉树的最近公共祖先|236| 二叉搜索树的最近公共祖先|235| 二叉搜索树的修改和构造 二叉搜索树的插入操作|701| 删除二叉搜索树的节点|450| 修剪二叉搜索树|669| 将有序数组转换为二叉搜索树|108| 回溯算法 组合 组合|77| 电话号码的字母组合|17| 组合总和|39| 组合总和2|40| 组合总和3|216| 分割 分割回文串|131| 复原IP地址|93| 子集 子集|78| 子集2|90| 排列 全排列|46| 全排列2|47| 棋盘问题 N皇后|51| 解数独|37| 其他 递增子序列|491| 重新安排行程|332| 贪心算法 理论基础 简单题目 分发饼干|455| K次取反后最大化的数组和|1005| 柠檬水找零|860| 序列问题 摆动序列|376| 单调递增的数字|738| 股票问题 买卖股票的最佳时机|122| 买卖股票的最佳时机含手续费|714| 两个维度权衡问题 分发糖果|135| 根据身高重建队列|406| 区间问题 跳跃游戏|55| 跳跃游戏2|45| 用最少数量的箭引爆气球|452| 五重叠区间|435| 划分字母区间|763| 合并区间|56| 其他问题 最大子序和|53| 加油站|134| 监控二叉树|968| 动态规划 算法 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:0:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"数组 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:1:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二分查找 搜索插入位置|35| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:1:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"双指针 移除元素|27| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:1:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"滑动窗口 长度最小的子数组|209| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:1:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"链表 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:2:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"链表的理论 链表的种类 单链表、双链表、循环链表 链表的存储方式 数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 链表操作 添加、删除、查询 数组和链表在不同场景下的性能分析 插入删除的时间复杂度是O(1),查询的时间复杂度是O(n) ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:2:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"链表的经典题目 虚拟头节点(哨兵节点) 移除链表元素|203| 链表的基本操作 设计链表|707| 反转链表 反转链表|206| 环形链表 环形链表II|142| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:2:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"哈希表 哈希表 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"哈希表介绍 哈希表是根据关键码的值而直接进行访问的数据结构。 哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"哈希函数 通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把value映射为哈希表上的索引数字了。 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"哈希碰撞 拉链法、线性探测法。 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"常见的三种哈希结构 数组、set（集合）、map（映射） 数组作为哈希表 有效的字母异位词|242| 赎金信|383| set作为哈希表 两个数组的交集|349| map作为哈希表 两数之和|1| 三数之和|15| 四数之和|18| 四数相加II|454| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"字符串 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"什么是字符串 字符串是若干字符组成的有限序列，也可以理解为是一个字符数组 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"要不要使用库函数 反转字符串|344| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"双指针法、反转系列 反转字符串II|541| 剑指Offer 05.替换空格 翻转字符串里的单词|151| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"KMP 实现 strStr()|28| 重复的子字符串|459| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"栈和队列 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:5:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"栈与队列的理论基础 队列是先进先出，栈是先进后出 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:5:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"栈经典题目 栈在系统中的应用 简化路径|71| 括号匹配问题 有效的括号|20| 字符串去重问题 删除字符串中的所有相邻重复项|1047| 逆波兰表达式问题 逆波兰表达式求值|150| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:5:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"队列的经典题目 滑动窗口最大值问题 滑动窗口最大值|239| 求前 K 个高频元素 前 K 个高频元素|347| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:5:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树的遍历方式 前序遍历|144| 中序遍历|145| 后序遍历|94| 层级遍历|102| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树的属性 对称二叉树|101| 二叉树最大深度|104| 二叉树最小深度|111| 完全二叉树的节点个数|222| 平衡二叉树|110| 二叉树的所有路径|157| 左叶子之和|404| 找树左下角的值|513| 路径总和|112| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树的修改与构造 翻转二叉树|226| 从中序与后续遍历序列构造二叉树|106| 最大二叉树|654| 合并二叉树|617| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"求二叉搜索树的属性 二叉搜索树中的搜索|700| 验证二叉搜索树|98| 二叉搜索树的最小绝对差|530| 二叉搜索树中的众数|501| 把二叉搜索树转换为累加树|538| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树公共祖先问题 二叉树的最近公共祖先|236| 二叉搜索树的最近公共祖先|235| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:5","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉搜索树的修改和构造 二叉搜索树的插入操作|701| 删除二叉搜索树的节点|450| 修剪二叉搜索树|669| 将有序数组转换为二叉搜索树|108| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:6","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"回溯算法 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"组合 组合|77| 电话号码的字母组合|17| 组合总和|39| 组合总和2|40| 组合总和3|216| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"分割 分割回文串|131| 复原IP地址|93| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"子集 子集|78| 子集2|90| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"排列 全排列|46| 全排列2|47| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"棋盘问题 N皇后|51| 解数独|37| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:5","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"其他 递增子序列|491| 重新安排行程|332| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:6","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"贪心算法 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"理论基础 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"简单题目 分发饼干|455| K次取反后最大化的数组和|1005| 柠檬水找零|860| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"序列问题 摆动序列|376| 单调递增的数字|738| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"股票问题 买卖股票的最佳时机|122| 买卖股票的最佳时机含手续费|714| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"两个维度权衡问题 分发糖果|135| 根据身高重建队列|406| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:5","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"区间问题 跳跃游戏|55| 跳跃游戏2|45| 用最少数量的箭引爆气球|452| 五重叠区间|435| 划分字母区间|763| 合并区间|56| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:6","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"其他问题 最大子序和|53| 加油站|134| 监控二叉树|968| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:7","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"动态规划 Written with StackEdit. ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:9:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["概要"],"content":" 个人技术蓝图 计算机基础 [the-basics-of-computer-science] 计算机的组成原理 [principles-of-computer-composition] 操作系统原理 [principle-operating-system] 编译原理 [principle-of-compiling] 数据库系统 [database-system] 计算机网络 [network-of-computer] TCP HTTP 语言与平台 [language-and-platform] C# \u0026 .NET 5 [chsarp-and-dotnet5] .NET 本质论 [dotnet-essentialism] C# 基础语法 [csharp-basic-syntax] C# 高级用法 [professional-csharp] 新一代的 .NET [new-generation-dotnet] Swift \u0026 IOS [swift-ios] Python [python] Python 基础语法 [python-basic-syntax] Python 高级语法 [professional-python] Python 的应用 [python-application] JS,ES,TS \u0026 Vue,React (Gatsby) [js-es-ts-vue-react] 前端框架 [front-end] JavaScript [js] 数据与算法[data-and-algorithmic] 数据结构 [data-structure] 常用算法 [algorithm] 重构 [refactoring] 软件工程 [software-engineering] 开发方法 [software-development-methodologies] 系统分析与设计 [system-analysis-and-design] 软件开发的生命周期 [software-development-lifecycle] 架构艺术 [architecture-art] 架构模式 [architecture-pattern] 设计模式 [design-pattern] 常用组件 [common-components] Redis [redis] RabbitMQ [rabbitmq] Elastic Search [elastic-search] 云上漫谈 [cloud-native] 基础架构篇 [cloud-infrastructure] 软件架构篇 [cloud-software-architecture] DEVOPS [devops] 个人技术蓝图 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:0:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"计算机基础 [the-basics-of-computer-science] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"计算机的组成原理 [principles-of-computer-composition] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"操作系统原理 [principle-operating-system] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"编译原理 [principle-of-compiling] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"数据库系统 [database-system] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:4","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"计算机网络 [network-of-computer] TCP HTTP ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:5","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"语言与平台 [language-and-platform] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"C# \u0026 .NET 5 [chsarp-and-dotnet5] .NET 本质论 [dotnet-essentialism] dotnet-essentialism C# 基础语法 [csharp-basic-syntax] C# 高级用法 [professional-csharp] 新一代的 .NET [new-generation-dotnet] dotnet-core ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"Swift \u0026 IOS [swift-ios] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"Python [python] Python 基础语法 [python-basic-syntax] python-learning-notes python-learning-intermediate-notes Python 高级语法 [professional-python] python-quick-grammar Python 的应用 [python-application] jupyter-notebook-shortcuts ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"JS,ES,TS \u0026 Vue,React (Gatsby) [js-es-ts-vue-react] 前端框架 [front-end] Gatsby JavaScript [js] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:4","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"数据与算法[data-and-algorithmic] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"数据结构 [data-structure] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"常用算法 [algorithm] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"重构 [refactoring] [转载]C#重构经典全面汇总 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"软件工程 [software-engineering] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"开发方法 [software-development-methodologies] 软件开发方法笔记 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"系统分析与设计 [system-analysis-and-design] 系统分析与设计 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"软件开发的生命周期 [software-development-lifecycle] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"架构艺术 [architecture-art] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"架构模式 [architecture-pattern] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"设计模式 [design-pattern] UML设计 设计模式 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"常用组件 [common-components] Redis [redis] [转载]Redis面试题 RabbitMQ [rabbitmq] [转载][转载]消息中间件MQ与RabbitMQ面试题 Elastic Search [elastic-search] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"云上漫谈 [cloud-native] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"基础架构篇 [cloud-infrastructure] introduce-microservice-infrastructure-on-cloud how-to-setup-kubernetes-on-azure ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"软件架构篇 [cloud-software-architecture] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"DEVOPS [devops] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["软件工程"],"content":" Software Development Methodologies ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:0:0","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"开发方法 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:0","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"软件的生命周期 可行性研究与计划-\u003e需求分析-\u003e概要设计-\u003e详细设计-\u003e实现-\u003e集成测试-\u003e确认测试-\u003e使用与维护 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:1","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"软件开发模型 瀑布模型 演化模型 螺旋模型 增量模型 构建组装模型 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:2","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"统一过程 UP的9个核心工作流 业务建模，需求，分析设计，实施，测试，部署，配置与变更管理，项目管理，环境 UP的生命周期 目标里程碑，架构里程碑，能力里程碑，发布里程碑 UP的特点 UP不但给出类迭代的生命周期，还给出了生命周期每一阶段的迭代指南 采用不同迭代方式的UP可以演变为演化模型或增量模型 迭代特点使得更容易控制软件开发的风险 UP本身并不属于敏捷 实际应用中可以根据具体问题对UP进行剪裁 架构师在UP中的活动 同需求人员和项目管理人员密切协作 细化软件架构 保持整个架构的概念完整性 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:3","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"敏捷方法 极限编程 XP是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方式。 在更短的周期内，更早的提供具体、持续的反馈信息 迭代的进行计划编制 依赖自动测试程序来监控开发进度，并及早捕获缺陷 依赖口头交流、测试和源程序进行沟通 倡导持续的、演化式的设计 依赖与开发团队内部的紧密协作 尽可能达到程序员短期利益和项目长期利益的平衡 四大价值观 沟通，简单，反馈，勇气，（尊重） 十二个最佳实践 计划游戏，小型发布，隐喻，简单设计，测试先行，重构，结对编程，集体代码所有制，持续集成，每周工作40小时，现场客户，编码标准 特性驱动开发 FDD也是一个迭代开发模型，FDD每一步都强调质量，不断的交付可运行的软件，并以很小的开发提供精准的项目进度报告和状态信息。 FDD角色定义 项目经理，首席架构设计师，开发经理，主程序员，程序员，领域专家 核心过程 开发整体对象模型、构造特征列表、计划特征开发、特征设计、特征构建 最佳实践 领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管 Scrum Scrum是一个用于开发和维护复杂产品的框架，是一个增量的、迭代的开发过程。 Scrum 的五个活动 产品待办事项列表梳理、Sprint计划会议、每日Scrum会议、Sprint评审会议、Sprint回顾会议 Scrum的5大价值观 承诺、专注、开放、尊重、勇气 水晶方法 Crystal 是发展一种提倡“机动性“的方法，包括共有的核心元素，每个都含有独特的角色，过程模式，工作产品和实践。 7大体系特征：经常交付，反思改进，渗透式交流，个人安全，焦点，与专家用户建立方便的联系，配有自动测试、配置管理和经常集成功能的技术环境 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:4","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"软件重用 软件重用 源代码重用，架构重用，应用框架重用，业务建模重用，文档及过程的重用，软构件重用，软件服务重用 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:5","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"基于架构的软件设计 ABSD方法于生命周期 ABSD：分解功能，通过选择架构风格来事先质量和业务需求，软件模版的使用 抽象功能需求，包括变化的需求和通用的需求 用例（实际功能需求） 抽象的质量和业务需求 架构选项 质量场景 约束 基于架构的软件开发模型(ABSDM) 架构需求 需求获取，标识构件（生成类图，对类分组，打包构件），需求评审 架构设计 提出软件架构模型，把已标识的构件映射到软件架构中，分析构件的互相作用，产生软件架构，设计评审 架构文档化 输出：架构需求规格说明，测试架构需求的质量设计说明 架构复审 架构实现 架构演化 需求变动归类，制定架构演化计划，修改、增加或删除构件，更新构件的互相作用，构件组装与测试，技术评审 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:6","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["语言与平台"],"content":"Python Quick Grammar ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:0","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"1. 变量互换 a=1 b=2 a,b=b,a a,b (2, 1) ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:1","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"2. 连续赋值 a=b=c=50 a,b,c (50, 50, 50) ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:2","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"3. 自动解包 a,b,c=[1,2,3] a,b,c (1, 2, 3) a,*others=[1,2,3,4] print(a) print(*others) 1 2 3 4 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:3","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"4. 链式比较 a=10 if(5\u003ca\u003c15): print(a) 10 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:4","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"5. 重复列表 [5,2]*4 [5, 2, 5, 2, 5, 2, 5, 2] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:5","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"6. 重复字符串 \"hello\"*3 'hellohellohello' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:6","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"7. 三目运算 age = 30 slogon = \"牛逼\" if age == 30 else \"niubility\" print(slogon) 牛逼 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:7","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"8. 字典合并 a={\"a\":1} b={\"b\":2} {**a,**b} {'a': 1, 'b': 2} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:8","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"9. 字符串反转 s = \"i love python\" s[::-1] 'nohtyp evol i' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:9","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"10. 列表转字符串 s = [\"i\", \"love\", \"python\"] \" \". join(s) 'i love python' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:10","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"11. for else 语句 foo=[2,3,4,5] for i in foo: if i == 0: break else: print(\"未发现\") 未发现 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:11","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"12. 字典推导式 m = {x: x**2 for x in range(5)} m {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:12","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"13. 用Counter查找列表中出现最多的元素 content = [\"a\", \"b\", \"c\", \"a\", \"d\", \"c\", \"a\"] from collections import Counter c = Counter(content) c. most_common(1) [('a', 3)] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:13","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"14. 默认值字典 from collections import defaultdict d = defaultdict(list) d['a']. append(1) d['a'] [1] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:14","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"15. 赋值表达式 import re data = \"hello123world\" if match:=re. search(\"(\\d+)\", data): num = match. group(1) else: num=None num '123' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:15","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"16. isinstance x=1 b=isinstance(x, (int, float)) b True ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:16","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"17. 用 http.server 共享文件 #python3 -m http. server ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:17","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"18. zip 函数实现字典键值对互换 lang = {\"python\":\". py\", \"java\":\". java\"} dict(zip(lang. values(), lang. keys())) {'. py': 'python', '. java': 'java'} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:18","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"19. 查找列表中出现次数最多的数字 test = [1, 2, 3, 4, 2, 2, 3, 1, 4, 4, 4, 5] max(set(test), key=test. count) 4 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:19","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"20. 使用 slots 节省内存 class MyClass(object): def __init__(self, name, identifier): self. name = name self. identifier = identifier self. set_up() print(sys. getsizeof(MyClass)) class MyClass(object): __slots__ = ['name', 'identifier'] def __init__(self, name, identifier): self. name = name self. identifier = identifier self. set_up() print(sys. getsizeof(MyClass)) 1064 896 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:20","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"21. 扩展列表 i = ['a','b','c'] i. extend(['e','f','g']) i ['a', 'b', 'c', 'e', 'f', 'g'] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:21","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"22. 列表负数索引 a = [ 1, 2, 3] a[-1] 3 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:22","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"23. 列表切片 a = [0,1,2,3,4,5,6,7,8,9] a[3:6] # 第3个到第6个之间的元素 a[:5] # 前5个元素 a[5:] # 后5个元素 a[::] # 所有元素（拷贝列表） a[::2] # 偶数项 a[1::2] # 奇数项 a[::-1] # 反转列表 [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:23","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"24. 二维数组变一维数组 import itertools a = [[1, 2], [3, 4], [5, 6]] i = itertools. chain(*a) list(i) [1, 2, 3, 4, 5, 6] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:24","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"25. 有索引的迭代 a = ['Merry', 'Christmas ', 'Day'] for i, x in enumerate(a): print ('{}: {}'. format(i, x)) 0: Merry 1: Christmas 2: Day ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:25","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"26. 列表推导式 le = [x*2 for x in range(10)] le # 每个数取平方 le = [x for x in range(10) if x%2 == 0] le # 获取偶数项 [0, 2, 4, 6, 8] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:26","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"27. 生成器表达式 ge = (x*2 for x in range(10)) print(ge) print(next(ge)) print(next(ge)) print(next(ge)) \u003cgenerator object \u003cgenexpr\u003e at 0x000001D693764190\u003e 0 2 4 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:27","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"28. 集合推导式 nums = {n**2 for n in range(10)} nums {0, 1, 4, 9, 16, 25, 36, 49, 64, 81} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:28","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"29. 判断key是否存在字典中 d = {\"1\":\"a\"} print('1' in d) print(d['1']) print(d. get(\"1\")) print(d. get(\"2\")) True a a None ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:29","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"30. 装饰器 from functools import wraps def tags(tag_name): def tags_decorator(func): @wraps(func) def func_wrapper(name): return \"\u003c{0}\u003e{1}\u003c/{0}\u003e\". format(tag_name, func(name)) return func_wrapper return tags_decorator @tags(\"p\") def get_text(name): \"\"\"returns some text\"\"\" return \"Hello \" + name print(get_text(\"Python\")) \u003cp\u003eHello Python\u003c/p\u003e ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:30","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"31. 字典子集 def sub_dicts(d, keys): return {k:v for k, v in d. items() if k in keys} sub_dicts({1:\"a\", 2:\"b\", 3:\"c\"}, [1,2]) {1: 'a', 2: 'b'} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:31","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"32. 反转字典 d = {'a': 1, 'b': 2, 'c': 3, 'd': 4} zip(d. values(), d. keys()) z = zip(d. values(), d. keys()) dict(z) {1: 'a', 2: 'b', 3: 'c', 4: 'd'} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:32","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"33. 具名元组 from collections import namedtuple Point = namedtuple(\"Point\", \"x,y\") p = Point(x=1, y=2) print(p. x) print(p[0]) print(p. y) print(p[1]) 1 1 2 2 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:33","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"34. 设置字典默认值 d = dict() if 'a' not in d: d['a'] = [] d['a']. append(1) d d. setdefault('b',[]). append(2) d {'a': [1], 'b': [2]} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:34","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"35. 有序字典 from collections import OrderedDict m = OrderedDict((str(x), x) for x in range(10)) m. keys() # key 按照插入的顺序排列 odict_keys(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']) ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:35","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"36. 列表中最大最小的前n个数 import heapq a = [51, 95, 14, 65, 86, 35, 85, 32, 8, 98] heapq. nlargest(5,a) heapq. nsmallest(5,a) [8, 14, 32, 35, 51] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:36","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"37. 打开文件 import os with open('foo. txt', 'w') as f: f. write(\"hello\") os. remove(\"foo. txt\") ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:37","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"38. 两个列表组合成字典 list_1 = [\"One\",\"Two\",\"Three\"] list_2 = [1,2,3] dictionary = dict(zip(list_1, list_2)) print(dictionary) {'One': 1, 'Two': 2, 'Three': 3} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:38","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"39. 去除列表中重复元素 my_list = [1,4,1,8,2,8,4,5] my_list = list(set(my_list)) print(my_list) [1, 2, 4, 5, 8] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:39","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"40. 打印日历 import calendar print(calendar. month(2021, 1)) January 2021 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:40","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"41. 匿名函数 add = lambda a,b:a+b add(1,2) 3 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:41","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":" Python Learning Notes - Intermediate ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:0:0","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4. 序列 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:0","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.1 序列 1 索引 abc=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] print(abc[1]) 2 切片（slicing） sname[start🔚step] print(abc[1:5]) print(abc[0:5:2]) 3 序列相加 bcd=[\"b\",\"c\",\"d\"] print(abc+bcd) 4 乘法 print(bcd*5) 5 检查元素 print(\"b\" in bcd) 6 计算序列长度、最大值和最小值 print(len(abc)) print(max(abc)) print(min(abc)) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:1","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.2 列表(list) 1 创建和删除 lisa=[1,2,3,4,5,6] lisb=['a',\"b\",[\"a\",'''bcd''']] lise=[] lisr=list(range(1,10,2)) print(lisa,lisb,lise,lisr) del lisr print(lisr) 2 遍历 for i in lisa: print(i) for i,item in enumerate(lisb): print(i,item) 3 添加、修改和删除列表元素 lisa.append(7) print(lisa) lisa[5] = 7 print(lisa) del lisa[5] print(lisa) 4 统计 c=lisa.count(1) print(c) i=lisa.index(1) print(i) s=sum(lisa) print(s) lisa.sort(reverse=True) print(lisa) sort=sorted(lisa) print(sort) k=[x for x in lisa if x\u003e3] print(k) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:2","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.3 元组（tuple） 1 元组的基本操作 t=('a',12,(\"abc\",\"b\"),[\"ggg\",99]) print(t) t=tuple(range(10,20,2)) print(t) t=('人生苦短',28,'我用PYTHON',[123,456,789]) print(t[0]) print(t[:3]) 2 元组推导式 import random randomnumber=(random.randint(10,100) for i in range(10)) print(randomnumber) randomnumber=tuple(randomnumber) print(randomnumber) a=(1,2,3) print(a) a=(2,3,4) print(a) a=a+(5,6) print(a) 遍历后原生成器对象已经不存在了，如下： number=(i for i in range(3)) print(number.__next__()) print(number.__next__()) number=tuple(number) print(number) 元组和列表区别 列表属于可变序列，它的元素可以随时修改或者删除，而元组属于不可变序列，其中元素不可修改，除非整体替换 列表可以使用append(),extend(),insert(),remove()和pop()等方法实现添加和修改列表元素，而元组则没有这几个方法，因为不能向原则添加和修改元素，同样也不能删除元素 列表可以使用切片访问和修改列表中元素，元素也支持切片，但是它只支持通过切片访问元素中的元素，不支持修改 元组比列表的访问和处理速度快，所以如果只需要对其中元素进行访问，而不进行任何修改，建议使用元组而不使用列表 列表不能座位字典的键，而元组则可以 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:3","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.4 字典(dictionary) 字典的特性： 通过键而不是通过索引来读取 字典式任意对象的无序集合 字典是可变的，并且可以任意嵌套 字典中的键必须是唯一 字典中的键必须不可变 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:4","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5. 字符串和正则表达式 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:0","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5.1 字串常用操作 # 拼接 a='abc'+'bc'+'CD'+str(123)+'@' print(a) # 计算长度 print(len(a)) # 截取字符串【string[start🔚step]】 sub=a[2:7:2] print(sub) # 分割字符串【str.splite(sep,maxsplit)】 li=a.split('b') print(li) li=a.split('b',1) print(li) # 检索字符串count find index startswith endswith print(a.count('b')) print(a.find('b')) print(a.index('b')) print(a.startswith('abc')) print(a.endswith('123')) # 字母大小写 print(a.upper()) print(a.lower()) # 去特殊字符 print(a.strip('@')) 格式化字符串 常用格式化字符 s 字符串（采用str() 显示） r 字符串（采用repr() 显示） c 单个字符串 o 八进制整数 d 十进制整数 e 指数 x 十六进制整数 f 浮点数 % 字符串% template= '{:0\u003e9s}\\tname:{:s}\\ttitle:sr.{:s}' print(template.format('1','hello','wang')) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:1","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5.2 正则表达式基础 行定位符 ^tm$ 元字符 \\w\\s\\d\\b 限定符 ? + * {n} {n,} {n,m} 字符类 abc 排除字符 ^abc 选择字符 | 转义字符 \\ 分组 () ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:2","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5.3 使用re模块实现正则表达式 # re.match(pattern.string,[flags]) # re.search(pattern,string,[flags]) # re.findall(pattern,string,[flags]) # re.sub(pattern,repl.string,count,flags) # re.split(pattern,string,[maxsplite],[flags]) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:3","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["软件工程"],"content":" Scrum Learning Notes Scrum 学习笔记 理论与价值观 敏捷宣言 5 个价值观 8 大价值观 12 个原则 3 个角色 3 个工件 5 个活动 估算与计划 计划失败的原因 估算大小的策略 为价值制定计划 确定优先级因素 确定渴望度优先级 分解用户故事 用户故事的六个特性 - INVEST 确定经济优先级 会议与实战 Product Bocklog Refinement 框架 Skeleton 备忘录 Cheat Sheet Sprint Planning PART I PART II Spint Review 框架 Sprint Retrospective 发布计划策略 迭代计划策略 估算速度策略 有效原因与指导原则 敏捷计划有效原因 敏捷估算和计划的 12 条指导原则 Scrum 学习笔记 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:0:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"理论与价值观 在有限的时间（TimeBox）里 团队一起合作（Work Together），我们彼此信任（Trust）并发挥自我最大的能力和优势（Do The Best），持续不断的交付（CI，CD）可用、有价值（Usable，Valuable）的软件，赢得客户的满意。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"敏捷宣言 个体和互动 高于 流程和工具 （合作，信赖） 工作的软件 高于 详尽的文档 （产品增量） 客户合作 高于 合同谈判（同一组织） 响应变化 高于 遵循计划（公开，透明） ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"5 个价值观 专注 - 由于我们在一段时间内只能专注于少数几件事情，所以我们可以很好的合作并获得优质的产出，我们能够更快的交付有价值的事项。 公开 - 在团队合作中大家都会表达我们做的如何，以及遇到的障碍。我们发现将担忧说出来是一件好事，因为只有这样才能让这些担忧及时得到解决。 尊重 - 因为我们在一起工作，分享和成功失败，这有助培养并加深互相之间的尊重，并帮助彼此成为值得尊重的人。 承诺 - 由于对自己的命运有更大的掌控，我们会有更坚定的信念去获得成功。 勇气 - 因为我们不是单打独斗，我们能够感受到支持，而且掌握更多资源。这一切赋予我们勇气去迎接更大的挑战。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"8 大价值观 诚实，开放，勇气，尊重，专注，信任，授权，合作 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:3","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"12 个原则 我们最重要的目标，是通过及早和持续不断地交付有价值的软件使客户满意。 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。 业务人员和开发人员必须相互合作，项目中的每一天都不例外。 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。 可工作的软件是进度的首要度量标准。 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。(稳定的速度) 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。 以简洁为本，它是极力减少不必要工作量的艺术。 最好的架构、需求和设计出自自组织团队。 团队定期地反思如何能提高成效，并依此调整自身的行为表现。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:4","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"3 个角色 PO Scurm Master Team ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:5","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"3 个工件 Product Backlog Sprint Backlog Burndown chart ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:6","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"5 个活动 产品待办事项列表梳理 Sprint 计划 每⽇ Scrum 站会 Sprint 评审 Sprint 回顾 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:7","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"估算与计划 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"计划失败的原因 基于活动而不是基于特性 活动不会提前完成 延误沿着计划表向下传递 活动不是互相独立的 基于活动的计划分散了我们对特性的专注，而特性才是衡量客户价值的单元。解决策略：使用 FDD 策略。 多任务处理导致更多的延迟 - 每个人都达到 100%负荷，这和让高速公路保持 100%负荷结果相同，谁都无法取得任何进展。解决策略：专注 feature，合理估算 不按优先级开发特性 - 传统计划假设所有任务都会完成，但这样会造成如果无法完成会舍弃一些特性，而这些特性可能会比交付的更有价值。解决策略：明确优先级。 忽视不确定性 - 最明显的效果就是造成 delay。 解决策略：迭代。 把估算当作承诺 - 估算只是一个可能性，而对一个可能性做出承诺是不可能的。解决策略：对特性承诺而非时间。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"估算大小的策略 故事点的优势 故事点有助于驱动跨功能行为 故事点估算不会过期 故事点是纯粹对大小进行度量 故事点估算通常更快 我的理想人天不等于你的理想人天 理想人天 理想人天在团队以外更容易解释 理想人天估算更容易开始 理想人天便于预测速度 使用模糊的故事点产生的不舒服感觉是非常短暂的。 公司让实际人天接近于理想人天的压力会带来负面影响。 使用故事点估算更有说服力。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"为价值制定计划 确定优先级因素 价值 估算经济回报是一件很困难的工作，常常需要一种替代方案对价值估算 ** 确定渴望度的优先级 成本 确定经济优先级 新知识 关于产品的知识 关于技术的知识 风险 进度风险 成本风险 功能风险 确定渴望度优先级 客户满意度的 Kano 模型 作为阈值的特性 线性特性 兴奋点和惊喜点 Kano 模型 5 个度量点: 我希望这样; 我预期就是这样; 我没有意见; 我可以忍受这样; 我不希望这样; ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:3","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"分解用户故事 用户故事的六个特性 - INVEST 独立性 Independent、可协商性 Negotiable、有价值 Valuable、可以估算 Estimable、短小 Small、可测试性 Testable 何时分解用户故事 用户故事太大，不能放进单次迭代的时候 大型故事分解有助于作出更准确的估算 按照数据边界分解 按照用户故事所支持数据的边界来分解大型用户故事 按照操作边界分解 CURD 去除横切考虑 例如：日志 忽略满足性能限制 考虑把功能性和非功能性需求隔离到不同的用户故事，从而分解大型用户故事 分解具有混合优先级的用户故事 如果大型用户故事中的小故事具有不同的优先级，则可以对它们进行分解 不要把故事分解成任务 不要把大型用户分解成任务，而是寻找一种方法来让一颗曳光弹穿过整个故事 避免相关变化的诱惑 避免在具有适当大小的特性中增加相关变化而把事情弄糟，除非这些变化具有相同的优先级 组合用户故事 对于2周一次的迭代周期工作的团队来说，合适的做法是把特性分解成 2-5 天的用户故事 组合小故事 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:4","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"确定经济优先级 收入来源 新收入 增量收入 促进现有客户购买更多许可 包含了可以独立出售的可选，附加模块 包含允许提高收费的功能 促进对咨询服务的使用 留存收入 如果不开发项目或主题，公司会损失的收入 操作效率 需要或者在公司成长后需要很长时间的事 部门之间更好的集成和交流 减少人员更替 对新人缩短培训时间 任何对时间敏感的过程 综合多个过程 任何可以提高准确性和减少返工的工作 经济指标 1 金钱的时间价值 2 净现值 NPV 3 内部收益率 4 投资回收期 5 折现回收期 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:5","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"会议与实战 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Product Bocklog Refinement 框架 Skeleton 展示现阶段以及中期目标 展示并澄清 Product Backlog 团队估算 PBI PO 按照期望团队交付的顺序为 PBI 排序 分成小组协作对需求建模，切分以及确定验收条件 备忘录 Cheat Sheet 梳理之前是否与利益相关者一起评估确认远景、目标和 backlog 条目 团队和主要的利益相关者在场 会议由 ScurmMaster 或者 PO 引导 预留 sprint 总时间的 5%-10%梳理 backlog PO 把远景、目标和整个 backlog 分享给大家 技术风险是否被确认并创建响应的 spike Product Backlog 是一个有序列表 把所有的反馈、变更、缺陷记录到 Product Backlog 产品 Backlog 包括现景、近景和远景 团队一起对所有的条目估算 排列靠前的条目都有验收条件而且有具体实例 所有不确定的问题被记录下来等待会后继续调研 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Sprint Planning PART I 展示重要的 PBI 澄清 PBI 相关的问题 团队协作梳理新的 PBI 团队按照顺序尝试选择 PBI PART II 重新调整“完成的定义” 计算团队下个 Sprint 可用时间 团队一起讨论可能的实现方案 团队协作创建任务并估算 根据时间或速率向 PO 做出最终承诺 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Spint Review 框架 评估已经完成的 PBI 与承诺的 PBI 和 Sprint 目标 用讲故事的方式演示完成的功能 收集反馈 展示接下来要做的重要 PBI ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:3","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Sprint Retrospective 安全感 How much will each person participate 发现 Big Picture 分析 Continue; Fix; Stop; 计划 Where dowe want to be? How do we get there from here? 收尾 How to ducument; How to execute; ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:4","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"发布计划策略 确定满意条件，（日期驱动，特性驱动） 估算用户故事， 选择迭代周期长度，（官方建议：2 周迭代，压力分摊，6x2+1） 估算速度，（速度策略） 确定用户故事的优先级， 选择用户故事和发布时间 确定最初 1-3 个迭代的具体工作 卡片记录 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:5","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"迭代计划策略 速度驱动的迭代计划（客观） 调整优先级 确定目标速度 确定迭代目标 选择用户故事 把用户故事分解成任务 只包含此项目增加价值的工作 - 如“回复邮件 1 小时”。 尽量明确，直到养成习惯 - 如自动化测试培养。 会议会占据（很多）时间（整体时间：如开会）。 缺陷- 发现 bug 的迭代中就修复它们。 处理依赖性 - 如 mock 数据 难以分解的工作 - 探针策略 对任务进行估算 一部分设计就够了 任务的适合大小 承诺驱动的迭代计划（主观） 要求团队做出承诺(团队主导，承诺特性非任务)“你们可以承诺交付我们已经讨论过的特性么？” 对估算值求和 -实际上大多数团队在计划每天 4-6 个小时的工作量时候能够取得成功 维护与承诺 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:6","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"估算速度策略 如果你在给出对速度的估算前可以进行一次或多测迭代， ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:7","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"有效原因与指导原则 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:4:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"敏捷计划有效原因 经常重新计划 承认不可能建立完美的计划，可以大量减少焦虑，而且可以逐步的消除这种不精确性。 对大小和持续时间的估算时独立的 大小和时间时有关系统的，但很多因素也会影响持续时间。 故事点来估算大小，接下来估算速度，然后规模和速度估算结合起来就可以得到持续时间 在不同层次制定计划 发布计划，迭代计划，每日计划。1.不同的计划是用于不同的目的事实。2.帮助开发团队从不同的角度来看待项目。 基于特性而不是基于任务制定计划 团队可以少做一些关于特定任务的预先考量。让团队思考正在开发的特性。 小故事保持工作流畅 每个迭代都要消除未完成的工作 在团队层次跟踪 不要准备个人燃尽图**而只绘制团队层次的燃尽图 承认不确定性并为之计划 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:4:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"敏捷估算和计划的 12 条指导原则 让整个团队参与 在不同层次上进行计划 使用不同度量单位，让对大小和持续时间的估算保持独立 用功能或者日期来体现不确定性 经常重新计划 跟踪进度并沟通 承认学习的重要性 计划具有适当大小的特性 确定特性优先级 最好的估算和计划来源于事实 保留一些松弛度 通过前瞻性计划协调多个团队 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:4:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["语言与平台"],"content":" Jupyter Notebook Shortcuts ","date":"2020-06-04","objectID":"https://blog.gethin.online/jupyter-notebook-shortcuts/:0:0","tags":["python"],"title":"JUPYTER NOTEBOOK SHORTCUTS","uri":"https://blog.gethin.online/jupyter-notebook-shortcuts/"},{"categories":["语言与平台"],"content":"Command model Key Function 作用 Enter take you into edit mode 转入编辑模式 Shift-Enter run the current cell, select below 运行本单元，选中下个单元 Ctrl-Enter run selected cells 运行本单元 Alt-Enter run the current cell, insert below 运行本单元，在其下插入新单元 Y change the cell type to Code 单元转入代码状态 M change the cell type to Markdown 单元转入 markdown 状态 R change the cell type to Raw 单元转入 raw 状态 1 set level 1 title 设定 1 级标题-仅在 markdown 状态下 2 set level 2 title 设定 2 级标题 3 set level 3 title 设定 3 级标题 4 set level 4 title 设定 4 级标题 5 set level 5 title 设定 5 级标题 6 set level 6 title 设定 6 级标题 Up select cell above 选中上方单元 K select cell above 选中上方单元 Down select cell below 选中下方单元 J select cell above 选中下方单元 Shift-K Move selected cells up 连续选择上方单元 Shift-J Move selected cells down 连续选择下方单元 A insert cell above 在上方插入新单元 B insert cell below 在下方插入新单元 X cut selected cells 剪切选中的单元 C copy selected cells 复制选中的单元 Shift-V paste cells above 粘贴到上方单元 V paste cells below 粘贴到下方单元 Z undo cell deletion 恢复删除的最后一个单元 D,D delete selected cells 删除选中的单元 Shift-M merge cell below 合并选中的单元 Ctrl-S save and checkpoint 保存当前 NoteBook S Save and Checkpoint 保存当前 NoteBook L toggle line numbers 开关行号 O toggle output 转换输出 Shift-O toggle output scrolling 转换输出滚动 Esc close pager 关闭页面 Q close pager 关闭页面 H show all shortcuts 显示快捷键帮助 Shift-Space scroll notebook up 向上滚动 Space scroll notebook down 向下滚动 ","date":"2020-06-04","objectID":"https://blog.gethin.online/jupyter-notebook-shortcuts/:1:0","tags":["python"],"title":"JUPYTER NOTEBOOK SHORTCUTS","uri":"https://blog.gethin.online/jupyter-notebook-shortcuts/"},{"categories":["语言与平台"],"content":"Edit Mode Key Function 作用 Tab code completion or indent 代码补全或缩进 Shift-Tab tooltip 提示 Ctrl-] indent 缩进 Ctrl-[ dedent 解除缩进 Ctrl-A select all 全选 Ctrl-Z undo 撤销 Ctrl-Shift-Z redo 重做 Ctrl-Y redo 重做 Ctrl-Home go to cell start 跳到单元开头 Ctrl-Up go to cell start 跳到单元开头 Ctrl-End go to cell end 跳到单元末尾 Ctrl-Down go to cell end 跳到单元末尾 Ctrl-Left go one word left 跳到左边一个字首 Ctrl-Right go one word right 跳到右边一个字首 Ctrl-Backspace delete word before 删除前面一个字 Ctrl-Delete delete word after 删除后面一个字 Esc command mode 切换到命令模式 Ctrl-M command mode 切换到命令模式 Shift-Enter run cell, select below 运行本单元，选中下一单元 Ctrl-Enter run cell 运行本单元 Alt-Enter run cell, insert below 运行本单元，在下面插入一单元 Ctrl-Shift- - split cell 分割单元 Ctrl-Shift-Subtract split cell 分割单元 Ctrl-S Save and Checkpoint 保存当前 NoteBook Up move cursor up or previous cell 光标上移或转入上一单元 Down move cursor down or next cell 光标下移或转入下一单元 Ctrl-/ toggle comment on current or selected lines 注释整行/撤销注释 Written with StackEdit. ","date":"2020-06-04","objectID":"https://blog.gethin.online/jupyter-notebook-shortcuts/:2:0","tags":["python"],"title":"JUPYTER NOTEBOOK SHORTCUTS","uri":"https://blog.gethin.online/jupyter-notebook-shortcuts/"},{"categories":["语言与平台"],"content":" Python Learning Notes - Junior ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:0:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1. python 入门 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.1. 注释 单行注释 # 注释内容 多行注释 \"\"\"注释内容\"\"\" 中文编码声明注释 # coding=utf-8 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:1","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.2. 代码缩进 采用代码缩进和冒号“：”区分代码之间的层次，python 对代码缩进非常严格，如果不合理缩进会抛出 SyntaxError 异常。 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:2","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.3. 代码规范 1.3.1. 编写规范 每个 import 只导入一个模块 不要再行尾添加分号“；” 仅以每行不超过 80 个字符；如果超过，仅以使用小括号“（）” 使用必要的空行可以提高代码可读性 通常情况下，运算符两侧、函数参数之间、逗号“，”两侧建议使用空格进行分隔 应该避免在循环中使用+和+=运算符累加字符串，推荐做法是将每个字符串加入列表，然后再循环结束后使用 join 方法连接列表。 适当的使用一场处理提高程序容错性 1.3.2. 命名规范 模块名尽量短小，并且全部使用小写字母，可以使用下划线分割多个字母 如：game_main 包名尽量短小，并且全部使用小写字母，不推荐使用下划线，如：com.cr 类名采用单词首字母大写形式，即 Pascal 风格 如：TakeSomething 模块内部的类采用下划线+Pascal 风格的类名组成 如：_TakeSomething 函数、类的属性和方法的命名规则同模块类似，也是全部采用小写字母，多个字母间用下划线_进行分割 常量明明时全部采用大写字母，可以使用下划线 使用单下划线_开头的模块变量或者函数是受保护的，在使用 import * from 语句从模块中导入时这些变量或者函数不能导入 使用双下划线__开头的实例变量或者方法时类私有的 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:3","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.4. 基本输出 使用 print() 函数输出 使用 input() 函数输入 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:4","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2. 变量和数据类型 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.1. 保留字 Python 保留字: and, as, assert, break, class, continue, def, del, elif, else, except, finally, for, form, False, global, if, import, in, is, lambda, nonlocal, not, None, or, pass, raise, return, try, True, while, with, yield ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:1","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.2. 标识符 标识符命名规则：数字，字母，下划线，不能使用保留字 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:2","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.3. 变量 在 python 中，不需要先声明变量名及其类型，直接赋值即可创建各种类型变量。 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:3","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.4. 基本数据类型 2.4.1.数字类型 整数 十进制 八进制 - 必须以 0o/0O 开头 十六进制 - 必须以 0X/0x 开头 二进制 浮点数 复数 2.4.2. 字符串类型 通常使用‘’，“”，‘“’”。单引号双引号必须再一行，三引号可以分布在多行。 转义符：\\（续行符）,\\n（换行符）,\\0（空）,\\t（水平制表符）,\"（双引号）,'（单引号）,\\（一个反斜杠）,\\f（换页）,\\0dd（八进制数，dd 表示字符）,\\xhh（十六进制数，hh 表示字符） 布尔类型 类型转换 int(x) | float(x) | complex(real [,imag]) | str(x) | repr(x) | eval(str) | chr(x) | ord(x) | hex(x) | oct(x) ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:4","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.5. 运算符 2.5.1 数字运算符 +,-,*,/,%(余),//(取整除),**(幂) 2.5.2 赋值运算符 =,+=,-=,*=,/=,%=,//=,**= 2.5.3 比较运算符 \u003e,\u003c,==,!=,\u003e=,\u003c= 2.5.4 逻辑运算符 and,or,not 2.5.5 位运算符 \u0026,|,^,~,\u003c\u003c,\u003e\u003e ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:5","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3. 流程控制 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.1 选择语句 if 表达式: 语句块 if 表达式: 语句块 else: 语句块 if 表达式: 语句块 elif 表达式: 语句块 else: 语句块 if 表达式: if 表达式: 语句块 else: 语句块 else: 语句块 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:1","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.2 条件表达式 a=1 b=a if a\u003e0 else -a ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:2","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.3 循环语句 while 表达式: 循环体 for 迭代变量 in 对象: 循环体 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:3","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.4 跳转语句 break,continue ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:4","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.5 pass 空语句 pass 不做任何事 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:5","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["数据与算法"],"content":"海量数据优化 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:0","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"1. 合理使用索引 索引是数据库中重要的数据结构，它的根本目的就是为了提高查询效率。现在大多数的数据库产品都采用 IBM 最先提出的 ISAM 索引结构。索引的使用要恰到好处，其使用原则如下： 在经常进行连接，但是没有指定为外键的列上建立索引，而不经常连接的字段则由优化器自动生成索引。 在频繁进行排序或分组（即进行 group by 或 order by 操作）的列上建立索引。 在条件表达式中经常用到的不同值较多的列上建立检索，在不同值少的列上不要建立索引。比如在雇员表的“性别”列上只有“男”与“女”两个不同值，因此就无必要建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。 如果待排序的列有多个，可以在这些列上建立复合索引（compound index）。 使用系统工具。如 Informix 数据库有一个 tbcheck 工具，可以在可疑的索引上进行检查。在一些数据库服务器上，索引可能失效或者因为频繁操作而使得读取效率降低，如果一个使用索引的查询不明不白地慢下来，可以试着用 tbcheck 工具检查索引的完整性，必要时进行修复。另外，当数据库表更新大量数据后，删除并重建索引可以提高查询速度。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:1","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"2. 避免或简化排序 应当简化或避免对大型表进行重复的排序。当能够利用索引自动以适当的次序产生输出时，优化器就避免了排序的步骤。以下是一些影响因素： 索引中不包括一个或几个待排序的列； group by 或 order by 子句中列的次序与索引的次序不一样； 排序的列来自不同的表。 为了避免不必要的排序，就要正确地增建索引，合理地合并数据库表（尽管有时可能影响表的规范化，但相对于效率的提高是值得的）。如果排序不可避免，那么应当试图简化它，如缩小排序的列的范围等。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:2","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"3. 消除对大型表行数据的顺序存取 在嵌套查询中，对表的顺序存取对查询效率可能产生致命的影响。比如采用顺序存取策略，一个嵌套 3 层的查询，如果每层都查询 1000 行，那么这个查询就要查询 10 亿行数据。避免这种情况的主要方法就是对连接的列进行索引。 例如，两个表：学生表（学号、姓名、年龄……）和选课表（学号、课程号、成绩）。如果两个表要做连接，就要在“学号”这个连接字段上建立索引。 还可以使用并集来避免顺序存取。尽管在所有的检查列上都有索引，但某些形式的 where 子句强迫优化器使用顺序存取。下面的查询将强迫对 orders 表执行顺序操作： SELECT * FROM orders WHERE (customer_num=104 AND order_num\u003e1001) OR order_num=1008 虽然在 customer_num 和 order_num 上建有索引，但是在上面的语句中优化器还是使用顺序存取路径扫描整个表。因为这个语句要检索的是分离的行的集合，所以应该改为如下语句： SELECT * FROM orders WHERE customer_num=104 AND order_num\u003e1001 UNION SELECT * FROM orders WHERE order_num=1008 这样就能利用索引路径处理查询。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:3","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"4. 避免相关子查询 一个列的标签同时在主查询和 where 子句中的查询中出现，那么很可能当主查询中的列值改变之后，子查询必须重新查询一次。查询嵌套层次越多，效率越低，因此应当尽量避免子查询。如果子查询不可避免，那么要在子查询中过滤掉尽可能多的行。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:4","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"5. 避免困难的正规表达式 MATCHES 和 LIKE 关键字支持通配符匹配，技术上叫正规表达式。但这种匹配特别耗费时间。例如： SELECT * FROM customer WHERE zipcode LIKE “98_ _ _” 即使在 zipcode 字段上建立了索引，在这种情况下也还是采用顺序扫描的方式。如果把语句改为SELECT * FROM customer WHERE zipcode \u003e“98000”，在执行查询时就会利用索引来查询，显然会大大提高速度。 另外，还要避免非开始的子串。例如语句：SELECT * FROM customer WHERE zipcode[2，3] \u003e“80”，在 where 子句中采用了非开始子串，因而这个语句也不会使用索引。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:5","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"6.使用临时表加速查询 把表的一个子集进行排序并创建临时表，有时能加速查询。有助于避免多重排序操作，而且在其他方面还能简化优化器的工作。例如： SELECT cust.name，rcvbles.balance，……other columns FROM cust，rcvbles WHERE cust.customer_id = rcvlbes.customer_id AND rcvblls.balance\u003e0 AND cust.postcode\u003e“98000” ORDER BY cust.name 如果这个查询要被执行多次而不止一次，可以把所有未付款的客户找出来放在一个临时文件中，并按客户的名字进行排序： SELECT cust.name，rcvbles.balance，……other columns FROM cust，rcvbles WHERE cust.customer_id = rcvlbes.customer_id AND rcvblls.balance\u003e0 ORDER BY cust.name INTO TEMP cust_with_balance 然后以下面的方式在临时表中查询： SELECT * FROM cust_with_balance WHERE postcode\u003e“98000” 临时表中的行要比主表中的行少，而且物理顺序就是所要求的顺序，减少了磁盘 I/O，所以查询工作量可以得到大幅减少。 注意：临时表创建后不会反映主表的修改。在主表中数据频繁修改的情况下，注意不要丢失数据。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:6","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"7. 用排序来取代非顺序存取 非顺序磁盘存取是最慢的操作，表现在磁盘存取臂的来回移动。SQL 语句隐藏了这一情况，使得在写应用程序时很容易写出要求存取大量非顺序页的查询。 有些时候，用数据库的排序能力来替代非顺序的存取能改进查询。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:7","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"百万数据查询优化技巧三十则 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询： select id from t where num=0 应尽量避免在 where 子句中使用!=或\u003c\u003e操作符，否则将引擎放弃使用索引而进行全表扫描。 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 下面的查询也将导致全表扫描： select id from t where name like '%abc% 若要提高效率，可以考虑全文检索。 如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)='abc'--name以abc开头的id` select id from t where datediff(day,createdate,'2005-11-30')=0--‘2005-11-30’生成的id 应改为 select id from t where name like 'abc%' select id from t where createdate\u003e='2005-11-30' and createdate\u003c'2005-12-1' 要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(...) 很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段 sex，male、female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 任何地方都不要使用 select * from t，用具体的字段列表代替“*”，不要返回用不到的任何字段。 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 避免频繁创建和删除临时表，以减少系统表资源的消耗。 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 尽量避免大事务操作，提高系统并发能力。 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:2:0","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"常用SQL ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:0","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的存储过程 --select string using in procedure select b.name, a.text from syscomments a left join sysobjects b on b.id=a.id where b.xtype='P' and a.text like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:1","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的列名 --select columns name select b.name as Table1, a.name as Columns1,a.type from syscolumns a left join sysobjects b on b.id=a.id where b.xtype='u' and a.name like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:2","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的表名 --select table name select name from sysobjects where xtype='u' and name like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:3","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的函数名 --select string using in function select b.name, a.text from syscomments a left join sysobjects b on b.id=a.id where b.xtype='fn' and a.text like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:4","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的视图 --select string using in view select b.name, a.text from syscomments a left join sysobjects b on b.id=a.id where b.xtype='V' and a.text like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:5","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询表结构 SELECT table_name=case when a.colorder=1 then d.name else '' end, table_remarks=case when a.colorder=1 then isnull(f.value,'') else '' end, field_no=a.colorder, field_name=a.name, identification=case when COLUMNPROPERTY( a.id,a.name,'IsIdentity')=1 then '√'else '' end, primary_key=case when exists(SELECT 1 FROM sysobjects where xtype='PK' and name in ( SELECT name FROM sysindexes WHERE indid in( SELECT indid FROM sysindexkeys WHERE id = a.id AND colid=a.colid ))) then '√' else '' end, field_type=b.name, bytes=a.length, field_length=COLUMNPROPERTY(a.id,a.name,'PRECISION'), decimal_places=isnull(COLUMNPROPERTY(a.id,a.name,'Scale'),0), is_allow_null=case when a.isnullable=1 then '√'else '' end, default_value=isnull(e.text,''), field_description=isnull(g.[value],'') FROM syscolumns a left join systypes b on a.xtype=b.xusertype inner join sysobjects d on a.id=d.id and d.xtype='U' and d.name\u003c\u003e'dtproperties' left join syscomments e on a.cdefault=e.id left join sys.extended_properties g on a.id=g.major_id and a.colid=g.minor_id left join sys.extended_properties f on d.id=f.major_id and f.minor_id =0 where d.name='table_name' order by a.id desc,a.colorder ; Written with StackEdit. ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:6","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["语言与平台"],"content":" 这篇文章主要是翻译和记录了一些 Gateby 的基础知识，有助于开发者通过这些基础知识进行快速的开发 Refer to the Article: https://mpolinowski.github.io/gatsby-js-knowledgebase ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:0:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"10 添加文件数据(Adding File Data) 使用 Gatsby，您可以使用 GraphQL 直接从文件中查询数据。 Transformer插件将文件节点转换为各种其他类型的数据，例如 gatsby-transformer-json 将 将JSON 文件转换为 JSON 数据节点，而 gatsby-transformer-remark 将 将markdown 文件转换为 MarkdownRemark 节点，您可以从中查询 Markdown 的 的HTML 表示形式。 在这里，我们将使用gatsby-source-filesystem从我们的文件系统创建文件节点。 npm install --save gatsby-source-filesystem 安装后，将插件添加到 gatsby-config.js。 您可以具有此插件的多个实例，以从文件系统上的不同位置读取源节点。 以下设置了 Jekyll 模式：具有 Markdown 文件的页面目录和.json，.yaml，.csv 的数据目录： { resolve: `gatsby-source-filesystem`, options: { name: `pages`, path: `${__dirname}/src/pages/`, }, }, { resolve: `gatsby-source-filesystem`, options: { name: `data`, path: `${__dirname}/src/data/`, }, } 现在，您可以打开 GraphiQL 调试器-在大括号中，当你开始键入 allFiles 时，它应提供自动补全功能。 只需按 Enter 接受，然后再次按 CTRL + ENTER 填写所有页面 ID 的查询： { allFile { edges { node { id } } } } 当你删除 ID 并按 CTRL + SPACE 时，将显示一个包含所有可查询选项的下拉菜单：你可以使用 parent，children 和 和relativePath 属性来创建， 例如 breadcrumb navigation：现在，我们可以在/src/pages/page-2.js 中添加 GraphQL 查询，以遍历我们的所有页面并显示一些数据： export const query = graphql` query MyFilesQuery { allFile { edges { node { relativePath prettySize extension birthTime(fromNow: true) } } } } ` 不要忘记将{data}注入页面组件： const SecondPage = ({data}) =\u003e 现在，我们可以添加一些 JSX 来遍历所有文件，并在\u003ctable\u003e中输出信息 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003erelativePath\u003c/th\u003e \u003cth\u003eprettySize\u003c/th\u003e \u003cth\u003eextension\u003c/th\u003e \u003cth\u003ebirthTime\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e {data.allFile.edges.map(({ node }, index) =\u003e ( \u003ctr key={index}\u003e \u003ctd\u003e {node.relativePath} \u003c/td\u003e \u003ctd\u003e {node.prettySize} \u003c/td\u003e \u003ctd\u003e {node.extension} \u003c/td\u003e \u003ctd\u003e {node.birthTime} \u003c/td\u003e \u003c/tr\u003e ))} \u003c/tbody\u003e \u003c/table\u003e ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:1:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11 使用 Markdown(Working with Markdown) ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.1 添加 Markdown 到 GraphQL 现在，我们可以访问有关我们所有页面的信息。 但是如上所述，在最后一段的开头，我们还可以使用 Gatsby Transformer Plugins 来查找文件并将其内容可以通过 GraphQL 查询。 这里，我们希望使用 Markdown 文件并对其进行转换，以便能够在我们的网站上显示其内容。 为此所需的 Transformer Plugin 是 gatsby-transformer-remark。 首先，我们需要安装插件： npm install --save gatsby-transformer-remark 在 gatsby-config.js 中添加： plugins: [ `gatsby-transformer-remark`, ] 然后在/src/pages/FirstMDpost/index.md 内创建一个 markdown 页面，其中包含一些 FrontMatter（文件开头的元数据，以后可以由 GraphQL 查询）和一些文本： --- path: '/md-posts' title: 'My first Post' date: '2017-10-05' author: 'Mike Polinowski' chapter: 'Index' --- # This is my first mardown Post! 现在我们为 GraphQL 提供了 Markdown -与以前一样，只需开始输入 allMardownRemark（ENTER 自动完成），然后按 CTRL + ENTER 完成查询： ![gatsby_10](https://raw.githubusercontent.com/mpolinowski/gatsby-wiki/master/gatsby_10.png =577x189) 现在，我们可以查询 FrontMatter 以及添加到页面文件夹中的每个 MD 文件的 MD 转换为 HTML 的内容： ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:1","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.2 发布我们的 Markdown 数据模板 这些 Markdown 表示将要被显示的模板，但是现在我们需要创建一个用于此数据的样式模板。让我们先在/src 内添加一个称为templates的文件夹。 现在，向其中添加一个名为post.js的文件，该文件将包含每个帖子条目的结构模板。 该文件包含我们帖子的 JSX markup： import React from 'react' export default function Template({data}) { const {markdownRemark: post} = data return ( \u003cdiv\u003e \u003ch1\u003e{post.frontmatter.title}\u003c/h1\u003e \u003cdiv dangerouslySetInnerHTML={{__html: post.html}} /\u003e \u003c/div\u003e ) } export const postQuery = graphql` query BlogPostByPath($path: String!) { markdownRemark(frontmatter: { path: { eq: $path} }) { html frontmatter { path title } } } ` \u003cTemplate /\u003e组件接收{data}属性，这些属性由 GraphQL 查询检索。 该查询会查找 markdown 中 中frontmatter 里面所有 URL 等于$Path 的帖子，所以如果你在浏览器中键入的这个 URL 是/md-posts，那么路径中带有/md-posts 的文件，就会被调用。 然后，查询使用 markdownRemark 插件将 post markdown 转换为 HTML，并在{data}中提供其前题的路径和标题，并将其传递到组件，然后渲染。 Gatsby 已经配置为将/src/pages 中的所有页面路由为我们网站的页面。 但是现在我们必须注册来自 markdown 文件和 post.js 模板的帖子。 为此，我们必须在应用程序的根目录内创建一个名为 gatsby-node.js 的文件。 我们将使用createPages Gatsby API从我们的帖子模板创建页面： const path = require('path'); exports.createPages = ({boundActionCreators, graphql}) =\u003e { const {createPage} = boundActionCreators; // const createPage = boundActionCreators.createPage; const postTemplate = path.resolve('src/templates/post.js'); return graphql(`{ allMarkdownRemark { edges { node { html id frontmatter { path title } } } } }`) .then(res =\u003e { if(res.errors) { return Promise.reject(res.errors); } res.data.allMarkdownRemark.edges.forEach(({node}) =\u003e { createPage({ path: node.frontmatter.path, component: postTemplate }) }) }) } 保存并重新启动您的应用程序，然后在浏览器中打开 http://localhost:8000/md-posts ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:2","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.3 带有 Markdown 的嵌套路由 要为./src/pages/FirstMDpost/index.md 文件创建子帖子，我们可以简单地向文件夹中添加更多文件，并在其前题中定义嵌套路由 - e.g. ./src/pages/FirstMDpost/myfirstpost.md: --- path: '/md-posts/first-post' title: 'First Blog Post' date: '2017-10-05' author: 'Mike Polinowski' chapter: 'Markdown Posts' --- # This is my first markdown Post! 和 ./src/pages/FirstMDpost/mysecondpost.md: --- path: '/md-posts/second-post' title: 'Second Blog Post' date: '2017-10-05' author: 'Mike Polinowski' chapter: 'Markdown Posts' --- # A dive into Markdown Syntax 它们可以分别通过http://localhost:8000/md-posts/first-post和http://localhost:8000/md-posts/second-post 来访问 ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:3","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.4 创建 Index 页面 现在，我们可以使用 GraphQL 检索所有 Markdown 页面并将过滤它们。 对于此测试，我们将一个表添加到起始页面，显示最后 10 个帖子（到目前为止，我只发表了 3 3个帖子…），我们希望按日期降序排列它们，并且仅显示 chapter: ‘Markdown Posts’的页面 ，并排除我们的 index.md： const IndexPage = ({data}) =\u003e ( \u003cdiv\u003e \u003ch2\u003eMarkdown Index\u003c/h2\u003e \u003cp\u003eThe table below sorts out all Markdown pages that are not inside the \"Markdown Posts\" chapter - as defined inside their frontmatter. It also applies a filter, to only display the latest 10 posts. Click on here to display \u0026nbsp; \u003cLink to=\"/md-posts/\"\u003e all Markdown pages \u003c/Link\u003e .\u003c/p\u003e \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eDate\u003c/th\u003e \u003cth\u003eLink\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e {data.allMarkdownRemark.edges.map(post =\u003e ( \u003ctr key={post.node.id}\u003e \u003ctd\u003e {post.node.frontmatter.date} \u003c/td\u003e \u003ctd\u003e \u003cLink to={post.node.frontmatter.path}\u003e {post.node.frontmatter.title} \u003c/Link\u003e \u003c/td\u003e \u003c/tr\u003e ))} \u003c/tbody\u003e \u003c/table\u003e \u003c/div\u003e ) export const pageQuery = graphql` query IndexQuery { allMarkdownRemark(limit: 10 sort: {fields: [frontmatter___date], order: DESC} filter: { frontmatter: { chapter: {eq: \"Markdown Posts\"} }} ) { edges { node { id frontmatter { path title date } } } } } ` ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:4","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.5 缓存 Markdown 中的链接 一旦开始在 Markdown 文件中添加链接，您会发现单击它们会重新加载您的应用程序-这不是很好 :( 但请放心，这里的gatsby-plugin-catch-links可以助您一臂之力！ 它-安装后，将其添加到./gatsby-config.js 中的 Gatsby 插件中，它就可以正常工作： npm install --save gatsby-plugin-catch-links // In your gatsby-config.js plugins: [ `gatsby-plugin-catch-links`, ] ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:5","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"12 添加 Material-UI 为了使我们的生活更轻松，我们希望包含来自@ Materials-UI 的即用型 material 设计组件。 我们将安装 v.1.0.0 的测试版-它也需要 Roboto Fontface 和 和Material-UI 图标： npm install material-ui@next --save npm install typeface-roboto --save npm install material-ui-icons --save 现在，我们可以轻松地将 Material-UI 组件导入我们的应用程序： import React from 'react' import { render } from 'react-dom' import Button from 'material-ui/Button' import 'typeface-roboto' function AppWithButton() { return ( \u003cButton\u003e Hello World \u003c/Button\u003e ); } render(\u003cAppWithButton /\u003e, document.querySelector('#app')); ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:3:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"13 添加 Elasticsearch 该项目的先决条件之一是，我们需要为我们的 ElasticSearch Index 创建一个闪电般的界面。 我们已经为其构建了ES6 Class component。并将其添加到 Gatsby/Material-UI 中非常简单。 首先，添加./src/pages/search/jsx 并修改 ElasticSearch 组件来配合我们的 UI. import React, { Component } from 'react' import Link from 'gatsby-link' import elasticsearch from 'elasticsearch' import { withStyles } from 'material-ui/styles' import Grid from 'material-ui/Grid' import Button from 'material-ui/Button' import ResultCards from '../components/ResultCards' const connectionString = 'localhost:9200' const _index = 'wiki2_de_2017_09_09' const _type = 'article' let client = new elasticsearch.Client({ host: connectionString, log: \"trace\" }) const rootStyle = { flexGrow: 1, marginTop: 30, } export class Search extends Component { constructor(props) { super(props) this.state = { results: [] }; this.handleChange = this.handleChange.bind(this) } handleChange(event) { const search_query = event.target.value; client.search({ index: _index, type: _type, body: { query: { multi_match: { query: search_query, fields: ['title^100', 'tags^100', 'abstract^20', 'description^10', 'chapter^5', 'title2^10', 'description2^10'], fuzziness: 1, }, }, }, }).then(function(body) { this.setState({ results: body.hits.hits }); }.bind(this), function(error) { console.trace(error.message); } ); } render() { return ( \u003cdiv className=\"container\"\u003e \u003cinput type=\"text\" onChange={this.handleChange} /\u003e \u003cSearchResults results={this.state.results} /\u003e \u003c/div\u003e ); } } const SearchResults = ({results}) =\u003e ( \u003cdiv className=\"search_results\"\u003e \u003cbr/\u003e\u003chr/\u003e \u003cdiv className={rootStyle}\u003e \u003cGrid container spacing={24}\u003e {results.map((result , i) =\u003e \u003cResultCards key={i} image={result._source.image} title={result._source.title2} link={result._source.link} abstract={result._source.abstract}/\u003e )} \u003c/Grid\u003e \u003c/div\u003e \u003cbr/\u003e\u003cbr/\u003e\u003cLink to=\"/\" style={{ textDecoration: 'none' }}\u003e\u003cButton raised color=\"primary\"\u003eGo back to the homepage\u003c/Button\u003e\u003c/Link\u003e \u003c/div\u003e ) export default Search \u003cSearchResults /\u003e组件将遍历\u003cResultCards /\u003e组件内的 Material UI Card： import React from 'react' import Link from 'gatsby-link' import Card, { CardActions, CardContent, CardMedia } from 'material-ui/Card' import Button from 'material-ui/Button' import Typography from 'material-ui/Typography' import Grid from 'material-ui/Grid' const ResultCards = ({image, title, abstract, link}) =\u003e ( \u003cGrid item xs={12} sm={6} lg={4}\u003e \u003cCard style={{ maxWidth: 345 }}\u003e \u003cCardMedia style={{ height: 200 }} image={image} title={abstract} /\u003e \u003cCardContent\u003e \u003cTypography type=\"headline\" component=\"h4\" style={{ minHeight: 60, marginBottom: \"10px\" }}\u003e {title} \u003c/Typography\u003e \u003cTypography component=\"p\" style={{ minHeight: 50, marginBottom: \"10px\" }}\u003e {abstract} \u003c/Typography\u003e \u003c/CardContent\u003e \u003cCardActions\u003e \u003cLink to={link} style={{ textDecoration: 'none' }}\u003e \u003cButton dense color=\"primary\"\u003e Read \u003c/Button\u003e \u003c/Link\u003e \u003cButton dense color=\"primary\"\u003e Learn More \u003c/Button\u003e \u003c/CardActions\u003e \u003c/Card\u003e \u003c/Grid\u003e ) export default ResultCards 组件将添加来自 ElasticSearch JSON Response 的结果，并给我们一个灵活的卡片网格。 ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:4:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":" 这篇文章主要是翻译和记录了一些 Gateby 的基础知识，有助于开发者通过这些基础知识进行快速的开发 Refer to the Article: https://mpolinowski.github.io/gatsby-js-knowledgebase ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:0:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"06 属性传递(Passing down Props) 现在，我们可以从父组件传递属性到Counter组件。例： 我们可以通过显示的页面来更改我们的Counter 标题。 ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"6.1 更改头部 \u003cCounter header=\"This is the Index Counter\" /\u003e 这个header的属性现在可以用在Counter组件中的render方法。现在我们可以通过调用他的父组件来为Counter组件获取不同的标头了。 render() { return \u003cdiv\u003e \u003ch3\u003e{this.props.header}\u003c/h3\u003e \u003cp\u003ecurrent count: {this.state.count}\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003eplus\u003c/button\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count - 1 })}\u003eminus\u003c/button\u003e \u003c/div\u003e } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:1","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"6.2 更改样式 样式也是如此-如果我们希望标题与父组件的配色方案匹配，我们只需要将颜色属性传递给 Counter 组件： \u003cCounter header=\"This is the Index Counter\" color=\"rebeccapurple\" /\u003e 并在组件本身中添加必要的内联样式： render() { return \u003cdiv\u003e \u003ch3 style={{color: this.props.color}}\u003e{this.props.header}\u003c/h3\u003e \u003cp\u003ecurrent count: {this.state.count}\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003eplus\u003c/button\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count - 1 })}\u003eminus\u003c/button\u003e \u003c/div\u003e } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:2","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"6.3 设置默认属性 为了确保localhost:8000/counter URL 仍可以被打开，我们现在必须在Counter 组件内部定义一个默认的属性 - 如果没有父组件传递 props，则标题标记和字体颜色将是未定义的！ 这可以通过 Prop-Types 完成，我们需要安装： npm install --save prop-types 现在，我们可以将其导入到/src/pages/counter.js： import React from \"react\" import PropTypes from \"prop-types\" 并在Counter组件内（在export语句上方）为 header prop 定义一个默认值： Counter.defaultProps = { header: \"Default Counter\", color: \"black\", } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:3","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"07 Gatsby 插件(Gatsby Plugins) 插件是实现 Gatsby API 的 的Node.js 软件包。 它们使您能够轻松解决常见的网站构建问题，例如 设置 Sass，添加 markdown 支持，过程映像等。 ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:2:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"7.1 进度动画 在此示例中，我们要使用 NProgress.js 插件将加载动画添加到我们的网站。 您使用 npm 安装 NProgress 插件： npm install --save gatsby-plugin-nprogress 现在，我们必须告诉 Gatsby 通过编辑（在文件不存在的情况下创建）应用程序根目录内的 gatsby-config.js 文件来使用该插件。 在 在starter 模板中，我们已经安装了 react-helmet 插件（此插件如下所述：Page Layout）。 现在，只需将 gatsby-plugin-nprogress 添加到数组中： module.exports = { siteMetadata: { title: `Gatsby Wiki`, }, plugins: [ `gatsby-plugin-react-helmet`, { { resolve: `gatsby-plugin-nprogress`, options: { // Setting a color is optional. color: `rebeccapurple`, // Disable the loading spinner. showSpinner: false, }, }, ], } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:2:1","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"7.2 离线支持和清单 现在，我们想在网站上添加一个 Serviceworker，以帮助我们缓存应用程序的重要部分，从而为我们提供一定程度的脱机支持-正如 Offline Plugin告诉我们的那样，我们还将安装 Manifest Plugin （请确保它是 在 Offline Plugin 之前列出！）。 npm install --save gatsby-plugin-manifest npm install --save gatsby-plugin-offline 现在，将它们添加到我们的 Gatsby 配置中： module.exports = { siteMetadata: { title: `Gatsby Wiki`, }, plugins: [ `gatsby-plugin-react-helmet`, { resolve: `gatsby-plugin-nprogress`, options: { // Setting a color is optional. color: `rebeccapurple`, // Disable the loading spinner. showSpinner: false, }, }, { resolve: `gatsby-plugin-manifest`, options: { name: \"Gatsby Wiki\", short_name: \"Gatsby Wiki\", start_url: \"/\", background_color: \"white\", theme_color: \"rebeccapurple\", display: \"minimal-ui\", icons: [ { // Everything in /static will be copied to an equivalent // directory in /public during development and build, so // assuming your favicons are in /static/favicons, // you can reference them here src: `/apple-touch-icon.png`, sizes: `180x180`, type: `image/png`, }, { { src: `/favicon.ico`, sizes: `256x256`, type: `image/png`, }, ], }, }, `gatsby-plugin-offline`, ], } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:2:2","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"08 单页面应用(Single-Page-Application) Gatsby 基于他的布局特性提供了一个创建 Single-Page-Applications (SPA’s)的简单方法。 你可以在/src/layout 中找到 JSX 和 和CSS。我们正在使用的 Gatsby Starter，已经提供了头导航栏，该头导航栏已在 index.js 文件中定义（并带有必需的 CSS）。 您可以看到该应用程序已经使用React-Helmet作为 Gatsby 插件。 这个可重用的 React 组件将管理您对文档\u003chead\u003e的所有更改。 Helmet采用纯 HTML 标记并输出纯 HTML 标记。 该布局定义了\u003cHeader /\u003e组件，该组件与\u003cHelmet /\u003e组件一起在\u003cTemplateWrapper /\u003e内部使用。 您到目前为止所创建的页面中的所有内容，都将通过{children}标签注入到 Wrapper 中。 这样，您可以创建顶部导航栏，页眉，侧面导航和页脚，然后将其显示在所有网站上。 ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:3:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"09 GraphQL 我们可以在应用程序的根目录下的 gatsby-config.js 内定义一些全局变量： module.exports = { siteMetadata: { title: `Gatsby Wiki`, author: `Mike Polinowski`, description: `Trying out Gatsby`, }, } 该数据将可用于每个页面，并可使用 GraphQL 查询。 只需将以下 GraphQL 查询添加到/src/pages/index.js，即可保留这些值： export const query = graphql` query FirstQuery { site { siteMetadata { title author description } } } ` 然后，我们需要将此{data}注入父组件\u003cIndexPage /\u003e： const IndexPage = ({data}) =\u003e 现在我们可以查询组件内部的这些数据： \u003ch1\u003e{data.site.siteMetadata.description}\u003c/h1\u003e 为什么是 data.site.siteMetadata？Gatsby 的 的graphql 调试器在 http://localhost:8000/___graphql上运行，您也可以使用它来测试查询并查看结果。 只需打开调试器，然后尝试我们先前的查询： ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:4:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":" 这篇文章主要是翻译和记录了一些 Gateby 的基础知识，有助于开发者通过这些基础知识进行快速的开发 Refer to the Article: https://mpolinowski.github.io/gatsby-js-knowledgebase ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:0:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"00 准备操作 The default Gatsby starter Github 有关项目结构的概述，请参阅Gatsby documentation - Building with Components 从您的 CLI 运行此安装程序（假设已安装 Gatsby）： gatsby new gatsby-wiki ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:1:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"01 开始你的 Gatsby 开发环境(Start your Gatsby development environment) 现在请转到你的站点目录中，并使用 npm 运行你的 Gatsby 开发环境如下： cd gatsby-wiki npm run development 看，你可以访问你的网站了http://localhost:8000 ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:2:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"02 添加内容和链接页面(Adding content and Linking Pages) /src/pages/index.js 文件包含常规的 JSX-在\u003cdiv /\u003e标记内添加任何 HTML，可以让它显示在您的网站内。（Gatsby 使用的热加载） import React from \"react\" import Link from \"gatsby-link\" const IndexPage = () =\u003e ( \u003cdiv\u003e \u003ch1\u003eHi people\u003c/h1\u003e \u003cp\u003eWelcome to your new Gatsby site.\u003c/p\u003e \u003cp\u003eNow go build something great.\u003c/p\u003e \u003cLink to=\"/page-2/\"\u003eGo to page 2\u003c/Link\u003e \u003c/div\u003e ) export default IndexPage 你可以通过import Link from gatsby-link使用 Link 组件并链接到其他页面 \u003cLink to=\"/page-2/\"\u003eGo to page 2\u003c/Link\u003e 链接我们的 index.js 页面到同目录的 page-2 页面。/src /pages 文件夹中的每个 js 文件都会自动被 Gatsby 路由！ ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:3:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"03 样式化 JSX(Styling your JSX) 你可以在组件中使用内联样式如： const IndexPage = () =\u003e ( \u003cdiv style={{ color: \"tomato\", background: \"blue\"}}\u003e \u003ch1\u003eHi people\u003c/h1\u003e \u003cp\u003eWelcome to your new Gatsby site.\u003c/p\u003e \u003cp\u003eNow go build something great.\u003c/p\u003e \u003cLink to=\"/page-2/\"\u003eGo to page 2\u003c/Link\u003e \u003c/div\u003e ) 一些高级样式，请查看 Gatsby 插件 Glamor 或者 Styled Components. 如何安装这些插件请查看Gatsby Plugins。 ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:4:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"04 添加交互式插件(Adding Interactive Components) React 允许你向页面中添加交互 - 我们想添加一个计数器，在加载时将其状态设置为 0，并且有两个使用 onClick 事件增加或减少计数器状态的按钮。 我们可以添加一个新文件/src/pages/counter.js并链接到index页面\u003cLink to=\"/counter/\"\u003eGo to Counter\u003c/Link\u003e。 import React from \"react\" class Counter extends React.Component { constructor() { super() this.state = { count: 0 } } render() { return ( \u003cdiv\u003e \u003ch1\u003eCounter\u003c/h1\u003e \u003cp\u003ecurrent count: {this.state.count}\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003e plus plus\u003c/button\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count - 1 })}\u003e minus minus\u003c/button\u003e \u003c/div\u003e ) } } export default Counter ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:5:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"05 向你的站点导入组件(Importing Components to your Sites) 目前为止，我们将 pages 目录中的每个文件都用作单独的站点。但是 React.js 允许我们采用默认组件-在文件底部导出的默认组件-并将其导入另一个页面。 例如，我们可以将上面的\u003cCounter /\u003e组件添加到索引页面中（而不是仅链接到它）。 我们只需要在/src/pages/index.js开头添加import一行: import React from \"react\" import Link from \"gatsby-link\" import Counter from \"./counter\" 并在 index.js 的 的JSX 代码内引用 Counter，如下所示： const IndexPage = () =\u003e ( \u003cdiv\u003e \u003ch1\u003eHi people\u003c/h1\u003e \u003cp\u003eWelcome to your new Gatsby site.\u003c/p\u003e \u003cp\u003eNow go build something great.\u003c/p\u003e \u003cLink to=\"/page-2/\"\u003eGo to Page 2\u003c/Link\u003e \u003cbr /\u003e \u003cbr /\u003e \u003cCounter /\u003e \u003c/div\u003e ) ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:6:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":null,"content":"自我评价 Hi，我叫GETHIN，是一名主修计算机，有8年工作经验的软件工程师，擅长全栈开发，主要工作语言是C#，曾就职于多家知名外企和互联网企业，如Honeywell，腾讯文学等，目前就职于GreenDot。 擅长技术体系架构设计与重构，软件项目研究，分析设计与风险识别，爱好云原生架构设计。 熟悉OOP，SOA，AOP，MVC，MVVM，EDA，BDD，DDD，微服务架构，云架构，SPA等架构与编程思想，注重基于SOLID编码规范。熟悉常见的架构风格。熟悉各种UML的使用。 精通C#/.NET开发，熟悉Python，精通传统.NET相关技术WCF，WEBAPI，MVC，WPF并熟练掌握现代.NET开发技术.NET Core, RabbitMQ, Azure, K8S, Docker 等。 认证Scrum Master，善于发现和解决敏捷开发中的各种技术和流程问题，熟知软件开发生命周期SDLC。 熟悉手机IOS端开发，Cordova，熟悉react，vue，javascript，jquary等。 了解SQL Server，Oracle，MySQL，存储过程，EF，Redis。 ","date":"0001-01-01","objectID":"https://blog.gethin.online/about/:0:1","tags":null,"title":"关于我","uri":"https://blog.gethin.online/about/"},{"categories":null,"content":"个人经历 GREEN DOT - Sr. Software Engineer 在 GreenDot 担任 高级软件工程师，主要负责开发维护银行后端系统。如银行转账，信用卡自动还款 等 主要的开发语言是 C#，主要技术有 .NET Core, RabbitMQ, WEBAPI，K8S，SQLServer 等 主要项目：Eureka 发卡，TMM，BAAS交易，信用卡自动还款 等 2019 function non0plural(number, name) { if (number == 0) { return \"\" } if (number == 1 || number == -1) { return number + \" \" +name } return number + \" \" + name + \"s\" } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2019-05-31\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 let years = 0 if (months Honeywell - Software Engineer 1 years 在 霍尼韦尔 担任 移动端软件工程师，主要负责开发项目手机端应用，如SRS IOS手机端， 工业报警混合应用端 等 主要开发语言是SWIFT，JS。主要技术有 Cordova，Vue，IOS，Hybird 等 主要项目: REF SAAS IOS端应用，工业报警手机混合端应用 2018 GREEN DOT - Software Engineer II 3 years 在 GreenDot 担任 软件工程师，主要负责开发维护银行风险控制项目 主要开发语言是 C#， 主要技术有 .NET，WCF，MVC，WEBAPI 等 主要项目：APPLY PAY CASH风控，MITIK \u0026 IDOLOGY 风控系统集成，银行常规风控项目 等 2015 腾讯文学 - Software Engineer 1 years 在 腾讯文学 担任 软件工程师，主要负责开发维护起点读书的各种功能 在 主要开发语言是 C#，JS， 主要技术有 .NET，MVC，aspx，memchached，Oracle 主要项目：Mobile 端春节打赏活动，端闪屏替换，文章末打赏互动 等 2014 易贸集团 - Software Engineer 1 years 4 months 在 易贸集团 担任 软件工程师，主要负责开发维护集团内部的各种系统 主要开发语言是 C#，JS， 主要技术有 .NET，MVC，WPF，MSMQ 主要项目：会展系统，客服系统 等 2012 南京航空航天大学 - 计算机专业 4 years 南京航空航天大学，计算机专业，优秀毕业论文 2009 ","date":"0001-01-01","objectID":"https://blog.gethin.online/about/:0:2","tags":null,"title":"关于我","uri":"https://blog.gethin.online/about/"},{"categories":null,"content":"友情链如下 ","date":"0001-01-01","objectID":"https://blog.gethin.online/links/:1:0","tags":null,"title":"友情链接","uri":"https://blog.gethin.online/links/"},{"categories":null,"content":"欢迎留言 ","date":"0001-01-01","objectID":"https://blog.gethin.online/message-board/:1:0","tags":null,"title":"留言板","uri":"https://blog.gethin.online/message-board/"},{"categories":null,"content":"此页面用于展示收藏的网站 ","date":"0001-01-01","objectID":"https://blog.gethin.online/websites/:1:0","tags":null,"title":"网站收藏","uri":"https://blog.gethin.online/websites/"},{"categories":null,"content":"网站里程碑 BLOG 3.0 ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:0","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"},{"categories":null,"content":"个人博客3.0 由 hugo \u0026 loveit \u0026 github page 驱动 https://blog.gethin.online 摘要 博客3.0 基于 hugo 建站，主题采用了loveit，github action 作为 CI/CD，托管于github page。 gatsby 始终还是太重了，而且升级难度太大，依赖的包太多。强大也是强大的，折腾也是真折腾。人生有限，所以还是调整了策略，把博客迁移到hugo上，还是站在巨人的肩膀上才能做更多的事情。 摘要 2021-6-3 | 添加赞赏、网站分析、版权等功能 2021-5-28 | 添加时间轴、脑图、文章加密等功能 2021-5-17 | 添加背景图片 2021-5-16 | 添加顶部菜单 2021-5-12 | 添加测试文章 2021-5-11 | 集成搜索自动化 2021-5-10 | 添加评论，搜索 2021-5-6 | 集成Github Action 2021-5-5 | 建站 2021 function non0plural(number, name) { if (number == 0) { return \"\" } if (number == 1 || number == -1) { return number + \" \" +name } return number + \" \" + name + \"s\" } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2021-05-05\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 let years = 0 if (months BLOG 2.0 1 years ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:1","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"},{"categories":null,"content":"个人博客2.0 由 gatsby \u0026 tinacms \u0026 netlify 驱动 https://gethin.online 摘要 博客2.0 基于 gatsby 建站，主题采用了tinacms，netlify 作为 CI/CD，托管于netlify。 之前的基于react gatsby 引擎，依托于aks，个人维护精力有限，实在踩不起 19年 azure k8s 的那些坑。所以决定对网站进行升级，并托管于netlify。目前网站仍然保留。 2020 BLOG 1.0 10 months ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:2","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"},{"categories":null,"content":"个人博客1.0 由 gatsby \u0026 AKS 驱动 https://gethin.online 摘要 博客1.0 基于 gatsby 建站，自建主题，Azure DEVOPS 作为 CI/CD，托管于自建AKS。 2019年底个人博客建站，托管于自建AKS，使用Azure DEVOPS 作为CI/CD。博客用于总结个人技术，专注云原生，kubernetes，python 等技术。 2019 ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:3","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"}]