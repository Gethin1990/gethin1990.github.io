[{"categories":["架构艺术"],"content":"为什么使用MQ？MQ的优点 简答 异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。 流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。 日志处理 - 解决大量日志传输。 消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。 详答 主要是：解耦、异步、削峰。 解耦：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。 就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。 异步：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。 削峰：减少高峰时期对服务器压力。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:1:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息队列有什么优缺点？RabbitMQ有什么优缺点？ 优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。 缺点有以下几个： 系统可用性降低 本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低； 系统复杂度提高 加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。 一致性问题 A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。 所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:2:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"你们公司生产环境用的是什么消息中间件？ 这个首先你可以说下你们公司选用的是什么消息中间件，比如用的是RabbitMQ，然后可以初步给一些你对不同MQ中间件技术的选型分析。 举个例子：比如说ActiveMQ是老牌的消息中间件，国内很多公司过去运用的还是非常广泛的，功能很强大。 但是问题在于没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企业，用ActiveMQ做异步调用和系统解耦。 然后你可以说说RabbitMQ，他的好处在于可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。 另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。 而且经过调研，国内各大互联网公司落地大规模RabbitMQ集群支撑自身业务的case较多，国内各种中小型互联网公司使用RabbitMQ的实践也比较多。 除此之外，RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化，因此综合考虑过后，公司采取了RabbitMQ。 但是RabbitMQ也有一点缺陷，就是他自身是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以。 然后可以聊聊RocketMQ，是阿里开源的，经过阿里的生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。 而且RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。 另外就是Kafka。Kafka提供的消息中间件的功能明显较少一些，相对上述几款MQ中间件要少很多。 但是Kafka的优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。 因此Kafka在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。但是在传统的MQ中间件使用场景中较少采用。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:3:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？ ActiveMQ RabbitMQ RocketMQ Kafka ZeroMQ 单机吞吐量 比RabbitMQ低 2.6w/s（消息做持久化） 11.6w/s 17.3w/s 29w/s 开发语言 Java Erlang Java Scala/Java C 主要维护者 Apache Mozilla/Spring Alibaba Apache iMatix，创始人已去世 成熟度 成熟 成熟 开源版本不够成熟 比较成熟 只有C、PHP等版本成熟 订阅形式 点对点(p2p)、广播（发布-订阅） 提供了4种：direct, topic ,Headers和fanout。fanout就是广播模式 基于topic/messageTag以及按照消息类型、属性进行正则匹配的发布订阅模式 基于topic以及按照topic进行正则匹配的发布订阅模式 点对点(p2p) 持久化 支持少量堆积 支持少量堆积 支持大量堆积 支持大量堆积 不支持 顺序消息 不支持 不支持 支持 支持 不支持 性能稳定性 好 好 一般 较差 很好 集群方式 支持简单集群模式，比如’主-备’，对高级集群模式支持不好。 支持简单集群，‘复制’模式，对高级集群模式支持不好。 常用 多对’Master-Slave’ 模式，开源版本需手动切换Slave变成Master 天然的‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave 不支持 管理界面 一般 较好 一般 无 无 综上，各种对比之后，有如下建议： 一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了； 后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高； 不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。 所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。 如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:4:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"MQ 有哪些常见问题？如何解决这些问题？ MQ 的常见问题有： 消息的顺序问题 消息的重复问题 消息的顺序问题 消息有序指的是可以按照消息的发送顺序来消费。 假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？ 解决方案： （1）保证生产者 - MQServer - 消费者是一对一对一的关系 缺陷： 并行度就会成为消息系统的瓶颈（吞吐量不够） 更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。 （2）通过合理的设计或者将问题分解来规避。 不关注乱序的应用实际大量存在 队列无序并不意味着消息无序 所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。 消息的重复问题 造成消息重复的根本原因是：网络不可达。 所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？ 消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:5:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"什么是RabbitMQ？ RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:6:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"rabbitmq 的使用场景 （1）服务间异步通信 （2）顺序消费 （3）定时任务 （4）请求削峰 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:7:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"RabbitMQ基本概念 Broker： 简单来说就是消息队列服务器实体 Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列 Queue： 消息队列载体，每个消息都会被投入到一个或多个队列 Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 Routing Key： 路由关键字，exchange根据这个关键字进行消息投递 VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。 Producer： 消息生产者，就是投递消息的程序 Consumer： 消息消费者，就是接受消息的程序 Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务 由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:8:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"RabbitMQ的工作模式 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"一.simple模式（即最简单的收发模式） 1.消息产生消息，将消息放入队列 2.消息的消费者(consumer) 监听 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失，这里可以设置成手动的ack,但如果设置成手动ack，处理完后要及时发送ack消息给队列，否则会造成内存溢出)。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:1","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"二.work工作模式(资源的竞争) 1.消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2同时监听同一个队列,消息被消费。C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用)。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:2","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"三.publish/subscribe发布订阅(共享资源) 1、每个消费者监听自己的队列； 2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:3","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"四.routing路由模式 1.消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息; 2.根据业务功能定义路由字符串 3.从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中。 4.业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误; ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:4","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"五.topic 主题模式(路由模式的一种) 1.星号井号代表通配符 2.星号代表多个单词,井号代表一个单词 3.路由功能添加模糊匹配 4.消息产生者产生消息,把消息交给交换机 5.交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费 （在我的理解看来就是routing查询的一种模糊匹配，就类似sql的模糊查询方式） ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:9:5","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证RabbitMQ消息的顺序性？ 拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:10:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息如何分发？ 若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:11:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息怎么路由？ 消息提供方-\u003e路由-\u003e一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）； 常用的交换器主要分为一下三种： fanout：如果交换器收到消息，将会广播到所有绑定的队列上 direct：如果路由键完全匹配，消息就被投递到相应的队列 topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:12:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"消息基于什么传输？ 由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:13:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？ 先说为什么会重复消费：正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除； 但是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。 针对以上问题，一个解决思路是：保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；保证消息等幂性； 比如：在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过； 假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:14:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？ 发送方确认模式 将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。 一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。 如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（notacknowledged，未确认）消息。 发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。 接收方确认机制 消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。 这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性； 下面罗列几种特殊情况 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重） 如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:15:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证RabbitMQ消息的可靠传输？ 消息不可靠的情况可能是消息丢失，劫持等原因； 丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息； 生产者丢失消息：从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息； transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降； confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后； rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了； 如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。 消息队列丢数据：消息持久化。 处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。 这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。 这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。 那么如何持久化呢？ 这里顺便说一下吧，其实也很容易，就下面两步 将queue的持久化标识durable设置为true,则代表是一个持久的队列 发送消息的时候将deliveryMode=2 这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据 消费者丢失消息：消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！ 消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息； 如果这时处理消息失败，就会丢失该消息； 解决方案：处理消息成功后，手动回复确认消息。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:16:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"为什么不应该对所有的 message 都使用持久化机制？ 首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多，message 的吞吐量可能有 10 倍的差距。 其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现“坑爹”问题。矛盾点在于，若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed ；若 message 设置了 persistent 属性，同时 queue 也设置了 durable 属性，那么当 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在这段时间内发送给该 queue 的 message 将被 blackholed 。 所以，是否要对 message 进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条/秒以上的消息吞吐量（单 RabbitMQ 服务器），则要么使用其他的方式来确保 message 的可靠 delivery ，要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。另外一种处理原则是：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:17:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何保证高可用的？RabbitMQ 的集群 RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。 单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式 普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。 镜像集群模式：这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:18:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？ 消息积压处理办法：临时紧急扩容： 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。 MQ中消息失效：假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。 mq消息队列块满了：如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:19:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"设计MQ思路 比如说这个消息队列系统，我们从以下几个角度来考虑一下： 首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -\u003e topic -\u003e partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？ 其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。 其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -\u003e leader \u0026 follower -\u003e broker 挂了重新选举 leader 即可对外服务。 能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。 本文转自 https://blog.csdn.net/ThinkWon/article/details/104588612，如有侵权，请联系删除。 ","date":"2021-06-04","objectID":"https://blog.gethin.online/rabbitmq-reprinted/:20:0","tags":[],"title":"[转载]消息中间件MQ与RabbitMQ面试题","uri":"https://blog.gethin.online/rabbitmq-reprinted/"},{"categories":["架构艺术"],"content":"1 软件架构概述 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"1.1 软件架构的定义 架构是对系统的抽象，由多个架构组成，任何软件都存在架构，元素与其行为的集合构成架构内容，架构具有“基础性”，架构隐含有“决策”。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"1.2 软件架构重要性 项目关系人之间交流平台； 早期设计决策； 在较高层面上实现软件复用； 架构对开发的指导与规范意义不容忽略。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"1.3 架构的模型 结构模型；框架模型；动态模型；过程模型；功能模型； 逻辑视图，开发视图，进程视图，物理视图，场景。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:1:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"2 架构需求与软件质量属性 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:2:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"2.1 软件质量属性 功能性；可靠性；易用性；效率；可维护性；可移植性； 1 运行期质量属性 性能；安全性；易用性；可伸缩性；互操作性；可靠性；持续可用性；鲁棒性； 2 开发期质量属性 易理解性；可扩展性；可重用性；可测试性；可维护性； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:2:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"2.2 六个质量属性与实现 质量属性：可用性；可修改性；性能；安全性；可测试性；易用性； 质量属性场景组件：刺激源；刺激；环境；制品；响应；响应度量； 1 可用性与其实现战术 可用性描述 可用性战术 错误检测：命令/响应；心跳；异常； 错误恢复 表决；主动冗余；被动冗余；备件；状态再同步；检查点/回滚； 错误预防 从服务中删除；事务；进程监视器； 2 可修改性与其实现战术 可修改性描述 可修改性战术 局部化修改；(维持语义的一致性；预期期望的变更；泛化该模块；限制可能的选择) 防止连锁反应；（信息隐藏；维持现有的接口；限制通信路径；仲裁者的使用） 推迟绑定时间；（运行时注册；配置文件；多态；构件更换；） 3 性能与其实现技术 性能描述 性能战术 资源消耗：闭锁时间； 资源需求：减少处理事件流所需的资源；减少所处理事件的数量；控制资源的使用； 资源管理：引入并发；维持数据或计算的多个副本；增加可用资源； 资源仲裁：先进先出；固定优先级调度；动态优先级调度；静态调度； 4 安全性与其实现技术 安全性描述 安全性战术 抵抗攻击：对用户进行身份验证；对用户进行授权；维护数据的机密性；维护完整性；限制暴露的信息；限制访问； 检测攻击 从攻击中恢复：恢复；识别攻击者； 5 可测试性与其实现战术 可测试性描述 可测试性战术 输入/输出：记录回放；将接口与现实分离；优化访问线路 内部监控 6 易用性与实现战术 易用性描述 易用性战术 运行时战术：任务的模型；用户的模型；系统的模型； 设计时战术 支持用户主动操作 常见的六个质量属性:可用性、可修改性、性能、安全性、可测试性、易用性。 质量属性场景是一种面向特定的质量属性的需求，由6部分组成：刺激源、刺激、环境、制品、响应、响应度量。 以《淘宝网》为例： (1)可用性: 场景：天猫双十一购物狂欢节 刺激源：海量用户 刺激：过多用户涌入抢购，系统出现崩溃的状态 制品：处理系统崩溃的处理器 环境：正常操作 响应：淘宝网监控系统记录，处理人员进行紧急处理 响应度量：短时间内恢复系统正常运行 （2）可修改性： 场景：系统进行升级 刺激源：开发人员 刺激：改变页面的形态，增加少许功能、 制品：升级完后的系统 环境：设计时 响应：修改了用户的操作页面，未产生副作用 响应度量：在15分钟左右完成升级更改 （3）性能： 场景：天猫双十一购物狂欢节 刺激源：用户 刺激：进行疯狂购物交易 制品：系统 环境：在正常操作下 响应：大量的交易同时被处理 响应度量：每个交易平均等待时间为3s (4)安全性: 场景：黑客想要盗窃用户信息 刺激源：黑客 刺激：试图通过某些手段窃取用户的信息 制品：淘宝用户信息 环境：用户不在线时 响应：对访问者进行身份上的验证 响应度量：淘宝安全系统阻止黑客访问用户信息 （5）可测试性： 场景：一个马上要执行的系统功能 刺激源：系统测试人员 刺激：对系统功能执行测试 制品：系统的某个功能 环境：功能要部署时 响应：提供对状态值的访问、提供所要计算的值，准备测试环境 响应度量：3个小时测试了85% （6）易用性： 场景：用户误将某物品移入到购物车 刺激源：用户 刺激：用户想要将物品移出 制品：系统 环境；系统运行时 响应：希望快速完成操作 响应度量：在1s内完成撤销操作 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:2:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3 软件架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.1 软件架构风格分类 数据流风格：批处理序列；管道\\过滤器； 调用/返回风格：主程序、子程序；面型对象风格；层次结构； 独立构件风格：进程通信；事件系统； 虚拟机风格：解释器；基于规则的系统； 仓库风格：数据库系统；超文本系统；黑板系统； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.2 数据流风格 批处理序列：批处理风格的每一步处理都是独立的，并且每一步都是顺序的。 管道和过滤器：每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。 好处：良好的隐蔽性；高内聚低耦合；简单合成；支持重用；性能简单；允许死锁分析；支持并行执行； 弊端：导致进程成为批处理；不适合处理交互式应用； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.3 调用/返回风格 主程序/子程序 面向对象风格：对负责维护其表示的完整性；对象的表示对其他对象而言是隐蔽的； 层次结构风格：支持基于抽象程度递增的系统设计；支持功能增强；支持重用； ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.4 独立构件风格 进程通信架构风格：构件是独立的过程，连接件是消息传递 事件系统风格：为软件重用提供了强大的支持；为还进系统带来了方便 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.5 虚拟机风格 解释器：包括完成解释工作的解释引擎，一个包含将被解释的代码储存区，一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的 规划为中心：基于规则的系统包括规则集、规则解释器，规则/数据选择器及工作内存 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:5","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"3.6 仓库风格 数据库系统、超文本系统、黑板风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:3:6","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4 层次系统架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.1 二层及三层C/S架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.2 B/S架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.3 MVC架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"4.4 MVP架构风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:4:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5 面向服务的架构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.1 SOA概述 5.1.1 服务基本结构 5.1.2 SOA设计原则 明确定义的接口、自包含和模块化、粗粒度、松耦合、互操作性。 5.1.3 服务构件和传统构件 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.2 SOA关键技术 UUDI（统一描述、发现集成） 数据模型、API、注册服务 WSDL（web服务描述语言） 服务实现定义：服务、端口 服务接口定义：绑定、端口类型、消息、类型 SOAP（简单对象访问协议） 封装；编码规则；RPC表示；绑定； SOAP消息：封装；SOAP头；SOAP体； REST（表述性状态转移） 网络上的所有事物都被抽象为资源 每个资源对应一个唯一资源标识 通过通用链接件接口对资源进行操作 对资源各种操作不会改变资源标识 所有操作都是无状态的 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.3 SOA的实现方法 Web Service 架构：服务提供者，服务请求者，服务注册者。 操作：发布，查找，绑定。 层次：底层传输层，服务通信协议层，服务描述层，服务层，业务流程层，服务注册层 服务注册表 服务注册，服务位置，服务绑定。 企业服务总线 功能： 支持异构环境中的服务，消息和基于事件的交互，并且具有适当的服务级别和可管理级别。 可以在几乎不更改代码的情况下，以一种无缝的非入侵方式使现有系统具有全新的服务接口，并能够在部署环境中支持任何标准 充当缓冲器的ESB于服务逻辑和分离，从而使不同的系统可以同时使用同一服务，不用在系统或数据变化时改动服务代码 ESB还提供服务代码和协议转换等功能，多种传输方式，发现和使用企业服务或界面提供基础设施。 提供可配置的消息转换翻译机制和基于消息内容的消息路由服务，传输消息到不同的目的地 提供安全和拥有者机制，保证消息和服务使用的认证，授权和完整性。 优势: 扩展的、基于标准的连接。 灵活的、服务导向的应用组合。 提高复用率。 减少市场的反应时间。 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"5.4 微服务 优势： 技术异构性，弹性，扩展，简单部署，与组织结构相匹配，可组合性，对可替代的优化。 挑战： 分布式系统的复杂度，运维成本，部署自动化，DEVOPS与组织结构，服务间的依赖测试，服务间的依赖管理 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:5:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"6 架构设计 演变交付生命周期 属性驱动设计法ADD 按架构组织开发团队 开发骨架系统 利用商业构件进行开发 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:6:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"7 软件架构文档化 架构文档的使用者 合理的编写规则 从读者角度编写文档，避免出现不必要的重复，避免歧义，使用标准结构，记录基本原理，文档保持更新但注意频率，针对目标的适宜性对文档进行评审 视图编档 视图概述，元素目录，上下文图，可变性指南，架构背景，术语表，其他信息。 跨视图文档 UML 软件架构重构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:7:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8 软件架构评估 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8.1 软件架构评估方法 基于调查问卷 基于场景 基于度量 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8.2 架构的权衡分析法ATAM 一个简洁的架构表述 表达清楚的业务目标 用场景集合捕获质量需求 架构决策到质量需求的映射 所确定的敏感点与权衡点的集合 有风险决策和无风险决策 风险主题集合 产生一些附属结果 产生一些无形的结果 步骤： ATAM方法表述 商业动机表述 架构表述 对架构方法进行分类 生成质量属性效用树 分析架构方法 集体讨论并确定场景优先级 分析架构方法 结果的表述 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"8.3 成本效益分析法CBAM 步骤： 整理场景，对场景进行求精，确定场景优先级，分配效用，策略-场景-响应，质量属性响应级别效用，各架构策略的总收益， ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:8:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9 构件及其复用 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9.1 商用构件标准规范 CORBA，J2EE，DNA 2000 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9.2 应用系统簇与构件系统 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"9.3 基于服用开发的组织结构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:9:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10 产品线及系统演化 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.1 复用与产品线 需求，架构设计，元素，建模与分析，测试，项目规划，过程、方法和工具，人员，样本系统，缺陷消除 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.2 基于产品线的架构 三个方面：确定变化点，支持变化点，对产品线架构的适宜性进行评估 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.3 产品线的开发模型 前瞻性产品线，反应性模型 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.4 特定领域软件架构 领域模型为需求定义率领域知识和领域词汇 软件界面的设计往往和领域模型关系密切 领域模型的合理性将严重影响软件系统的可扩展性 在分层架构指导下，领域模型精华后即成为业务层骨架 领域模型也是其数据模型的基础 领域模型是团队交流的基础 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"10.4 架构及系统演化 需求变动归类，制订架构演化计划，修改增加删除构件，更新构件的互相作用，构架组装和测试，技术评审，产生演化后的架构 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:10:5","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11 软件架构视图 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:0","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.1 软件视图分类 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:1","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.2 模块视图类型及其风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:2","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.3 C\u0026C视图类型及其风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:3","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.4 分配视图类型及其风格 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:4","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["架构艺术"],"content":"11.5 各视图类型间的映射关系 ","date":"2021-05-29","objectID":"https://blog.gethin.online/software-architecture-design/:11:5","tags":["架构"],"title":"软件架构设计","uri":"https://blog.gethin.online/software-architecture-design/"},{"categories":["概要"],"content":"自定义扩展 ","date":"2021-05-26","objectID":"https://blog.gethin.online/second-post/:1:0","tags":[],"title":"自定义扩展功能测试","uri":"https://blog.gethin.online/second-post/"},{"categories":["概要"],"content":"脑图测试 Root l1 l11 l12 l2 l12 l121 l122 l13 l3 l31 l313 l323 Test1 ABC 2021 function non0plural(number, name) { if (number == 0) { return \"\" } if (number == 1 || number == -1) { return number + \" \" +name } return number + \" \" + name + \"s\" } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2021-05-01\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 let years = 0 if (months Test 11 months ABC 2020 ","date":"2021-05-26","objectID":"https://blog.gethin.online/second-post/:1:1","tags":[],"title":"自定义扩展功能测试","uri":"https://blog.gethin.online/second-post/"},{"categories":["概要"],"content":"网站功能 文章加密 自定义域名 网站分析 脑图 时间轴 评论的优化 关于页面的优化 版权声明 运行时间 赞赏 网站流量统计 ","date":"2021-05-22","objectID":"https://blog.gethin.online/blog-todo/:1:0","tags":["待办事项"],"title":"博客代办事项","uri":"https://blog.gethin.online/blog-todo/"},{"categories":["概要"],"content":"编辑 新文章头部模板 ","date":"2021-05-22","objectID":"https://blog.gethin.online/blog-todo/:2:0","tags":["待办事项"],"title":"博客代办事项","uri":"https://blog.gethin.online/blog-todo/"},{"categories":["语言与平台"],"content":"自然拼读 ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:0","tags":null,"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["语言与平台"],"content":"元音 a am pam sam ad dad at cat rat an van man ran ap cap nap lap ab cab lab tab ag bag rag wag ack jack back sack pack ant pant Kant rant ang bang hang sang ank bank rank sank tank amp lamp camp ramp e ed Ted red en ten hen ell bell sell eg egg meg leg beg et jet get wet ess Bess less mess end bend mend send ent Kent bent sent went tent est best pest nest test west eck neck peck deck i id Sid kid ig pig dig ill Jill hill kill it sit fit hit pit im Tim Jim Kim dim in fin win tin pin ing ding ring king sing ink pink sink link ish fish dish wish ick pick kick sick tick Rick o ox fox box ot pot hot op hop top ob Bob job rob od nod pod rod og hog jog log om Tom mom ock rock sock lock u ug bug mug un run sun ut hut nut ub cub rub tub um gum hum mum uck duck luck tunk ump bump hump jump unch lunch munch punch ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:1","tags":null,"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["语言与平台"],"content":"辅音 辅音 bl black blink block blush cl clock clap click club class fl flag flex flip flop flush gl glass glad glob pl plan plane plant plot plum br Brad brick bring brush cr crab crack crash crop dr dress drip drop drum fr frog frank fresh Fred gr grass grab grand grid tr track trap trick truck sk skip skin skill sl sled slam slip slot sp spot spell spin spill st stand step stop stick sw swim swing swell ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:2","tags":null,"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["语言与平台"],"content":"元音组合 元音组合 ead read bead lead ean jean dean lean clean eat heat meat neat treat eal meal seal deal real oa goat toad oat coat goat boat moat oad road toad load oap soap oak soak oast toast roast coast boast oal goal oaf loaf ","date":"2021-05-16","objectID":"https://blog.gethin.online/phonics/:1:3","tags":null,"title":"phonics","uri":"https://blog.gethin.online/phonics/"},{"categories":["概要"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容。 此文章用于测试。 以下内容仅用于测试主题功能 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:0:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"LoveIt 的文章列表参考如下 hugoloveit https://hugoloveit.com/zh-cn/posts/ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:0:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"1 内容组织 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:1:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"2 前置参数 ---title:\"我的第一篇文章\"subtitle:\"\"# 文章副标题date:2020-03-04T15:58:26+08:00# 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置.lastmod:2020-03-04T15:58:26+08:00# 上次修改内容的日期时间.draft:true# 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染.author:\"\"# 文章作者.authorLink:\"\"# 文章作者的链接.description:\"\"# 文章内容的描述.license:\"\"# 这篇文章特殊的许可.images:[]# 页面图片, 用于 Open Graph 和 Twitter Cards.tags:[]# 文章的标签.categories:[]# 文章所属的类别.featuredImage:\"\"# 文章的特色图片.featuredImagePreview:\"\"# 用在主页预览的文章特色图片.hiddenFromHomePage:false# 如果设为 true, 这篇文章将不会显示在主页上.hiddenFromSearch:false# 如果设为 true, 这篇文章将不会显示在搜索结果中.twemoji:false# 如果设为 true, 这篇文章会使用 twemoji.lightgallery:true# 如果设为 true, 文章中的图片将可以按照画廊形式呈现.ruby:true# 如果设为 true, 这篇文章会使用 上标注释扩展语法.fraction:true# 如果设为 true, 这篇文章会使用 分数扩展语法.fontawesome:true# 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法.linkToMarkdown:true# 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接.rssFullText:false# 如果设为 true, 在 RSS 中将会显示全文内容.toc:enable:trueauto:truecode:copy:true# ...math:enable:true# ...mapbox:accessToken:\"\"# ...share:enable:true# ...comment:enable:true# ...library:css:# someCSS = \"some.css\"# 位于 \"assets/\"# 或者# someCSS = \"https://cdn.example.com/some.css\"js:# someJS = \"some.js\"# 位于 \"assets/\"# 或者# someJS = \"https://cdn.example.com/some.js\"seo:images:[]# ...## featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法.resources:- name:featured-imagesrc:featured-image.jpg- name:featured-image-previewsrc:featured-image-preview.jpg--- ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:2:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3 内容摘要 文章摘要预览文章摘要预览 \" 文章摘要预览 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.1 自动摘要拆分 网站设置 summaryLength ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.2 手动摘要拆分 添加 \u003c!--more--\u003e ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.3 前置参数摘要 前置参数 summary ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"3.4 使用文章描述作为摘要 前置参数 description ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:3:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"4 Markdown 基本语法 ignore ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:4:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5 Markdown 扩展语法 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.1 Emoji 支持 https://hugoloveit.com/zh-cn/emoji-support/ 😀,😄,😆,🤣,😅,😂 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.2 数学公式 $$ c = \\pm\\sqrt{a^2 + b^2} $$ $$ c = \\pm\\sqrt{a^2 + b^2} $$ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.3 行内公式 默认的行内公式分割符是 $/$ 和 \\\\(/\\\\) $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.4 mhchem $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.5 字符注音或者注释 [Hugo]^(一个开源的静态网站生成工具) Hugo一个开源的静态网站生成工具 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:5","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.6 分数 [99]/[100] 99/100 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:6","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.7 Font Awesome 真开心! :(far fa-grin-tears): 真开心! ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:7","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"5.8 转义字符 {?:}joy: :joy: ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:5:8","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6 内置 Shortcodes https://hugoloveit.com/zh-cn/theme-documentation-built-in-shortcodes/ ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.1 figure {{\u003c figure src=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.2 gist {{\u003c gist spf13 7896402 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.3 highlight {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.4 instagram instagram 的文档 {{\u003c instagram BWNjjyYFxVx hidecaption \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.5 param param 的文档 {{\u003c param description \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:5","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.6 ref 和 relref ref 和 relref 的文档 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:6","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.7 tweet tweet 的文档 {{\u003c tweet 877500564405444608 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:7","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.8 vimeo vimeo 的文档 {{\u003c vimeo 146022717 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:8","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"6.9 youtube youtube 的文档 {{\u003c youtube w7Ft2ymGmfc \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:6:9","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7 扩展shortcodes ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:0","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.1 style {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} This is a right-aligned paragraph. ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:1","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.2 link href [必需] content [可选] title [可选] rel [可选] class [可选] {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} Upstage ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:2","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.3 image src [必需] 图片的 URL. alt [可选] 图片无法显示时的替代文本, 默认值是 src 参数的值. caption [可选] 图片标题. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} lighthouse (image)\" lighthouse (image) ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:3","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.4 admonition 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] admonition 横幅的类型, 默认值是 note. title [可选] admonition 横幅的标题, 默认值是 type 参数的值. open [可选] 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:4","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.5 mermaid mermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 7.5.1 流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.2 时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.3 甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.4 类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.5 状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.6 Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph: options { \"nodeSpacing\": 100, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {{\u003c /mermaid \u003e}} 呈现的输出效果如下: 7.5.7 饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:5","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.5.8 echarts ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:6","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.6 mapbox Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:7","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.7 music music shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. 7.7.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"music/wind.mp3\" name=起风了 artist=买辣椒也用券 cover=\"images/wind.png\" \u003e}} 呈现的输出效果如下: 7.7.2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: 7.7.3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] [netease, tencent, kugou, xiami, baidu]音乐平台. type [必需] [song, playlist, album, search, artist]音乐类型. id [必需] 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: 7.7.4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme *[可选]*音乐播放器的主题色, 默认值是 #448aff. fixed *[可选]*是否开启固定模式, 默认值是 false. mini *[可选]*是否开启迷你模式, 默认值是 false. autoplay *[可选]*是否自动播放音乐, 默认值是 false. volume *[可选]*第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex *[可选]*是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选][all, one, none]音乐列表的循环模式, 默认值是 none. order [可选][list, random]音乐列表的播放顺序, 默认值是 list. list-folded *[可选]*初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height *[可选]*音乐列表的最大高度, 默认值是 340px. ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:8","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.8 bilibili {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:9","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.9 typeit typeit shortcode 基于 TypeIt 提供了打字动画. {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:10","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["概要"],"content":"7.10 script {{\u003c script \u003e}} console.log('Hello LoveIt!'); {{\u003c /script \u003e}} ","date":"2021-05-06","objectID":"https://blog.gethin.online/first-post/:7:11","tags":["测试"],"title":"一篇关于主题功能测试的文章","uri":"https://blog.gethin.online/first-post/"},{"categories":["语言与平台"],"content":" 声明：本文仅用做复习整理知识，大部分内容参考自： https://www.cnblogs.com/edisonchou/p/4787775.html https://zhuanlan.zhihu.com/p/38799766 .NET 本质论 .NET中所有类型的基类是什么 值类型和引用类型的区别 装箱和拆箱的原理 struct和class的区别，struct适用于哪些场合 C#中方法的参数传递有哪几种方式 浅复制和深复制的区别 .NET中栈和堆的差异 执行string abc=\"aaa\"+\"bbb\"+\"ccc\"共分配了多少内存 托管堆内存分配 简要说说.NET中GC的运行机制 GC机制中如何判断一个对象仍然在被使用（如何标记） GC中代（Generation）是什么，分为几代（如何移动） GC有什么问题 托管与非托管资源是什么 托管资源 非托管资源 Dispose和Finalize方法在何时被调用（非托管资源回收方法） .NET中的托管堆中是否可能出现内存泄露的现象 大对象的分配 不恰当地保存根引用 不正确的Finalize方法 .NET 本质论 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:0:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":".NET中所有类型的基类是什么 System.Object ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:1:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"值类型和引用类型的区别 所有继承自System.ValueType的类型是值类型，而其他类型都是引用类型。 常用的值类型包括：结构、枚举、整数型、浮点型、布尔型等等。 赋值时的区别 值类型的变量直接将获得一个真实的数据副本，而对引用类型的赋值仅仅是把对象的引用赋给变量，这样就可能导致多个变量引用到一个对象实例上。 内存分配的区别 引用类型的对象将会在堆上分配内存，而值类型的对象则会在堆栈上分配内存 继承结构的区别 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:2:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"装箱和拆箱的原理 装箱：CLR需要做额外的工作把堆栈上的值类型移动到堆上，这个操作就被称为装箱。 拆箱：装箱操作的反操作，把堆中的对象复制到堆栈中，并且返回其值。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:3:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"struct和class的区别，struct适用于哪些场合 struct（结构）是值类型，而class（类）是引用类型。 struct与class相比，不具备继承的特性 struct不能有无参数的构造方法（class默认就有），也不能为成员变量定义初始值。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:4:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"C#中方法的参数传递有哪几种方式 ref关键字：引用传递参数，需要在传递前初始化；（ref 要求参数在传入前被初始化） out关键字：引用传递参数，需要在返回前初始化；（out 要求参数在方法返回前被初始化） params关键字：允许方法在定义时不确定参数的数量。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:5:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"浅复制和深复制的区别 浅复制：复制一个对象的时候，仅仅复制原始对象中所有的非静态类型成员和所有的引用类型成员的引用。（新对象和原对象将共享所有引用类型成员的实际对象） 深复制：复制一个对象的时候，不仅复制所有非静态类型成员，还要复制所有引用类型成员的实际对象。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:6:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":".NET中栈和堆的差异 .NET 中的栈 堆栈用来存储值类型的对象和引用类型对象的引用（地址），其分配的是一块连续的地址，堆栈上的地址从高位向低位分配内存。 .NET 中的堆 托管堆的分配也是连续的（从低位到高位），但是堆中却存在着暂时不能被分配却已经无用的对象内存块。 当一个引用类型对象被初始时，会通过指向堆上可用空间的指针分配一块连续的内存，然后使堆栈上的引用指向堆上刚刚分配的这块内存块。 .NET中的非托管堆 非托管的堆需要程序员用指针手动地分配和释放内存，.NET中的GC和内存管理不适用于非托管堆。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:7:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"执行string abc=\"aaa\"+\"bbb\"+\"ccc\"共分配了多少内存 string是引用类型，其内存分配会遵照引用类型的规范。字符串具有不可变性。 string first = \"aaa\" + \"bbb\" + \"ccc\"; string second = \"aaabbbccc\"; int num = 1; string str = \"aaa\" + num.ToString(); Console.WriteLine(str); string str = \"aaa\"; str += \"bbb\"; str += \"ccc\"; Console.WriteLine(str) ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:8:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"托管堆内存分配 CLR在进程中分配一块保留地址控件-即托管堆 托管堆有分为多个区域-垃圾回收堆（GC Heap）和加载堆（Loader Heap）[High-Frequency Heap、Low-Frequency Heap和Stub Heap] Loader Heap最重要的信息就是元数据相关的信息 每个Type在Loader Heap上体现一个Method Table，而Method Table中则记录了存储的元数据信息 Loader Heap不受GC控制。 TypeHandle：类型句柄，指向对应实例的方法表，每个对象创建时都包含该附加成员，并占用4个字节的内存空间。 SyncBlockIndex：用于线程同步，每个对象创建时也包含该附加成员la。它指向一块呗称为Synchronization Block的内存块，用于管理对象同步，同样占用4个字节的内存空间。 NextObjPtr:由托管堆维护的一个指针，用于标识下一个新建对象分配时在托管堆中所处的位置。CLR初始化时，NextObjPtr位于托管堆的及地址。 首先，将声明一个引用类型变量aUser：（堆栈4字节） VIPUser aUser;; 它仅是一个引用（指针），保存在线程的堆栈上，占用4Byte的内存空间，将用于保存VIPUser对象的有效地址，其执行过程正是上文描述的在线程栈上的分配过程。此时aUser未指向任何有效的实例，因此被自行初始化为null，试图对aUser的任何操作将抛出NullReferenceException异常。 然后，通过new操作执行对象创建：（GC托管堆20字节） aUser = new VIPUser(); 如上文所言，该操作对应于执行newobj指令，其执行过程又可细分为以下几步： 1、CLR按照其继承层次进行搜索，计算类型及其所有父类的字段，该搜索将一直递归到System.Object类型，并返回字节总数，以本例而言类型VIPUser需要的字节总数为 15 Bytes，具体计算为：VIPUser类型本身字段isVip（bool型）为 1 Bytes；父类User类型的字段id（Int32型）为 4 Bytes，字段user保存了指向UserInfo型的引用，因此占 4 Bytes，而同时还要为UserInfo分配 6 Bytes字节的内存。 2、实例对象所占的字节总数还要加上对象附加成员所需的字节总数，其中附加成员包括TypeHandle和SyncBlockIndex，共计 8 Bytes（在32位CPU平台下）。因此，需要在托管堆上分配的字节总数为 23 Bytes，而堆上的内存块总是按照 4 Bytes的倍数进行分配，因此本例中将分配 24 Bytes的地址空间。 3、CLR在当前AppDomain对应的托管堆上搜索，找到一个未使用的 20 Bytes 的连续空间，并为其分配该内存地址。事实上，GC使用了非常高效的算法来满足该请求，NextObjPtr指针只需要向前推进 20 Bytes，并清零原NextObjPtr指针和当前NextObjPtr指针之间的字节，然后返回原NextObjPtr指针地址即可，该地址正是新创建对象的托管堆地址，也就是aUser引用指向的实例地址。而此时的NextObjPtr仍指向下一个新建对象的位置。注意，栈的分配是向低地址扩展，而堆的分配是向高地址扩展。 最后，调用对象构造器，进行对象初始化操作，完成创建过程。该构造过程，又可细分为以下几个环节： （a）构造VIPUser类型的Type对象，主要包括静态字段、方法表、实现的接口等，并将其分配在上文提到托管堆的Loader Heap上。 （b）初始化aUser的两个附加成员：TypeHandle 和 SyncBlockIndex。 （解析类型）将TypeHandle指针指向Loader Heap上的MethodTable，CLR将根据TypeHandle来定位具体的Type； （实现对象实例同步）将SyncBlockIndex指针指向Synchronization Block的内存块，用于在多线程环境下对实例对象的同步操作。 （c）调用VIPUser的构造器，进行实例字段的初始化。 实例初始化时，会首先向上递归执行父类初始化，直到完成System.Object类型的初始化，然后再返回执行子类的初始化，直到执行VIPUser类为止。 以本例而言，初始化过程为首先执行System.Object类，再执行User类，最后才是VIPUser类。最终，newobj分配的托管堆的内存地址，被传递给VIPUser的this参数，并将其引用传给栈上声明的aUser。(System.Object-\u003eUser-\u003eVIPUser-\u003e封装成aUser-\u003e地址丢给线程堆栈) ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:9:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"简要说说.NET中GC的运行机制 GC是垃圾回收（Garbage Collect）的缩写,.NET中的垃圾回收是指清理托管堆上不会再被使用的对象内存，并且移动仍在被使用的对象使它们紧靠托管堆的一边。 标记：找到所有不再被使用的对象：对象A和对象C，并标记为垃圾； 移动：移动仍在被使用的对象：对象B和对象D; 通常情况下，我们不需要手动干预垃圾回收的执行，不过CLR仍然提供了一个手动执行垃圾回收的方法：GC.Collect()。当我们需要在某一批对象不再使用并且及时释放内存的时候可以调用该方法来实现。But，垃圾回收的运行成本较高（涉及到了对象块的移动、遍历找到不再被使用的对象、很多状态变量的设置以及Finalize方法的调用等等），对性能影响也较大，因此我们在编写程序时，应该避免不必要的内存分配，也尽量减少或避免使用GC.Collect()来执行垃圾回收。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:10:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"GC机制中如何判断一个对象仍然在被使用（如何标记） Mark-Compact 标记压缩算法 在.NET中引用类型对象实例通常通过引用来访问，而GC判断堆中的对象是否仍然在被使用的依据也是引用。简单地说：当没有任何引用指向堆中的某个对象实例时，这个对象就被视为不再使用。 在GC执行垃圾回收时，会把引用分为以下两类： （1）根引用：往往指那些静态字段的引用，或者存活的局部变量的引用； （2）非根引用：指那些不属于根引用的引用，往往是对象实例中的字段。 垃圾回收时，GC从所有仍在被使用的根引用出发遍历所有的对象实例，那些不能被遍历到的对象将被视为不再被使用而进行回收。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:11:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"GC中代（Generation）是什么，分为几代（如何移动） GC会把所有托管堆内的对象按照其已经不再被使用的可能性分为三类，并且从最有可能不被使用的类别开始扫描，.NET对这样的分类类别有一个称呼：代（Generation）。 第0代，新近分配在堆上的对象，从来没有被垃圾收集过。任何一个新对象，当它第一次被分配在托管堆上时，就是第0代。 第1代，经历过一次垃圾回收后，依然保留在堆上的对象。 第2代，经历过两次或以上垃圾回收后，依然保留在堆上的对象。如果第2代对象在进行完垃圾回收后空间仍然不够用，则会抛出OutOfMemoryException异常。 并不是每次垃圾回收都会同时回收3个代的所有对象，越小的代拥有着越多被释放的机会。 CLR对于代的基本算法是：每执行N次0代的回收，才会执行一次1代的回收，而每执行N次1代的回收，才会执行一次2代的回收。 根据.NET的垃圾回收机制，0代、1代和2代的初始分配空间分别为256KB、2M和10M。 一个对象实例存活的时间越长，那么它就具有更大的机率去存活更长的时间。 因为一次GC回收之后仍然被使用的对象会被移动到更高的代上，因此我们需要避免保留已经不再被使用的对象引用，将对象的引用置为null是告诉.NET该对象不需要再使用的最直接的方法。 在前面我们提到Finalize方法会大幅影响性能，通过结合对代的理解，我们可以知道：在带有Finalize方法的对象被回收时，该对象会被视为正在被使用从而被留在托管堆中，且至少要等一个GC循环才能被释放（为什么是至少一个？因为这取决于执行Finalize方法的线程的执行速度）。很明显，需要执行Finalize方法的那些对象实例，被真正释放时最乐观的情况下也已经位于1代的位置上了，而如果它们是在1代上才开始释放或者执行Finalize方法的线程运行得慢了一点，那该对象就在第2代上才被释放，相对于0代，这样的对象实例在堆中存留的时间将长很多。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:12:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"GC有什么问题 首先，GC并不是能释放所有的资源。它不能自动释放非托管资源。 第二，GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。 GC并不是实时性的，这会造成系统性能上的瓶颈和不确定性。所以有了IDisposable接口，IDisposable接口定义了Dispose方法，这个方法用来供程序员显式调用以释放非托管资源。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:13:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"托管与非托管资源是什么 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:14:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"托管资源 .NET中的所有类型都是（直接或间接）从System.Object类型派生的。.NET中超过80%的资源都是托管资源。 CTS中的类型被分成两大类——引用类型（reference type，又叫托管类型[managed type]），分配在内存堆上；值类型（value type），分配在堆栈上。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:14:1","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"非托管资源 ApplicationContext, Brush, Component, ComponentDesigner, Container, Context, Cursor, FileStream, Font, Icon, Image, Matrix, Object, OdbcDataReader, OleDBDataReader, Pen, Regex, Socket, StreamWriter, Timer, Tooltip, 文件句柄, GDI资源, 数据库连接等等资源。可能在使用的时候很多都没有注意到！ ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:14:2","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"Dispose和Finalize方法在何时被调用（非托管资源回收方法） Dispose方法 我们会在Dispose方法中实现一些托管对象和非托管对象的释放以及业绩业务逻辑的结束工作等等。 But，即使我们实现了Dispose方法，也不能得到任何有关释放的保证，Dispose方法的调用依赖于类型的使用者，当类型被不恰当地使用，Dispose方法将不会被调用,我们一般会借助using等语法来帮助Dispose方法被正确调用。 Finalize方法 Finalize在GC执行垃圾回收时被调用 ①当每个包含Finalize方法的类型的实例对象被分配时，.NET会在一张特定的表结构中添加一个引用并且指向这个实例对象，暂且称该表为“带析构方法的对象表”； ②当GC执行并且检测到一个不被使用的对象时，需要进一步检查“带析构方法的对象表”来查询该对象类型是否含有Finalize方法，如果没有则将该对象视为垃圾，如果存在则将该对象的引用移动到另外一张表，暂且称其为“待析构的对象表”，并且该对象实例仍然被视为在被使用。 ③CLR将有一个单独的线程负责处理“待析构的对象表”，其执行方法内部就是依次通过调用其中每个对象的Finalize方法，然后删除引用，这时托管堆中的对象实例就被视为不再被使用。 ④下一个GC执行时，将释放已经被调用Finalize方法的那些对象实例。 结合使用Dispose和Finalize方法：标准Dispose模式 Finalize方法由于有CLR保证调用，因此比Dispose方法更加安全（这里的安全是相对的，Dispose需要类型使用者的及时调用），但在性能方面Finalize方法却要差很多。因此，我们在类型设计时一般都会使用标准Dispose模式：Finalize方法作为Dispose方法的后备，只有在使用者没有调用Dispose方法的情况下，Finalize方法才被视为需要执行。这一模式保证了对象能够被高效和安全地释放，已经被广泛使用。 标准dispose模式模板 public class BaseTemplate : IDisposable { // 标记对象是否已经被释放 private bool isDisposed = false; // Finalize方法 ~BaseTemplate() { Dispose(false); } // 实现IDisposable接口的Dispose方法 public void Dispose() { Dispose(true); // 告诉GC此对象的Finalize方法不再需要被调用 GC.SuppressFinalize(this); } // 虚方法的Dispose方法做实际的析构工作 protected virtual void Dispose(bool isDisposing) { // 当对象已经被析构，则不必再继续执行 if(isDisposed) { return; } if(isDisposing) { // Step1:在这里释放托管资源 } // Step2:在这里释放非托管资源 // Step3:最后标记对象已被释放 isDisposed = true; } public void MethodA() { if(isDisposed) { throw new ObjectDisposedException(\"对象已经释放\"); } // Put the logic code of MethodA } public void MethodB() { if (isDisposed) { throw new ObjectDisposedException(\"对象已经释放\"); } // Put the logic code of MethodB } } public sealed class SubTemplate : BaseTemplate { // 标记子类对象是否已经被释放 private bool disposed = false; protected override void Dispose(bool isDisposing) { // 验证是否已被释放，确保只被释放一次 if(disposed) { return; } if(isDisposing) { // Step1:在这里释放托管的并且在这个子类型中申明的资源 } // Step2:在这里释放非托管的并且这个子类型中申明的资源 // Step3:调用父类的Dispose方法来释放父类中的资源 base.Dispose(isDisposing); // Step4:设置子类的释放标识 disposed = true; } } 真正做释放工作的只是受保护的虚方法Dispose，它接收一个bool参数，主要用于区分调用者是类型的使用者还是.NET的GC机制。两者的区别在于通过Finalize方法释放资源时不能再释放或使用对象中的托管资源，这是因为这时的对象已经处于不被使用的状态，很有可能其中的托管资源已经被释放掉了。在Dispose方法中GC.SuppressFinalize(this)告诉GC此对象在被回收时不需要调用Finalize方法，这一句是改善性能的关键，记住实现Dispose方法的本质目的就在于避免所有释放工作在Finalize方法中进行。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:15:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":".NET中的托管堆中是否可能出现内存泄露的现象 首先，必须明确一点：即使在拥有垃圾回收机制的.NET托管堆上，仍然是有可能发生内存泄露现象的。 其次，什么是内存泄露？内存泄露是指内存空间上产生了不再被实际使用却又不能被分配的内存空间，其意义很广泛，像内存碎片、不彻底的对象释放等都属于内存泄露现象。内存泄露将导致主机的内存随着程序的运行而逐渐减少，无论其表现形式怎样，它的危害是很大的，因此我们需要努力地避免。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:0","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"大对象的分配 NET中所有的大对象（这里主要是指对象的大小超过指定数值[85000字节]）将分配在托管堆内一个特殊的区域内，暂且将其称为“大对象堆”（这也算是CLR对于GC的一个优化策略）。大对象堆中最重要的一个特点就是：没有代级的概念，所有对象都被视为第2代。在回收大对象堆内的对象时，其他的大对象不会被移动，这是考虑到大规模地移动对象需要耗费过多的资源。这样，在程序过多地分配和释放大对象之后，就会产生很多内存碎片。 随着对象的分配和释放不断进行，在不进行对象移动的大对象堆内，将不可避免地产生小的内存碎片。我们所需要做的就是尽量减少大对象的分配次数，尤其是那些作为局部变量的，将被大规模分配和释放的大对象，典型的例子就是String类型。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:1","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"不恰当地保存根引用 最简单的一个错误例子就是不恰当地把一个对象申明为公共静态变量，一个公共的静态变量将一直被GC视为一个在使用的根引用。更糟糕的是：当这个对象内部还包含更多的对象引用时，这些对象同样不会被释放。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:2","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["语言与平台"],"content":"不正确的Finalize方法 不正确的Finalize方法将导致Finalize方法不能被正确执行。如果系统中所有的Finalize方法不能被正确执行，包含它们的对象也只能驻留在托管堆内不能被释放，这样的情况将会导致严重的后果。 Finalize方法应该只致力于快速而简单地释放非托管资源，并且尽可能快地返回。相反，不正确的Finalize方法则可能包含： 1. 没有保护地写文件日志； 2. 访问数据库； 3. 访问网络； 4. 把当前对象赋给某个存活的引用； 例如，当Finalize方法试图访问文件系统、数据库或者网络时，将会有资源争用和等待的潜在危险。试想一个不断尝试访问离线数据库的Finalize方法，将会在长时间内不会返回，这不仅影响了对象的释放，也使得排在Finalize方法队列中的所有后续对象得不到释放，这个连锁反应将会导致很快地造成内存耗尽。此外，如果在Finalize方法中把对象自身又赋给了另外一个存活的引用，这时对象内的一部分资源已经被释放掉了，而另外一部分还没有，当这样一个对象被激活后，将导致不可预知的后果。 ","date":"2021-04-26","objectID":"https://blog.gethin.online/dotnet-essentialism/:16:3","tags":null,"title":".NET 本质论","uri":"https://blog.gethin.online/dotnet-essentialism/"},{"categories":["数据与算法"],"content":" 这个篇文章主要是算法学习大纲。 主要参考 https://github.com/youngyangyang04/leetcode-master 的学习路线，标号||均为leetcode题号。 算法 数组 二分查找 搜索插入位置|35| 双指针 移除元素|27| 滑动窗口 长度最小的子数组|209| 链表 链表的理论 链表的种类 链表的存储方式 链表操作 数组和链表在不同场景下的性能分析 链表的经典题目 虚拟头节点(哨兵节点) 链表的基本操作 反转链表 环形链表 哈希表 哈希表介绍 哈希函数 哈希碰撞 常见的三种哈希结构 数组作为哈希表 set作为哈希表 map作为哈希表 字符串 什么是字符串 要不要使用库函数 双指针法、反转系列 KMP 栈和队列 栈与队列的理论基础 栈经典题目 栈在系统中的应用 括号匹配问题 字符串去重问题 逆波兰表达式问题 队列的经典题目 滑动窗口最大值问题 求前 K 个高频元素 二叉树 二叉树的遍历方式 前序遍历|144| 中序遍历|145| 后序遍历|94| 层级遍历|102| 二叉树的属性 对称二叉树|101| 二叉树最大深度|104| 二叉树最小深度|111| 完全二叉树的节点个数|222| 平衡二叉树|110| 二叉树的所有路径|157| 左叶子之和|404| 找树左下角的值|513| 路径总和|112| 二叉树的修改与构造 翻转二叉树|226| 从中序与后续遍历序列构造二叉树|106| 最大二叉树|654| 合并二叉树|617| 求二叉搜索树的属性 二叉搜索树中的搜索|700| 验证二叉搜索树|98| 二叉搜索树的最小绝对差|530| 二叉搜索树中的众数|501| 把二叉搜索树转换为累加树|538| 二叉树公共祖先问题 二叉树的最近公共祖先|236| 二叉搜索树的最近公共祖先|235| 二叉搜索树的修改和构造 二叉搜索树的插入操作|701| 删除二叉搜索树的节点|450| 修剪二叉搜索树|669| 将有序数组转换为二叉搜索树|108| 回溯算法 组合 组合|77| 电话号码的字母组合|17| 组合总和|39| 组合总和2|40| 组合总和3|216| 分割 分割回文串|131| 复原IP地址|93| 子集 子集|78| 子集2|90| 排列 全排列|46| 全排列2|47| 棋盘问题 N皇后|51| 解数独|37| 其他 递增子序列|491| 重新安排行程|332| 贪心算法 理论基础 简单题目 分发饼干|455| K次取反后最大化的数组和|1005| 柠檬水找零|860| 序列问题 摆动序列|376| 单调递增的数字|738| 股票问题 买卖股票的最佳时机|122| 买卖股票的最佳时机含手续费|714| 两个维度权衡问题 分发糖果|135| 根据身高重建队列|406| 区间问题 跳跃游戏|55| 跳跃游戏2|45| 用最少数量的箭引爆气球|452| 五重叠区间|435| 划分字母区间|763| 合并区间|56| 其他问题 最大子序和|53| 加油站|134| 监控二叉树|968| 动态规划 算法 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:0:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"数组 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:1:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二分查找 搜索插入位置|35| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:1:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"双指针 移除元素|27| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:1:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"滑动窗口 长度最小的子数组|209| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:1:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"链表 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:2:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"链表的理论 链表的种类 单链表、双链表、循环链表 链表的存储方式 数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 链表操作 添加、删除、查询 数组和链表在不同场景下的性能分析 插入删除的时间复杂度是O(1),查询的时间复杂度是O(n) ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:2:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"链表的经典题目 虚拟头节点(哨兵节点) 移除链表元素|203| 链表的基本操作 设计链表|707| 反转链表 反转链表|206| 环形链表 环形链表II|142| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:2:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"哈希表 哈希表 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"哈希表介绍 哈希表是根据关键码的值而直接进行访问的数据结构。 哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"哈希函数 通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把value映射为哈希表上的索引数字了。 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"哈希碰撞 拉链法、线性探测法。 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"常见的三种哈希结构 数组、set（集合）、map（映射） 数组作为哈希表 有效的字母异位词|242| 赎金信|383| set作为哈希表 两个数组的交集|349| map作为哈希表 两数之和|1| 三数之和|15| 四数之和|18| 四数相加II|454| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:3:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"字符串 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"什么是字符串 字符串是若干字符组成的有限序列，也可以理解为是一个字符数组 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"要不要使用库函数 反转字符串|344| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"双指针法、反转系列 反转字符串II|541| 剑指Offer 05.替换空格 翻转字符串里的单词|151| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"KMP 实现 strStr()|28| 重复的子字符串|459| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:4:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"栈和队列 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:5:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"栈与队列的理论基础 队列是先进先出，栈是先进后出 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:5:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"栈经典题目 栈在系统中的应用 简化路径|71| 括号匹配问题 有效的括号|20| 字符串去重问题 删除字符串中的所有相邻重复项|1047| 逆波兰表达式问题 逆波兰表达式求值|150| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:5:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"队列的经典题目 滑动窗口最大值问题 滑动窗口最大值|239| 求前 K 个高频元素 前 K 个高频元素|347| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:5:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树的遍历方式 前序遍历|144| 中序遍历|145| 后序遍历|94| 层级遍历|102| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树的属性 对称二叉树|101| 二叉树最大深度|104| 二叉树最小深度|111| 完全二叉树的节点个数|222| 平衡二叉树|110| 二叉树的所有路径|157| 左叶子之和|404| 找树左下角的值|513| 路径总和|112| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树的修改与构造 翻转二叉树|226| 从中序与后续遍历序列构造二叉树|106| 最大二叉树|654| 合并二叉树|617| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"求二叉搜索树的属性 二叉搜索树中的搜索|700| 验证二叉搜索树|98| 二叉搜索树的最小绝对差|530| 二叉搜索树中的众数|501| 把二叉搜索树转换为累加树|538| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉树公共祖先问题 二叉树的最近公共祖先|236| 二叉搜索树的最近公共祖先|235| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:5","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"二叉搜索树的修改和构造 二叉搜索树的插入操作|701| 删除二叉搜索树的节点|450| 修剪二叉搜索树|669| 将有序数组转换为二叉搜索树|108| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:6:6","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"回溯算法 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"组合 组合|77| 电话号码的字母组合|17| 组合总和|39| 组合总和2|40| 组合总和3|216| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"分割 分割回文串|131| 复原IP地址|93| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"子集 子集|78| 子集2|90| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"排列 全排列|46| 全排列2|47| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"棋盘问题 N皇后|51| 解数独|37| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:5","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"其他 递增子序列|491| 重新安排行程|332| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:7:6","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"贪心算法 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"理论基础 ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:1","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"简单题目 分发饼干|455| K次取反后最大化的数组和|1005| 柠檬水找零|860| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:2","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"序列问题 摆动序列|376| 单调递增的数字|738| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:3","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"股票问题 买卖股票的最佳时机|122| 买卖股票的最佳时机含手续费|714| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:4","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"两个维度权衡问题 分发糖果|135| 根据身高重建队列|406| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:5","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"区间问题 跳跃游戏|55| 跳跃游戏2|45| 用最少数量的箭引爆气球|452| 五重叠区间|435| 划分字母区间|763| 合并区间|56| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:6","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"其他问题 最大子序和|53| 加油站|134| 监控二叉树|968| ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:8:7","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["数据与算法"],"content":"动态规划 Written with StackEdit. ","date":"2021-03-08","objectID":"https://blog.gethin.online/algorthm/:9:0","tags":["算法"],"title":"算法","uri":"https://blog.gethin.online/algorthm/"},{"categories":["概要"],"content":" 个人技术蓝图 计算机基础 [the-basics-of-computer-science] 计算机的组成原理 [principles-of-computer-composition] 操作系统原理 [principle-operating-system] 编译原理 [principle-of-compiling] 数据库系统 [database-system] 计算机网络 [network-of-computer] TCP HTTP 语言与平台 [language-and-platform] C# \u0026 .NET 5 [chsarp-and-dotnet5] .NET 本质论 [dotnet-essentialism] C# 基础语法 [csharp-basic-syntax] C# 高级用法 [professional-csharp] 新一代的 .NET [new-generation-dotnet] Swift \u0026 IOS [swift-ios] Python [python] Python 基础语法 [python-basic-syntax] Python 高级语法 [professional-python] Python 的应用 [python-application] JS,ES,TS \u0026 Vue,React (Gatsby) [js-es-ts-vue-react] 前端框架 [front-end] JavaScript [js] 数据与算法[data-and-algorithmic] 数据结构 [data-structure] 常用算法 [algorithm] 重构 [refactoring] 软件工程 [software-engineering] 开发方法 [software-development-methodologies] 系统分析与设计 [system-analysis-and-design] 软件开发的生命周期 [software-development-lifecycle] 架构艺术 [architecture-art] 架构模式 [architecture-pattern] 设计模式 [design-pattern] 常用组件 [common-components] Redis [redis] RabbitMQ [rabbitmq] Elastic Search [elastic-search] 云上漫谈 [cloud-native] 基础架构篇 [cloud-infrastructure] 软件架构篇 [cloud-software-architecture] DEVOPS [devops] 个人技术蓝图 ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:0:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"计算机基础 [the-basics-of-computer-science] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"计算机的组成原理 [principles-of-computer-composition] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"操作系统原理 [principle-operating-system] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"编译原理 [principle-of-compiling] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"数据库系统 [database-system] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:4","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"计算机网络 [network-of-computer] TCP HTTP ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:1:5","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"语言与平台 [language-and-platform] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"C# \u0026 .NET 5 [chsarp-and-dotnet5] .NET 本质论 [dotnet-essentialism] dotnet-essentialism C# 基础语法 [csharp-basic-syntax] C# 高级用法 [professional-csharp] 新一代的 .NET [new-generation-dotnet] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"Swift \u0026 IOS [swift-ios] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"Python [python] Python 基础语法 [python-basic-syntax] python-learning-notes python-learning-intermediate-notes Python 高级语法 [professional-python] python-quick-grammar Python 的应用 [python-application] jupyter-notebook-shortcuts ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"JS,ES,TS \u0026 Vue,React (Gatsby) [js-es-ts-vue-react] 前端框架 [front-end] Gatsby JavaScript [js] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:2:4","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"数据与算法[data-and-algorithmic] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"数据结构 [data-structure] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"常用算法 [algorithm] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"重构 [refactoring] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:3:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"软件工程 [software-engineering] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"开发方法 [software-development-methodologies] software-development-methodologies ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"系统分析与设计 [system-analysis-and-design] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"软件开发的生命周期 [software-development-lifecycle] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:4:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"架构艺术 [architecture-art] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"架构模式 [architecture-pattern] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"设计模式 [design-pattern] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"常用组件 [common-components] Redis [redis] RabbitMQ [rabbitmq] Elastic Search [elastic-search] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:5:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"云上漫谈 [cloud-native] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:0","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"基础架构篇 [cloud-infrastructure] introduce-microservice-infrastructure-on-cloud how-to-setup-kubernetes-on-azure ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:1","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"软件架构篇 [cloud-software-architecture] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:2","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["概要"],"content":"DEVOPS [devops] ","date":"2021-02-18","objectID":"https://blog.gethin.online/blueprint/:6:3","tags":["蓝图"],"title":"个人技术蓝图","uri":"https://blog.gethin.online/blueprint/"},{"categories":["软件工程"],"content":" Software Development Methodologies ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:0:0","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"开发方法 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:0","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"软件的生命周期 可行性研究与计划-\u003e需求分析-\u003e概要设计-\u003e详细设计-\u003e实现-\u003e集成测试-\u003e确认测试-\u003e使用与维护 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:1","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"软件开发模型 瀑布模型 演化模型 螺旋模型 增量模型 构建组装模型 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:2","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"统一过程 UP的9个核心工作流 业务建模，需求，分析设计，实施，测试，部署，配置与变更管理，项目管理，环境 UP的生命周期 目标里程碑，架构里程碑，能力里程碑，发布里程碑 UP的特点 UP不但给出类迭代的生命周期，还给出了生命周期每一阶段的迭代指南 采用不同迭代方式的UP可以演变为演化模型或增量模型 迭代特点使得更容易控制软件开发的风险 UP本身并不属于敏捷 实际应用中可以根据具体问题对UP进行剪裁 架构师在UP中的活动 同需求人员和项目管理人员密切协作 细化软件架构 保持整个架构的概念完整性 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:3","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"敏捷方法 极限编程 XP是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方式。 在更短的周期内，更早的提供具体、持续的反馈信息 迭代的进行计划编制 依赖自动测试程序来监控开发进度，并及早捕获缺陷 依赖口头交流、测试和源程序进行沟通 倡导持续的、演化式的设计 依赖与开发团队内部的紧密协作 尽可能达到程序员短期利益和项目长期利益的平衡 四大价值观 沟通，简单，反馈，勇气，（尊重） 十二个最佳实践 计划游戏，小型发布，隐喻，简单设计，测试先行，重构，结对编程，集体代码所有制，持续集成，每周工作40小时，现场客户，编码标准 特性驱动开发 FDD也是一个迭代开发模型，FDD每一步都强调质量，不断的交付可运行的软件，并以很小的开发提供精准的项目进度报告和状态信息。 FDD角色定义 项目经理，首席架构设计师，开发经理，主程序员，程序员，领域专家 核心过程 开发整体对象模型、构造特征列表、计划特征开发、特征设计、特征构建 最佳实践 领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管 Scrum Scrum是一个用于开发和维护复杂产品的框架，是一个增量的、迭代的开发过程。 Scrum 的五个活动 产品待办事项列表梳理、Sprint计划会议、每日Scrum会议、Sprint评审会议、Sprint回顾会议 Scrum的5大价值观 承诺、专注、开放、尊重、勇气 水晶方法 Crystal 是发展一种提倡“机动性“的方法，包括共有的核心元素，每个都含有独特的角色，过程模式，工作产品和实践。 7大体系特征：经常交付，反思改进，渗透式交流，个人安全，焦点，与专家用户建立方便的联系，配有自动测试、配置管理和经常集成功能的技术环境 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:4","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"软件重用 软件重用 源代码重用，架构重用，应用框架重用，业务建模重用，文档及过程的重用，软构件重用，软件服务重用 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:5","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["软件工程"],"content":"基于架构的软件设计 ABSD方法于生命周期 ABSD：分解功能，通过选择架构风格来事先质量和业务需求，软件模版的使用 抽象功能需求，包括变化的需求和通用的需求 用例（实际功能需求） 抽象的质量和业务需求 架构选项 质量场景 约束 基于架构的软件开发模型(ABSDM) 架构需求 需求获取，标识构件（生成类图，对类分组，打包构件），需求评审 架构设计 提出软件架构模型，把已标识的构件映射到软件架构中，分析构件的互相作用，产生软件架构，设计评审 架构文档化 输出：架构需求规格说明，测试架构需求的质量设计说明 架构复审 架构实现 架构演化 需求变动归类，制定架构演化计划，修改、增加或删除构件，更新构件的互相作用，构件组装与测试，技术评审 ","date":"2021-02-08","objectID":"https://blog.gethin.online/software-development-methodologies/:1:6","tags":["开发方法"],"title":"开发方法","uri":"https://blog.gethin.online/software-development-methodologies/"},{"categories":["语言与平台"],"content":"Python Quick Grammar ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:0","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"1. 变量互换 a=1 b=2 a,b=b,a a,b (2, 1) ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:1","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"2. 连续赋值 a=b=c=50 a,b,c (50, 50, 50) ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:2","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"3. 自动解包 a,b,c=[1,2,3] a,b,c (1, 2, 3) a,*others=[1,2,3,4] print(a) print(*others) 1 2 3 4 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:3","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"4. 链式比较 a=10 if(5\u003ca\u003c15): print(a) 10 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:4","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"5. 重复列表 [5,2]*4 [5, 2, 5, 2, 5, 2, 5, 2] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:5","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"6. 重复字符串 \"hello\"*3 'hellohellohello' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:6","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"7. 三目运算 age = 30 slogon = \"牛逼\" if age == 30 else \"niubility\" print(slogon) 牛逼 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:7","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"8. 字典合并 a={\"a\":1} b={\"b\":2} {**a,**b} {'a': 1, 'b': 2} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:8","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"9. 字符串反转 s = \"i love python\" s[::-1] 'nohtyp evol i' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:9","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"10. 列表转字符串 s = [\"i\", \"love\", \"python\"] \" \". join(s) 'i love python' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:10","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"11. for else 语句 foo=[2,3,4,5] for i in foo: if i == 0: break else: print(\"未发现\") 未发现 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:11","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"12. 字典推导式 m = {x: x**2 for x in range(5)} m {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:12","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"13. 用Counter查找列表中出现最多的元素 content = [\"a\", \"b\", \"c\", \"a\", \"d\", \"c\", \"a\"] from collections import Counter c = Counter(content) c. most_common(1) [('a', 3)] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:13","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"14. 默认值字典 from collections import defaultdict d = defaultdict(list) d['a']. append(1) d['a'] [1] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:14","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"15. 赋值表达式 import re data = \"hello123world\" if match:=re. search(\"(\\d+)\", data): num = match. group(1) else: num=None num '123' ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:15","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"16. isinstance x=1 b=isinstance(x, (int, float)) b True ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:16","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"17. 用 http.server 共享文件 #python3 -m http. server ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:17","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"18. zip 函数实现字典键值对互换 lang = {\"python\":\". py\", \"java\":\". java\"} dict(zip(lang. values(), lang. keys())) {'. py': 'python', '. java': 'java'} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:18","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"19. 查找列表中出现次数最多的数字 test = [1, 2, 3, 4, 2, 2, 3, 1, 4, 4, 4, 5] max(set(test), key=test. count) 4 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:19","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"20. 使用 slots 节省内存 class MyClass(object): def __init__(self, name, identifier): self. name = name self. identifier = identifier self. set_up() print(sys. getsizeof(MyClass)) class MyClass(object): __slots__ = ['name', 'identifier'] def __init__(self, name, identifier): self. name = name self. identifier = identifier self. set_up() print(sys. getsizeof(MyClass)) 1064 896 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:20","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"21. 扩展列表 i = ['a','b','c'] i. extend(['e','f','g']) i ['a', 'b', 'c', 'e', 'f', 'g'] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:21","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"22. 列表负数索引 a = [ 1, 2, 3] a[-1] 3 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:22","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"23. 列表切片 a = [0,1,2,3,4,5,6,7,8,9] a[3:6] # 第3个到第6个之间的元素 a[:5] # 前5个元素 a[5:] # 后5个元素 a[::] # 所有元素（拷贝列表） a[::2] # 偶数项 a[1::2] # 奇数项 a[::-1] # 反转列表 [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:23","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"24. 二维数组变一维数组 import itertools a = [[1, 2], [3, 4], [5, 6]] i = itertools. chain(*a) list(i) [1, 2, 3, 4, 5, 6] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:24","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"25. 有索引的迭代 a = ['Merry', 'Christmas ', 'Day'] for i, x in enumerate(a): print ('{}: {}'. format(i, x)) 0: Merry 1: Christmas 2: Day ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:25","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"26. 列表推导式 le = [x*2 for x in range(10)] le # 每个数取平方 le = [x for x in range(10) if x%2 == 0] le # 获取偶数项 [0, 2, 4, 6, 8] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:26","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"27. 生成器表达式 ge = (x*2 for x in range(10)) print(ge) print(next(ge)) print(next(ge)) print(next(ge)) \u003cgenerator object \u003cgenexpr\u003e at 0x000001D693764190\u003e 0 2 4 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:27","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"28. 集合推导式 nums = {n**2 for n in range(10)} nums {0, 1, 4, 9, 16, 25, 36, 49, 64, 81} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:28","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"29. 判断key是否存在字典中 d = {\"1\":\"a\"} print('1' in d) print(d['1']) print(d. get(\"1\")) print(d. get(\"2\")) True a a None ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:29","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"30. 装饰器 from functools import wraps def tags(tag_name): def tags_decorator(func): @wraps(func) def func_wrapper(name): return \"\u003c{0}\u003e{1}\u003c/{0}\u003e\". format(tag_name, func(name)) return func_wrapper return tags_decorator @tags(\"p\") def get_text(name): \"\"\"returns some text\"\"\" return \"Hello \" + name print(get_text(\"Python\")) \u003cp\u003eHello Python\u003c/p\u003e ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:30","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"31. 字典子集 def sub_dicts(d, keys): return {k:v for k, v in d. items() if k in keys} sub_dicts({1:\"a\", 2:\"b\", 3:\"c\"}, [1,2]) {1: 'a', 2: 'b'} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:31","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"32. 反转字典 d = {'a': 1, 'b': 2, 'c': 3, 'd': 4} zip(d. values(), d. keys()) z = zip(d. values(), d. keys()) dict(z) {1: 'a', 2: 'b', 3: 'c', 4: 'd'} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:32","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"33. 具名元组 from collections import namedtuple Point = namedtuple(\"Point\", \"x,y\") p = Point(x=1, y=2) print(p. x) print(p[0]) print(p. y) print(p[1]) 1 1 2 2 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:33","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"34. 设置字典默认值 d = dict() if 'a' not in d: d['a'] = [] d['a']. append(1) d d. setdefault('b',[]). append(2) d {'a': [1], 'b': [2]} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:34","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"35. 有序字典 from collections import OrderedDict m = OrderedDict((str(x), x) for x in range(10)) m. keys() # key 按照插入的顺序排列 odict_keys(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']) ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:35","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"36. 列表中最大最小的前n个数 import heapq a = [51, 95, 14, 65, 86, 35, 85, 32, 8, 98] heapq. nlargest(5,a) heapq. nsmallest(5,a) [8, 14, 32, 35, 51] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:36","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"37. 打开文件 import os with open('foo. txt', 'w') as f: f. write(\"hello\") os. remove(\"foo. txt\") ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:37","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"38. 两个列表组合成字典 list_1 = [\"One\",\"Two\",\"Three\"] list_2 = [1,2,3] dictionary = dict(zip(list_1, list_2)) print(dictionary) {'One': 1, 'Two': 2, 'Three': 3} ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:38","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"39. 去除列表中重复元素 my_list = [1,4,1,8,2,8,4,5] my_list = list(set(my_list)) print(my_list) [1, 2, 4, 5, 8] ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:39","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"40. 打印日历 import calendar print(calendar. month(2021, 1)) January 2021 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:40","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":"41. 匿名函数 add = lambda a,b:a+b add(1,2) 3 ","date":"2021-02-01","objectID":"https://blog.gethin.online/python-quick-grammar/:1:41","tags":["python"],"title":"PYTHON 技巧","uri":"https://blog.gethin.online/python-quick-grammar/"},{"categories":["语言与平台"],"content":" Python Learning Notes - Intermediate ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:0:0","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4. 序列 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:0","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.1 序列 1 索引 abc=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] print(abc[1]) 2 切片（slicing） sname[start🔚step] print(abc[1:5]) print(abc[0:5:2]) 3 序列相加 bcd=[\"b\",\"c\",\"d\"] print(abc+bcd) 4 乘法 print(bcd*5) 5 检查元素 print(\"b\" in bcd) 6 计算序列长度、最大值和最小值 print(len(abc)) print(max(abc)) print(min(abc)) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:1","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.2 列表(list) 1 创建和删除 lisa=[1,2,3,4,5,6] lisb=['a',\"b\",[\"a\",'''bcd''']] lise=[] lisr=list(range(1,10,2)) print(lisa,lisb,lise,lisr) del lisr print(lisr) 2 遍历 for i in lisa: print(i) for i,item in enumerate(lisb): print(i,item) 3 添加、修改和删除列表元素 lisa.append(7) print(lisa) lisa[5] = 7 print(lisa) del lisa[5] print(lisa) 4 统计 c=lisa.count(1) print(c) i=lisa.index(1) print(i) s=sum(lisa) print(s) lisa.sort(reverse=True) print(lisa) sort=sorted(lisa) print(sort) k=[x for x in lisa if x\u003e3] print(k) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:2","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.3 元组（tuple） 1 元组的基本操作 t=('a',12,(\"abc\",\"b\"),[\"ggg\",99]) print(t) t=tuple(range(10,20,2)) print(t) t=('人生苦短',28,'我用PYTHON',[123,456,789]) print(t[0]) print(t[:3]) 2 元组推导式 import random randomnumber=(random.randint(10,100) for i in range(10)) print(randomnumber) randomnumber=tuple(randomnumber) print(randomnumber) a=(1,2,3) print(a) a=(2,3,4) print(a) a=a+(5,6) print(a) 遍历后原生成器对象已经不存在了，如下： number=(i for i in range(3)) print(number.__next__()) print(number.__next__()) number=tuple(number) print(number) 元组和列表区别 列表属于可变序列，它的元素可以随时修改或者删除，而元组属于不可变序列，其中元素不可修改，除非整体替换 列表可以使用append(),extend(),insert(),remove()和pop()等方法实现添加和修改列表元素，而元组则没有这几个方法，因为不能向原则添加和修改元素，同样也不能删除元素 列表可以使用切片访问和修改列表中元素，元素也支持切片，但是它只支持通过切片访问元素中的元素，不支持修改 元组比列表的访问和处理速度快，所以如果只需要对其中元素进行访问，而不进行任何修改，建议使用元组而不使用列表 列表不能座位字典的键，而元组则可以 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:3","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"4.4 字典(dictionary) 字典的特性： 通过键而不是通过索引来读取 字典式任意对象的无序集合 字典是可变的，并且可以任意嵌套 字典中的键必须是唯一 字典中的键必须不可变 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:1:4","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5. 字符串和正则表达式 ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:0","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5.1 字串常用操作 # 拼接 a='abc'+'bc'+'CD'+str(123)+'@' print(a) # 计算长度 print(len(a)) # 截取字符串【string[start🔚step]】 sub=a[2:7:2] print(sub) # 分割字符串【str.splite(sep,maxsplit)】 li=a.split('b') print(li) li=a.split('b',1) print(li) # 检索字符串count find index startswith endswith print(a.count('b')) print(a.find('b')) print(a.index('b')) print(a.startswith('abc')) print(a.endswith('123')) # 字母大小写 print(a.upper()) print(a.lower()) # 去特殊字符 print(a.strip('@')) 格式化字符串 常用格式化字符 s 字符串（采用str() 显示） r 字符串（采用repr() 显示） c 单个字符串 o 八进制整数 d 十进制整数 e 指数 x 十六进制整数 f 浮点数 % 字符串% template= '{:0\u003e9s}\\tname:{:s}\\ttitle:sr.{:s}' print(template.format('1','hello','wang')) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:1","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5.2 正则表达式基础 行定位符 ^tm$ 元字符 \\w\\s\\d\\b 限定符 ? + * {n} {n,} {n,m} 字符类 abc 排除字符 ^abc 选择字符 | 转义字符 \\ 分组 () ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:2","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["语言与平台"],"content":"5.3 使用re模块实现正则表达式 # re.match(pattern.string,[flags]) # re.search(pattern,string,[flags]) # re.findall(pattern,string,[flags]) # re.sub(pattern,repl.string,count,flags) # re.split(pattern,string,[maxsplite],[flags]) ","date":"2020-09-16","objectID":"https://blog.gethin.online/python-learning-intermediate-notes/:2:3","tags":["python"],"title":"PYTHON 学习笔记(Intermediate)","uri":"https://blog.gethin.online/python-learning-intermediate-notes/"},{"categories":["软件工程"],"content":" Scrum Learning Notes Scrum 学习笔记 理论与价值观 敏捷宣言 5 个价值观 8 大价值观 12 个原则 3 个角色 3 个工件 5 个活动 估算与计划 计划失败的原因 估算大小的策略 为价值制定计划 确定优先级因素 确定渴望度优先级 分解用户故事 用户故事的六个特性 - INVEST 确定经济优先级 会议与实战 Product Bocklog Refinement 框架 Skeleton 备忘录 Cheat Sheet Sprint Planning PART I PART II Spint Review 框架 Sprint Retrospective 发布计划策略 迭代计划策略 估算速度策略 有效原因与指导原则 敏捷计划有效原因 敏捷估算和计划的 12 条指导原则 Scrum 学习笔记 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:0:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"理论与价值观 在有限的时间（TimeBox）里 团队一起合作（Work Together），我们彼此信任（Trust）并发挥自我最大的能力和优势（Do The Best），持续不断的交付（CI，CD）可用、有价值（Usable，Valuable）的软件，赢得客户的满意。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"敏捷宣言 个体和互动 高于 流程和工具 （合作，信赖） 工作的软件 高于 详尽的文档 （产品增量） 客户合作 高于 合同谈判（同一组织） 响应变化 高于 遵循计划（公开，透明） ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"5 个价值观 专注 - 由于我们在一段时间内只能专注于少数几件事情，所以我们可以很好的合作并获得优质的产出，我们能够更快的交付有价值的事项。 公开 - 在团队合作中大家都会表达我们做的如何，以及遇到的障碍。我们发现将担忧说出来是一件好事，因为只有这样才能让这些担忧及时得到解决。 尊重 - 因为我们在一起工作，分享和成功失败，这有助培养并加深互相之间的尊重，并帮助彼此成为值得尊重的人。 承诺 - 由于对自己的命运有更大的掌控，我们会有更坚定的信念去获得成功。 勇气 - 因为我们不是单打独斗，我们能够感受到支持，而且掌握更多资源。这一切赋予我们勇气去迎接更大的挑战。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"8 大价值观 诚实，开放，勇气，尊重，专注，信任，授权，合作 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:3","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"12 个原则 我们最重要的目标，是通过及早和持续不断地交付有价值的软件使客户满意。 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。 业务人员和开发人员必须相互合作，项目中的每一天都不例外。 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。 可工作的软件是进度的首要度量标准。 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。(稳定的速度) 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。 以简洁为本，它是极力减少不必要工作量的艺术。 最好的架构、需求和设计出自自组织团队。 团队定期地反思如何能提高成效，并依此调整自身的行为表现。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:4","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"3 个角色 PO Scurm Master Team ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:5","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"3 个工件 Product Backlog Sprint Backlog Burndown chart ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:6","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"5 个活动 产品待办事项列表梳理 Sprint 计划 每⽇ Scrum 站会 Sprint 评审 Sprint 回顾 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:1:7","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"估算与计划 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"计划失败的原因 基于活动而不是基于特性 活动不会提前完成 延误沿着计划表向下传递 活动不是互相独立的 基于活动的计划分散了我们对特性的专注，而特性才是衡量客户价值的单元。解决策略：使用 FDD 策略。 多任务处理导致更多的延迟 - 每个人都达到 100%负荷，这和让高速公路保持 100%负荷结果相同，谁都无法取得任何进展。解决策略：专注 feature，合理估算 不按优先级开发特性 - 传统计划假设所有任务都会完成，但这样会造成如果无法完成会舍弃一些特性，而这些特性可能会比交付的更有价值。解决策略：明确优先级。 忽视不确定性 - 最明显的效果就是造成 delay。 解决策略：迭代。 把估算当作承诺 - 估算只是一个可能性，而对一个可能性做出承诺是不可能的。解决策略：对特性承诺而非时间。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"估算大小的策略 故事点的优势 故事点有助于驱动跨功能行为 故事点估算不会过期 故事点是纯粹对大小进行度量 故事点估算通常更快 我的理想人天不等于你的理想人天 理想人天 理想人天在团队以外更容易解释 理想人天估算更容易开始 理想人天便于预测速度 使用模糊的故事点产生的不舒服感觉是非常短暂的。 公司让实际人天接近于理想人天的压力会带来负面影响。 使用故事点估算更有说服力。 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"为价值制定计划 确定优先级因素 价值 估算经济回报是一件很困难的工作，常常需要一种替代方案对价值估算 ** 确定渴望度的优先级 成本 确定经济优先级 新知识 关于产品的知识 关于技术的知识 风险 进度风险 成本风险 功能风险 确定渴望度优先级 客户满意度的 Kano 模型 作为阈值的特性 线性特性 兴奋点和惊喜点 Kano 模型 5 个度量点: 我希望这样; 我预期就是这样; 我没有意见; 我可以忍受这样; 我不希望这样; ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:3","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"分解用户故事 用户故事的六个特性 - INVEST 独立性 Independent、可协商性 Negotiable、有价值 Valuable、可以估算 Estimable、短小 Small、可测试性 Testable 何时分解用户故事 用户故事太大，不能放进单次迭代的时候 大型故事分解有助于作出更准确的估算 按照数据边界分解 按照用户故事所支持数据的边界来分解大型用户故事 按照操作边界分解 CURD 去除横切考虑 例如：日志 忽略满足性能限制 考虑把功能性和非功能性需求隔离到不同的用户故事，从而分解大型用户故事 分解具有混合优先级的用户故事 如果大型用户故事中的小故事具有不同的优先级，则可以对它们进行分解 不要把故事分解成任务 不要把大型用户分解成任务，而是寻找一种方法来让一颗曳光弹穿过整个故事 避免相关变化的诱惑 避免在具有适当大小的特性中增加相关变化而把事情弄糟，除非这些变化具有相同的优先级 组合用户故事 对于2周一次的迭代周期工作的团队来说，合适的做法是把特性分解成 2-5 天的用户故事 组合小故事 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:4","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"确定经济优先级 收入来源 新收入 增量收入 促进现有客户购买更多许可 包含了可以独立出售的可选，附加模块 包含允许提高收费的功能 促进对咨询服务的使用 留存收入 如果不开发项目或主题，公司会损失的收入 操作效率 需要或者在公司成长后需要很长时间的事 部门之间更好的集成和交流 减少人员更替 对新人缩短培训时间 任何对时间敏感的过程 综合多个过程 任何可以提高准确性和减少返工的工作 经济指标 1 金钱的时间价值 2 净现值 NPV 3 内部收益率 4 投资回收期 5 折现回收期 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:2:5","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"会议与实战 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Product Bocklog Refinement 框架 Skeleton 展示现阶段以及中期目标 展示并澄清 Product Backlog 团队估算 PBI PO 按照期望团队交付的顺序为 PBI 排序 分成小组协作对需求建模，切分以及确定验收条件 备忘录 Cheat Sheet 梳理之前是否与利益相关者一起评估确认远景、目标和 backlog 条目 团队和主要的利益相关者在场 会议由 ScurmMaster 或者 PO 引导 预留 sprint 总时间的 5%-10%梳理 backlog PO 把远景、目标和整个 backlog 分享给大家 技术风险是否被确认并创建响应的 spike Product Backlog 是一个有序列表 把所有的反馈、变更、缺陷记录到 Product Backlog 产品 Backlog 包括现景、近景和远景 团队一起对所有的条目估算 排列靠前的条目都有验收条件而且有具体实例 所有不确定的问题被记录下来等待会后继续调研 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Sprint Planning PART I 展示重要的 PBI 澄清 PBI 相关的问题 团队协作梳理新的 PBI 团队按照顺序尝试选择 PBI PART II 重新调整“完成的定义” 计算团队下个 Sprint 可用时间 团队一起讨论可能的实现方案 团队协作创建任务并估算 根据时间或速率向 PO 做出最终承诺 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Spint Review 框架 评估已经完成的 PBI 与承诺的 PBI 和 Sprint 目标 用讲故事的方式演示完成的功能 收集反馈 展示接下来要做的重要 PBI ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:3","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"Sprint Retrospective 安全感 How much will each person participate 发现 Big Picture 分析 Continue; Fix; Stop; 计划 Where dowe want to be? How do we get there from here? 收尾 How to ducument; How to execute; ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:4","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"发布计划策略 确定满意条件，（日期驱动，特性驱动） 估算用户故事， 选择迭代周期长度，（官方建议：2 周迭代，压力分摊，6x2+1） 估算速度，（速度策略） 确定用户故事的优先级， 选择用户故事和发布时间 确定最初 1-3 个迭代的具体工作 卡片记录 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:5","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"迭代计划策略 速度驱动的迭代计划（客观） 调整优先级 确定目标速度 确定迭代目标 选择用户故事 把用户故事分解成任务 只包含此项目增加价值的工作 - 如“回复邮件 1 小时”。 尽量明确，直到养成习惯 - 如自动化测试培养。 会议会占据（很多）时间（整体时间：如开会）。 缺陷- 发现 bug 的迭代中就修复它们。 处理依赖性 - 如 mock 数据 难以分解的工作 - 探针策略 对任务进行估算 一部分设计就够了 任务的适合大小 承诺驱动的迭代计划（主观） 要求团队做出承诺(团队主导，承诺特性非任务)“你们可以承诺交付我们已经讨论过的特性么？” 对估算值求和 -实际上大多数团队在计划每天 4-6 个小时的工作量时候能够取得成功 维护与承诺 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:6","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"估算速度策略 如果你在给出对速度的估算前可以进行一次或多测迭代， ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:3:7","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"有效原因与指导原则 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:4:0","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"敏捷计划有效原因 经常重新计划 承认不可能建立完美的计划，可以大量减少焦虑，而且可以逐步的消除这种不精确性。 对大小和持续时间的估算时独立的 大小和时间时有关系统的，但很多因素也会影响持续时间。 故事点来估算大小，接下来估算速度，然后规模和速度估算结合起来就可以得到持续时间 在不同层次制定计划 发布计划，迭代计划，每日计划。1.不同的计划是用于不同的目的事实。2.帮助开发团队从不同的角度来看待项目。 基于特性而不是基于任务制定计划 团队可以少做一些关于特定任务的预先考量。让团队思考正在开发的特性。 小故事保持工作流畅 每个迭代都要消除未完成的工作 在团队层次跟踪 不要准备个人燃尽图**而只绘制团队层次的燃尽图 承认不确定性并为之计划 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:4:1","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["软件工程"],"content":"敏捷估算和计划的 12 条指导原则 让整个团队参与 在不同层次上进行计划 使用不同度量单位，让对大小和持续时间的估算保持独立 用功能或者日期来体现不确定性 经常重新计划 跟踪进度并沟通 承认学习的重要性 计划具有适当大小的特性 确定特性优先级 最好的估算和计划来源于事实 保留一些松弛度 通过前瞻性计划协调多个团队 ","date":"2020-06-22","objectID":"https://blog.gethin.online/scrum-learning-notes/:4:2","tags":["scrum","软件工程"],"title":"Scrum 学习笔记","uri":"https://blog.gethin.online/scrum-learning-notes/"},{"categories":["语言与平台"],"content":" Jupyter Notebook Shortcuts ","date":"2020-06-04","objectID":"https://blog.gethin.online/jupyter-notebook-shortcuts/:0:0","tags":["python"],"title":"JUPYTER NOTEBOOK SHORTCUTS","uri":"https://blog.gethin.online/jupyter-notebook-shortcuts/"},{"categories":["语言与平台"],"content":"Command model Key Function 作用 Enter take you into edit mode 转入编辑模式 Shift-Enter run the current cell, select below 运行本单元，选中下个单元 Ctrl-Enter run selected cells 运行本单元 Alt-Enter run the current cell, insert below 运行本单元，在其下插入新单元 Y change the cell type to Code 单元转入代码状态 M change the cell type to Markdown 单元转入 markdown 状态 R change the cell type to Raw 单元转入 raw 状态 1 set level 1 title 设定 1 级标题-仅在 markdown 状态下 2 set level 2 title 设定 2 级标题 3 set level 3 title 设定 3 级标题 4 set level 4 title 设定 4 级标题 5 set level 5 title 设定 5 级标题 6 set level 6 title 设定 6 级标题 Up select cell above 选中上方单元 K select cell above 选中上方单元 Down select cell below 选中下方单元 J select cell above 选中下方单元 Shift-K Move selected cells up 连续选择上方单元 Shift-J Move selected cells down 连续选择下方单元 A insert cell above 在上方插入新单元 B insert cell below 在下方插入新单元 X cut selected cells 剪切选中的单元 C copy selected cells 复制选中的单元 Shift-V paste cells above 粘贴到上方单元 V paste cells below 粘贴到下方单元 Z undo cell deletion 恢复删除的最后一个单元 D,D delete selected cells 删除选中的单元 Shift-M merge cell below 合并选中的单元 Ctrl-S save and checkpoint 保存当前 NoteBook S Save and Checkpoint 保存当前 NoteBook L toggle line numbers 开关行号 O toggle output 转换输出 Shift-O toggle output scrolling 转换输出滚动 Esc close pager 关闭页面 Q close pager 关闭页面 H show all shortcuts 显示快捷键帮助 Shift-Space scroll notebook up 向上滚动 Space scroll notebook down 向下滚动 ","date":"2020-06-04","objectID":"https://blog.gethin.online/jupyter-notebook-shortcuts/:1:0","tags":["python"],"title":"JUPYTER NOTEBOOK SHORTCUTS","uri":"https://blog.gethin.online/jupyter-notebook-shortcuts/"},{"categories":["语言与平台"],"content":"Edit Mode Key Function 作用 Tab code completion or indent 代码补全或缩进 Shift-Tab tooltip 提示 Ctrl-] indent 缩进 Ctrl-[ dedent 解除缩进 Ctrl-A select all 全选 Ctrl-Z undo 撤销 Ctrl-Shift-Z redo 重做 Ctrl-Y redo 重做 Ctrl-Home go to cell start 跳到单元开头 Ctrl-Up go to cell start 跳到单元开头 Ctrl-End go to cell end 跳到单元末尾 Ctrl-Down go to cell end 跳到单元末尾 Ctrl-Left go one word left 跳到左边一个字首 Ctrl-Right go one word right 跳到右边一个字首 Ctrl-Backspace delete word before 删除前面一个字 Ctrl-Delete delete word after 删除后面一个字 Esc command mode 切换到命令模式 Ctrl-M command mode 切换到命令模式 Shift-Enter run cell, select below 运行本单元，选中下一单元 Ctrl-Enter run cell 运行本单元 Alt-Enter run cell, insert below 运行本单元，在下面插入一单元 Ctrl-Shift- - split cell 分割单元 Ctrl-Shift-Subtract split cell 分割单元 Ctrl-S Save and Checkpoint 保存当前 NoteBook Up move cursor up or previous cell 光标上移或转入上一单元 Down move cursor down or next cell 光标下移或转入下一单元 Ctrl-/ toggle comment on current or selected lines 注释整行/撤销注释 Written with StackEdit. ","date":"2020-06-04","objectID":"https://blog.gethin.online/jupyter-notebook-shortcuts/:2:0","tags":["python"],"title":"JUPYTER NOTEBOOK SHORTCUTS","uri":"https://blog.gethin.online/jupyter-notebook-shortcuts/"},{"categories":["语言与平台"],"content":" Python Learning Notes - Junior ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:0:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1. python 入门 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.1. 注释 单行注释 # 注释内容 多行注释 \"\"\"注释内容\"\"\" 中文编码声明注释 # coding=utf-8 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:1","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.2. 代码缩进 采用代码缩进和冒号“：”区分代码之间的层次，python 对代码缩进非常严格，如果不合理缩进会抛出 SyntaxError 异常。 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:2","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.3. 代码规范 1.3.1. 编写规范 每个 import 只导入一个模块 不要再行尾添加分号“；” 仅以每行不超过 80 个字符；如果超过，仅以使用小括号“（）” 使用必要的空行可以提高代码可读性 通常情况下，运算符两侧、函数参数之间、逗号“，”两侧建议使用空格进行分隔 应该避免在循环中使用+和+=运算符累加字符串，推荐做法是将每个字符串加入列表，然后再循环结束后使用 join 方法连接列表。 适当的使用一场处理提高程序容错性 1.3.2. 命名规范 模块名尽量短小，并且全部使用小写字母，可以使用下划线分割多个字母 如：game_main 包名尽量短小，并且全部使用小写字母，不推荐使用下划线，如：com.cr 类名采用单词首字母大写形式，即 Pascal 风格 如：TakeSomething 模块内部的类采用下划线+Pascal 风格的类名组成 如：_TakeSomething 函数、类的属性和方法的命名规则同模块类似，也是全部采用小写字母，多个字母间用下划线_进行分割 常量明明时全部采用大写字母，可以使用下划线 使用单下划线_开头的模块变量或者函数是受保护的，在使用 import * from 语句从模块中导入时这些变量或者函数不能导入 使用双下划线__开头的实例变量或者方法时类私有的 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:3","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"1.4. 基本输出 使用 print() 函数输出 使用 input() 函数输入 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:1:4","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2. 变量和数据类型 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.1. 保留字 Python 保留字: and, as, assert, break, class, continue, def, del, elif, else, except, finally, for, form, False, global, if, import, in, is, lambda, nonlocal, not, None, or, pass, raise, return, try, True, while, with, yield ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:1","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.2. 标识符 标识符命名规则：数字，字母，下划线，不能使用保留字 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:2","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.3. 变量 在 python 中，不需要先声明变量名及其类型，直接赋值即可创建各种类型变量。 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:3","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.4. 基本数据类型 2.4.1.数字类型 整数 十进制 八进制 - 必须以 0o/0O 开头 十六进制 - 必须以 0X/0x 开头 二进制 浮点数 复数 2.4.2. 字符串类型 通常使用‘’，“”，‘“’”。单引号双引号必须再一行，三引号可以分布在多行。 转义符：\\（续行符）,\\n（换行符）,\\0（空）,\\t（水平制表符）,\"（双引号）,'（单引号）,\\（一个反斜杠）,\\f（换页）,\\0dd（八进制数，dd 表示字符）,\\xhh（十六进制数，hh 表示字符） 布尔类型 类型转换 int(x) | float(x) | complex(real [,imag]) | str(x) | repr(x) | eval(str) | chr(x) | ord(x) | hex(x) | oct(x) ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:4","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"2.5. 运算符 2.5.1 数字运算符 +,-,*,/,%(余),//(取整除),**(幂) 2.5.2 赋值运算符 =,+=,-=,*=,/=,%=,//=,**= 2.5.3 比较运算符 \u003e,\u003c,==,!=,\u003e=,\u003c= 2.5.4 逻辑运算符 and,or,not 2.5.5 位运算符 \u0026,|,^,~,\u003c\u003c,\u003e\u003e ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:2:5","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3. 流程控制 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:0","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.1 选择语句 if 表达式: 语句块 if 表达式: 语句块 else: 语句块 if 表达式: 语句块 elif 表达式: 语句块 else: 语句块 if 表达式: if 表达式: 语句块 else: 语句块 else: 语句块 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:1","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.2 条件表达式 a=1 b=a if a\u003e0 else -a ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:2","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.3 循环语句 while 表达式: 循环体 for 迭代变量 in 对象: 循环体 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:3","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.4 跳转语句 break,continue ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:4","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["语言与平台"],"content":"3.5 pass 空语句 pass 不做任何事 ","date":"2020-05-26","objectID":"https://blog.gethin.online/python-learning-notes/:3:5","tags":["python"],"title":"PYTHON 学习笔记(Junior)","uri":"https://blog.gethin.online/python-learning-notes/"},{"categories":["数据与算法"],"content":"海量数据优化 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:0","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"1. 合理使用索引 索引是数据库中重要的数据结构，它的根本目的就是为了提高查询效率。现在大多数的数据库产品都采用 IBM 最先提出的 ISAM 索引结构。索引的使用要恰到好处，其使用原则如下： 在经常进行连接，但是没有指定为外键的列上建立索引，而不经常连接的字段则由优化器自动生成索引。 在频繁进行排序或分组（即进行 group by 或 order by 操作）的列上建立索引。 在条件表达式中经常用到的不同值较多的列上建立检索，在不同值少的列上不要建立索引。比如在雇员表的“性别”列上只有“男”与“女”两个不同值，因此就无必要建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。 如果待排序的列有多个，可以在这些列上建立复合索引（compound index）。 使用系统工具。如 Informix 数据库有一个 tbcheck 工具，可以在可疑的索引上进行检查。在一些数据库服务器上，索引可能失效或者因为频繁操作而使得读取效率降低，如果一个使用索引的查询不明不白地慢下来，可以试着用 tbcheck 工具检查索引的完整性，必要时进行修复。另外，当数据库表更新大量数据后，删除并重建索引可以提高查询速度。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:1","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"2. 避免或简化排序 应当简化或避免对大型表进行重复的排序。当能够利用索引自动以适当的次序产生输出时，优化器就避免了排序的步骤。以下是一些影响因素： 索引中不包括一个或几个待排序的列； group by 或 order by 子句中列的次序与索引的次序不一样； 排序的列来自不同的表。 为了避免不必要的排序，就要正确地增建索引，合理地合并数据库表（尽管有时可能影响表的规范化，但相对于效率的提高是值得的）。如果排序不可避免，那么应当试图简化它，如缩小排序的列的范围等。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:2","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"3. 消除对大型表行数据的顺序存取 在嵌套查询中，对表的顺序存取对查询效率可能产生致命的影响。比如采用顺序存取策略，一个嵌套 3 层的查询，如果每层都查询 1000 行，那么这个查询就要查询 10 亿行数据。避免这种情况的主要方法就是对连接的列进行索引。 例如，两个表：学生表（学号、姓名、年龄……）和选课表（学号、课程号、成绩）。如果两个表要做连接，就要在“学号”这个连接字段上建立索引。 还可以使用并集来避免顺序存取。尽管在所有的检查列上都有索引，但某些形式的 where 子句强迫优化器使用顺序存取。下面的查询将强迫对 orders 表执行顺序操作： SELECT * FROM orders WHERE (customer_num=104 AND order_num\u003e1001) OR order_num=1008 虽然在 customer_num 和 order_num 上建有索引，但是在上面的语句中优化器还是使用顺序存取路径扫描整个表。因为这个语句要检索的是分离的行的集合，所以应该改为如下语句： SELECT * FROM orders WHERE customer_num=104 AND order_num\u003e1001 UNION SELECT * FROM orders WHERE order_num=1008 这样就能利用索引路径处理查询。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:3","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"4. 避免相关子查询 一个列的标签同时在主查询和 where 子句中的查询中出现，那么很可能当主查询中的列值改变之后，子查询必须重新查询一次。查询嵌套层次越多，效率越低，因此应当尽量避免子查询。如果子查询不可避免，那么要在子查询中过滤掉尽可能多的行。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:4","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"5. 避免困难的正规表达式 MATCHES 和 LIKE 关键字支持通配符匹配，技术上叫正规表达式。但这种匹配特别耗费时间。例如： SELECT * FROM customer WHERE zipcode LIKE “98_ _ _” 即使在 zipcode 字段上建立了索引，在这种情况下也还是采用顺序扫描的方式。如果把语句改为SELECT * FROM customer WHERE zipcode \u003e“98000”，在执行查询时就会利用索引来查询，显然会大大提高速度。 另外，还要避免非开始的子串。例如语句：SELECT * FROM customer WHERE zipcode[2，3] \u003e“80”，在 where 子句中采用了非开始子串，因而这个语句也不会使用索引。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:5","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"6.使用临时表加速查询 把表的一个子集进行排序并创建临时表，有时能加速查询。有助于避免多重排序操作，而且在其他方面还能简化优化器的工作。例如： SELECT cust.name，rcvbles.balance，……other columns FROM cust，rcvbles WHERE cust.customer_id = rcvlbes.customer_id AND rcvblls.balance\u003e0 AND cust.postcode\u003e“98000” ORDER BY cust.name 如果这个查询要被执行多次而不止一次，可以把所有未付款的客户找出来放在一个临时文件中，并按客户的名字进行排序： SELECT cust.name，rcvbles.balance，……other columns FROM cust，rcvbles WHERE cust.customer_id = rcvlbes.customer_id AND rcvblls.balance\u003e0 ORDER BY cust.name INTO TEMP cust_with_balance 然后以下面的方式在临时表中查询： SELECT * FROM cust_with_balance WHERE postcode\u003e“98000” 临时表中的行要比主表中的行少，而且物理顺序就是所要求的顺序，减少了磁盘 I/O，所以查询工作量可以得到大幅减少。 注意：临时表创建后不会反映主表的修改。在主表中数据频繁修改的情况下，注意不要丢失数据。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:6","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"7. 用排序来取代非顺序存取 非顺序磁盘存取是最慢的操作，表现在磁盘存取臂的来回移动。SQL 语句隐藏了这一情况，使得在写应用程序时很容易写出要求存取大量非顺序页的查询。 有些时候，用数据库的排序能力来替代非顺序的存取能改进查询。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:1:7","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"百万数据查询优化技巧三十则 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询： select id from t where num=0 应尽量避免在 where 子句中使用!=或\u003c\u003e操作符，否则将引擎放弃使用索引而进行全表扫描。 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 下面的查询也将导致全表扫描： select id from t where name like '%abc% 若要提高效率，可以考虑全文检索。 如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)='abc'--name以abc开头的id` select id from t where datediff(day,createdate,'2005-11-30')=0--‘2005-11-30’生成的id 应改为 select id from t where name like 'abc%' select id from t where createdate\u003e='2005-11-30' and createdate\u003c'2005-12-1' 要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(...) 很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段 sex，male、female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 任何地方都不要使用 select * from t，用具体的字段列表代替“*”，不要返回用不到的任何字段。 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 避免频繁创建和删除临时表，以减少系统表资源的消耗。 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 尽量避免大事务操作，提高系统并发能力。 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:2:0","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"常用SQL ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:0","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的存储过程 --select string using in procedure select b.name, a.text from syscomments a left join sysobjects b on b.id=a.id where b.xtype='P' and a.text like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:1","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的列名 --select columns name select b.name as Table1, a.name as Columns1,a.type from syscolumns a left join sysobjects b on b.id=a.id where b.xtype='u' and a.name like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:2","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的表名 --select table name select name from sysobjects where xtype='u' and name like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:3","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的函数名 --select string using in function select b.name, a.text from syscomments a left join sysobjects b on b.id=a.id where b.xtype='fn' and a.text like '%abc%' ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:4","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["数据与算法"],"content":"查询带关键字的视图 --select string using in view select b.name, a.text from syscomments a left join sysobjects b on b.id=a.id where b.xtype='V' and a.text like '%abc%' Written with StackEdit. ","date":"2020-04-27","objectID":"https://blog.gethin.online/massive-data-optimization-notes/:3:5","tags":["数据"],"title":"海量数据优化笔记","uri":"https://blog.gethin.online/massive-data-optimization-notes/"},{"categories":["语言与平台"],"content":" 这篇文章主要是翻译和记录了一些 Gateby 的基础知识，有助于开发者通过这些基础知识进行快速的开发 Refer to the Article: https://mpolinowski.github.io/gatsby-js-knowledgebase ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:0:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"10 添加文件数据(Adding File Data) 使用 Gatsby，您可以使用 GraphQL 直接从文件中查询数据。 Transformer插件将文件节点转换为各种其他类型的数据，例如 gatsby-transformer-json 将 将JSON 文件转换为 JSON 数据节点，而 gatsby-transformer-remark 将 将markdown 文件转换为 MarkdownRemark 节点，您可以从中查询 Markdown 的 的HTML 表示形式。 在这里，我们将使用gatsby-source-filesystem从我们的文件系统创建文件节点。 npm install --save gatsby-source-filesystem 安装后，将插件添加到 gatsby-config.js。 您可以具有此插件的多个实例，以从文件系统上的不同位置读取源节点。 以下设置了 Jekyll 模式：具有 Markdown 文件的页面目录和.json，.yaml，.csv 的数据目录： { resolve: `gatsby-source-filesystem`, options: { name: `pages`, path: `${__dirname}/src/pages/`, }, }, { resolve: `gatsby-source-filesystem`, options: { name: `data`, path: `${__dirname}/src/data/`, }, } 现在，您可以打开 GraphiQL 调试器-在大括号中，当你开始键入 allFiles 时，它应提供自动补全功能。 只需按 Enter 接受，然后再次按 CTRL + ENTER 填写所有页面 ID 的查询： { allFile { edges { node { id } } } } 当你删除 ID 并按 CTRL + SPACE 时，将显示一个包含所有可查询选项的下拉菜单：你可以使用 parent，children 和 和relativePath 属性来创建， 例如 breadcrumb navigation：现在，我们可以在/src/pages/page-2.js 中添加 GraphQL 查询，以遍历我们的所有页面并显示一些数据： export const query = graphql` query MyFilesQuery { allFile { edges { node { relativePath prettySize extension birthTime(fromNow: true) } } } } ` 不要忘记将{data}注入页面组件： const SecondPage = ({data}) =\u003e 现在，我们可以添加一些 JSX 来遍历所有文件，并在\u003ctable\u003e中输出信息 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003erelativePath\u003c/th\u003e \u003cth\u003eprettySize\u003c/th\u003e \u003cth\u003eextension\u003c/th\u003e \u003cth\u003ebirthTime\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e {data.allFile.edges.map(({ node }, index) =\u003e ( \u003ctr key={index}\u003e \u003ctd\u003e {node.relativePath} \u003c/td\u003e \u003ctd\u003e {node.prettySize} \u003c/td\u003e \u003ctd\u003e {node.extension} \u003c/td\u003e \u003ctd\u003e {node.birthTime} \u003c/td\u003e \u003c/tr\u003e ))} \u003c/tbody\u003e \u003c/table\u003e ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:1:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11 使用 Markdown(Working with Markdown) ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.1 添加 Markdown 到 GraphQL 现在，我们可以访问有关我们所有页面的信息。 但是如上所述，在最后一段的开头，我们还可以使用 Gatsby Transformer Plugins 来查找文件并将其内容可以通过 GraphQL 查询。 这里，我们希望使用 Markdown 文件并对其进行转换，以便能够在我们的网站上显示其内容。 为此所需的 Transformer Plugin 是 gatsby-transformer-remark。 首先，我们需要安装插件： npm install --save gatsby-transformer-remark 在 gatsby-config.js 中添加： plugins: [ `gatsby-transformer-remark`, ] 然后在/src/pages/FirstMDpost/index.md 内创建一个 markdown 页面，其中包含一些 FrontMatter（文件开头的元数据，以后可以由 GraphQL 查询）和一些文本： --- path: '/md-posts' title: 'My first Post' date: '2017-10-05' author: 'Mike Polinowski' chapter: 'Index' --- # This is my first mardown Post! 现在我们为 GraphQL 提供了 Markdown -与以前一样，只需开始输入 allMardownRemark（ENTER 自动完成），然后按 CTRL + ENTER 完成查询： ![gatsby_10](https://raw.githubusercontent.com/mpolinowski/gatsby-wiki/master/gatsby_10.png =577x189) 现在，我们可以查询 FrontMatter 以及添加到页面文件夹中的每个 MD 文件的 MD 转换为 HTML 的内容： ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:1","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.2 发布我们的 Markdown 数据模板 这些 Markdown 表示将要被显示的模板，但是现在我们需要创建一个用于此数据的样式模板。让我们先在/src 内添加一个称为templates的文件夹。 现在，向其中添加一个名为post.js的文件，该文件将包含每个帖子条目的结构模板。 该文件包含我们帖子的 JSX markup： import React from 'react' export default function Template({data}) { const {markdownRemark: post} = data return ( \u003cdiv\u003e \u003ch1\u003e{post.frontmatter.title}\u003c/h1\u003e \u003cdiv dangerouslySetInnerHTML={{__html: post.html}} /\u003e \u003c/div\u003e ) } export const postQuery = graphql` query BlogPostByPath($path: String!) { markdownRemark(frontmatter: { path: { eq: $path} }) { html frontmatter { path title } } } ` \u003cTemplate /\u003e组件接收{data}属性，这些属性由 GraphQL 查询检索。 该查询会查找 markdown 中 中frontmatter 里面所有 URL 等于$Path 的帖子，所以如果你在浏览器中键入的这个 URL 是/md-posts，那么路径中带有/md-posts 的文件，就会被调用。 然后，查询使用 markdownRemark 插件将 post markdown 转换为 HTML，并在{data}中提供其前题的路径和标题，并将其传递到组件，然后渲染。 Gatsby 已经配置为将/src/pages 中的所有页面路由为我们网站的页面。 但是现在我们必须注册来自 markdown 文件和 post.js 模板的帖子。 为此，我们必须在应用程序的根目录内创建一个名为 gatsby-node.js 的文件。 我们将使用createPages Gatsby API从我们的帖子模板创建页面： const path = require('path'); exports.createPages = ({boundActionCreators, graphql}) =\u003e { const {createPage} = boundActionCreators; // const createPage = boundActionCreators.createPage; const postTemplate = path.resolve('src/templates/post.js'); return graphql(`{ allMarkdownRemark { edges { node { html id frontmatter { path title } } } } }`) .then(res =\u003e { if(res.errors) { return Promise.reject(res.errors); } res.data.allMarkdownRemark.edges.forEach(({node}) =\u003e { createPage({ path: node.frontmatter.path, component: postTemplate }) }) }) } 保存并重新启动您的应用程序，然后在浏览器中打开 http://localhost:8000/md-posts ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:2","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.3 带有 Markdown 的嵌套路由 要为./src/pages/FirstMDpost/index.md 文件创建子帖子，我们可以简单地向文件夹中添加更多文件，并在其前题中定义嵌套路由 - e.g. ./src/pages/FirstMDpost/myfirstpost.md: --- path: '/md-posts/first-post' title: 'First Blog Post' date: '2017-10-05' author: 'Mike Polinowski' chapter: 'Markdown Posts' --- # This is my first markdown Post! 和 ./src/pages/FirstMDpost/mysecondpost.md: --- path: '/md-posts/second-post' title: 'Second Blog Post' date: '2017-10-05' author: 'Mike Polinowski' chapter: 'Markdown Posts' --- # A dive into Markdown Syntax 它们可以分别通过http://localhost:8000/md-posts/first-post和http://localhost:8000/md-posts/second-post 来访问 ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:3","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.4 创建 Index 页面 现在，我们可以使用 GraphQL 检索所有 Markdown 页面并将过滤它们。 对于此测试，我们将一个表添加到起始页面，显示最后 10 个帖子（到目前为止，我只发表了 3 3个帖子…），我们希望按日期降序排列它们，并且仅显示 chapter: ‘Markdown Posts’的页面 ，并排除我们的 index.md： const IndexPage = ({data}) =\u003e ( \u003cdiv\u003e \u003ch2\u003eMarkdown Index\u003c/h2\u003e \u003cp\u003eThe table below sorts out all Markdown pages that are not inside the \"Markdown Posts\" chapter - as defined inside their frontmatter. It also applies a filter, to only display the latest 10 posts. Click on here to display \u0026nbsp; \u003cLink to=\"/md-posts/\"\u003e all Markdown pages \u003c/Link\u003e .\u003c/p\u003e \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eDate\u003c/th\u003e \u003cth\u003eLink\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e {data.allMarkdownRemark.edges.map(post =\u003e ( \u003ctr key={post.node.id}\u003e \u003ctd\u003e {post.node.frontmatter.date} \u003c/td\u003e \u003ctd\u003e \u003cLink to={post.node.frontmatter.path}\u003e {post.node.frontmatter.title} \u003c/Link\u003e \u003c/td\u003e \u003c/tr\u003e ))} \u003c/tbody\u003e \u003c/table\u003e \u003c/div\u003e ) export const pageQuery = graphql` query IndexQuery { allMarkdownRemark(limit: 10 sort: {fields: [frontmatter___date], order: DESC} filter: { frontmatter: { chapter: {eq: \"Markdown Posts\"} }} ) { edges { node { id frontmatter { path title date } } } } } ` ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:4","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"11.5 缓存 Markdown 中的链接 一旦开始在 Markdown 文件中添加链接，您会发现单击它们会重新加载您的应用程序-这不是很好 :( 但请放心，这里的gatsby-plugin-catch-links可以助您一臂之力！ 它-安装后，将其添加到./gatsby-config.js 中的 Gatsby 插件中，它就可以正常工作： npm install --save gatsby-plugin-catch-links // In your gatsby-config.js plugins: [ `gatsby-plugin-catch-links`, ] ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:2:5","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"12 添加 Material-UI 为了使我们的生活更轻松，我们希望包含来自@ Materials-UI 的即用型 material 设计组件。 我们将安装 v.1.0.0 的测试版-它也需要 Roboto Fontface 和 和Material-UI 图标： npm install material-ui@next --save npm install typeface-roboto --save npm install material-ui-icons --save 现在，我们可以轻松地将 Material-UI 组件导入我们的应用程序： import React from 'react' import { render } from 'react-dom' import Button from 'material-ui/Button' import 'typeface-roboto' function AppWithButton() { return ( \u003cButton\u003e Hello World \u003c/Button\u003e ); } render(\u003cAppWithButton /\u003e, document.querySelector('#app')); ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:3:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":"13 添加 Elasticsearch 该项目的先决条件之一是，我们需要为我们的 ElasticSearch Index 创建一个闪电般的界面。 我们已经为其构建了ES6 Class component。并将其添加到 Gatsby/Material-UI 中非常简单。 首先，添加./src/pages/search/jsx 并修改 ElasticSearch 组件来配合我们的 UI. import React, { Component } from 'react' import Link from 'gatsby-link' import elasticsearch from 'elasticsearch' import { withStyles } from 'material-ui/styles' import Grid from 'material-ui/Grid' import Button from 'material-ui/Button' import ResultCards from '../components/ResultCards' const connectionString = 'localhost:9200' const _index = 'wiki2_de_2017_09_09' const _type = 'article' let client = new elasticsearch.Client({ host: connectionString, log: \"trace\" }) const rootStyle = { flexGrow: 1, marginTop: 30, } export class Search extends Component { constructor(props) { super(props) this.state = { results: [] }; this.handleChange = this.handleChange.bind(this) } handleChange(event) { const search_query = event.target.value; client.search({ index: _index, type: _type, body: { query: { multi_match: { query: search_query, fields: ['title^100', 'tags^100', 'abstract^20', 'description^10', 'chapter^5', 'title2^10', 'description2^10'], fuzziness: 1, }, }, }, }).then(function(body) { this.setState({ results: body.hits.hits }); }.bind(this), function(error) { console.trace(error.message); } ); } render() { return ( \u003cdiv className=\"container\"\u003e \u003cinput type=\"text\" onChange={this.handleChange} /\u003e \u003cSearchResults results={this.state.results} /\u003e \u003c/div\u003e ); } } const SearchResults = ({results}) =\u003e ( \u003cdiv className=\"search_results\"\u003e \u003cbr/\u003e\u003chr/\u003e \u003cdiv className={rootStyle}\u003e \u003cGrid container spacing={24}\u003e {results.map((result , i) =\u003e \u003cResultCards key={i} image={result._source.image} title={result._source.title2} link={result._source.link} abstract={result._source.abstract}/\u003e )} \u003c/Grid\u003e \u003c/div\u003e \u003cbr/\u003e\u003cbr/\u003e\u003cLink to=\"/\" style={{ textDecoration: 'none' }}\u003e\u003cButton raised color=\"primary\"\u003eGo back to the homepage\u003c/Button\u003e\u003c/Link\u003e \u003c/div\u003e ) export default Search \u003cSearchResults /\u003e组件将遍历\u003cResultCards /\u003e组件内的 Material UI Card： import React from 'react' import Link from 'gatsby-link' import Card, { CardActions, CardContent, CardMedia } from 'material-ui/Card' import Button from 'material-ui/Button' import Typography from 'material-ui/Typography' import Grid from 'material-ui/Grid' const ResultCards = ({image, title, abstract, link}) =\u003e ( \u003cGrid item xs={12} sm={6} lg={4}\u003e \u003cCard style={{ maxWidth: 345 }}\u003e \u003cCardMedia style={{ height: 200 }} image={image} title={abstract} /\u003e \u003cCardContent\u003e \u003cTypography type=\"headline\" component=\"h4\" style={{ minHeight: 60, marginBottom: \"10px\" }}\u003e {title} \u003c/Typography\u003e \u003cTypography component=\"p\" style={{ minHeight: 50, marginBottom: \"10px\" }}\u003e {abstract} \u003c/Typography\u003e \u003c/CardContent\u003e \u003cCardActions\u003e \u003cLink to={link} style={{ textDecoration: 'none' }}\u003e \u003cButton dense color=\"primary\"\u003e Read \u003c/Button\u003e \u003c/Link\u003e \u003cButton dense color=\"primary\"\u003e Learn More \u003c/Button\u003e \u003c/CardActions\u003e \u003c/Card\u003e \u003c/Grid\u003e ) export default ResultCards 组件将添加来自 ElasticSearch JSON Response 的结果，并给我们一个灵活的卡片网格。 ","date":"2020-03-17","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-3/:4:0","tags":["前端"],"title":"Gatsby基础知识（下）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-3/"},{"categories":["语言与平台"],"content":" 这篇文章主要是翻译和记录了一些 Gateby 的基础知识，有助于开发者通过这些基础知识进行快速的开发 Refer to the Article: https://mpolinowski.github.io/gatsby-js-knowledgebase ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:0:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"06 属性传递(Passing down Props) 现在，我们可以从父组件传递属性到Counter组件。例： 我们可以通过显示的页面来更改我们的Counter 标题。 ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"6.1 更改头部 \u003cCounter header=\"This is the Index Counter\" /\u003e 这个header的属性现在可以用在Counter组件中的render方法。现在我们可以通过调用他的父组件来为Counter组件获取不同的标头了。 render() { return \u003cdiv\u003e \u003ch3\u003e{this.props.header}\u003c/h3\u003e \u003cp\u003ecurrent count: {this.state.count}\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003eplus\u003c/button\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count - 1 })}\u003eminus\u003c/button\u003e \u003c/div\u003e } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:1","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"6.2 更改样式 样式也是如此-如果我们希望标题与父组件的配色方案匹配，我们只需要将颜色属性传递给 Counter 组件： \u003cCounter header=\"This is the Index Counter\" color=\"rebeccapurple\" /\u003e 并在组件本身中添加必要的内联样式： render() { return \u003cdiv\u003e \u003ch3 style={{color: this.props.color}}\u003e{this.props.header}\u003c/h3\u003e \u003cp\u003ecurrent count: {this.state.count}\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003eplus\u003c/button\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count - 1 })}\u003eminus\u003c/button\u003e \u003c/div\u003e } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:2","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"6.3 设置默认属性 为了确保localhost:8000/counter URL 仍可以被打开，我们现在必须在Counter 组件内部定义一个默认的属性 - 如果没有父组件传递 props，则标题标记和字体颜色将是未定义的！ 这可以通过 Prop-Types 完成，我们需要安装： npm install --save prop-types 现在，我们可以将其导入到/src/pages/counter.js： import React from \"react\" import PropTypes from \"prop-types\" 并在Counter组件内（在export语句上方）为 header prop 定义一个默认值： Counter.defaultProps = { header: \"Default Counter\", color: \"black\", } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:1:3","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"07 Gatsby 插件(Gatsby Plugins) 插件是实现 Gatsby API 的 的Node.js 软件包。 它们使您能够轻松解决常见的网站构建问题，例如 设置 Sass，添加 markdown 支持，过程映像等。 ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:2:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"7.1 进度动画 在此示例中，我们要使用 NProgress.js 插件将加载动画添加到我们的网站。 您使用 npm 安装 NProgress 插件： npm install --save gatsby-plugin-nprogress 现在，我们必须告诉 Gatsby 通过编辑（在文件不存在的情况下创建）应用程序根目录内的 gatsby-config.js 文件来使用该插件。 在 在starter 模板中，我们已经安装了 react-helmet 插件（此插件如下所述：Page Layout）。 现在，只需将 gatsby-plugin-nprogress 添加到数组中： module.exports = { siteMetadata: { title: `Gatsby Wiki`, }, plugins: [ `gatsby-plugin-react-helmet`, { { resolve: `gatsby-plugin-nprogress`, options: { // Setting a color is optional. color: `rebeccapurple`, // Disable the loading spinner. showSpinner: false, }, }, ], } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:2:1","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"7.2 离线支持和清单 现在，我们想在网站上添加一个 Serviceworker，以帮助我们缓存应用程序的重要部分，从而为我们提供一定程度的脱机支持-正如 Offline Plugin告诉我们的那样，我们还将安装 Manifest Plugin （请确保它是 在 Offline Plugin 之前列出！）。 npm install --save gatsby-plugin-manifest npm install --save gatsby-plugin-offline 现在，将它们添加到我们的 Gatsby 配置中： module.exports = { siteMetadata: { title: `Gatsby Wiki`, }, plugins: [ `gatsby-plugin-react-helmet`, { resolve: `gatsby-plugin-nprogress`, options: { // Setting a color is optional. color: `rebeccapurple`, // Disable the loading spinner. showSpinner: false, }, }, { resolve: `gatsby-plugin-manifest`, options: { name: \"Gatsby Wiki\", short_name: \"Gatsby Wiki\", start_url: \"/\", background_color: \"white\", theme_color: \"rebeccapurple\", display: \"minimal-ui\", icons: [ { // Everything in /static will be copied to an equivalent // directory in /public during development and build, so // assuming your favicons are in /static/favicons, // you can reference them here src: `/apple-touch-icon.png`, sizes: `180x180`, type: `image/png`, }, { { src: `/favicon.ico`, sizes: `256x256`, type: `image/png`, }, ], }, }, `gatsby-plugin-offline`, ], } ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:2:2","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"08 单页面应用(Single-Page-Application) Gatsby 基于他的布局特性提供了一个创建 Single-Page-Applications (SPA’s)的简单方法。 你可以在/src/layout 中找到 JSX 和 和CSS。我们正在使用的 Gatsby Starter，已经提供了头导航栏，该头导航栏已在 index.js 文件中定义（并带有必需的 CSS）。 您可以看到该应用程序已经使用React-Helmet作为 Gatsby 插件。 这个可重用的 React 组件将管理您对文档\u003chead\u003e的所有更改。 Helmet采用纯 HTML 标记并输出纯 HTML 标记。 该布局定义了\u003cHeader /\u003e组件，该组件与\u003cHelmet /\u003e组件一起在\u003cTemplateWrapper /\u003e内部使用。 您到目前为止所创建的页面中的所有内容，都将通过{children}标签注入到 Wrapper 中。 这样，您可以创建顶部导航栏，页眉，侧面导航和页脚，然后将其显示在所有网站上。 ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:3:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":"09 GraphQL 我们可以在应用程序的根目录下的 gatsby-config.js 内定义一些全局变量： module.exports = { siteMetadata: { title: `Gatsby Wiki`, author: `Mike Polinowski`, description: `Trying out Gatsby`, }, } 该数据将可用于每个页面，并可使用 GraphQL 查询。 只需将以下 GraphQL 查询添加到/src/pages/index.js，即可保留这些值： export const query = graphql` query FirstQuery { site { siteMetadata { title author description } } } ` 然后，我们需要将此{data}注入父组件\u003cIndexPage /\u003e： const IndexPage = ({data}) =\u003e 现在我们可以查询组件内部的这些数据： \u003ch1\u003e{data.site.siteMetadata.description}\u003c/h1\u003e 为什么是 data.site.siteMetadata？Gatsby 的 的graphql 调试器在 http://localhost:8000/___graphql上运行，您也可以使用它来测试查询并查看结果。 只需打开调试器，然后尝试我们先前的查询： ","date":"2020-03-10","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-2/:4:0","tags":["前端"],"title":"Gatsby基础知识（中）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-2/"},{"categories":["语言与平台"],"content":" 这篇文章主要是翻译和记录了一些 Gateby 的基础知识，有助于开发者通过这些基础知识进行快速的开发 Refer to the Article: https://mpolinowski.github.io/gatsby-js-knowledgebase ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:0:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"00 准备操作 The default Gatsby starter Github 有关项目结构的概述，请参阅Gatsby documentation - Building with Components 从您的 CLI 运行此安装程序（假设已安装 Gatsby）： gatsby new gatsby-wiki ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:1:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"01 开始你的 Gatsby 开发环境(Start your Gatsby development environment) 现在请转到你的站点目录中，并使用 npm 运行你的 Gatsby 开发环境如下： cd gatsby-wiki npm run development 看，你可以访问你的网站了http://localhost:8000 ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:2:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"02 添加内容和链接页面(Adding content and Linking Pages) /src/pages/index.js 文件包含常规的 JSX-在\u003cdiv /\u003e标记内添加任何 HTML，可以让它显示在您的网站内。（Gatsby 使用的热加载） import React from \"react\" import Link from \"gatsby-link\" const IndexPage = () =\u003e ( \u003cdiv\u003e \u003ch1\u003eHi people\u003c/h1\u003e \u003cp\u003eWelcome to your new Gatsby site.\u003c/p\u003e \u003cp\u003eNow go build something great.\u003c/p\u003e \u003cLink to=\"/page-2/\"\u003eGo to page 2\u003c/Link\u003e \u003c/div\u003e ) export default IndexPage 你可以通过import Link from gatsby-link使用 Link 组件并链接到其他页面 \u003cLink to=\"/page-2/\"\u003eGo to page 2\u003c/Link\u003e 链接我们的 index.js 页面到同目录的 page-2 页面。/src /pages 文件夹中的每个 js 文件都会自动被 Gatsby 路由！ ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:3:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"03 样式化 JSX(Styling your JSX) 你可以在组件中使用内联样式如： const IndexPage = () =\u003e ( \u003cdiv style={{ color: \"tomato\", background: \"blue\"}}\u003e \u003ch1\u003eHi people\u003c/h1\u003e \u003cp\u003eWelcome to your new Gatsby site.\u003c/p\u003e \u003cp\u003eNow go build something great.\u003c/p\u003e \u003cLink to=\"/page-2/\"\u003eGo to page 2\u003c/Link\u003e \u003c/div\u003e ) 一些高级样式，请查看 Gatsby 插件 Glamor 或者 Styled Components. 如何安装这些插件请查看Gatsby Plugins。 ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:4:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"04 添加交互式插件(Adding Interactive Components) React 允许你向页面中添加交互 - 我们想添加一个计数器，在加载时将其状态设置为 0，并且有两个使用 onClick 事件增加或减少计数器状态的按钮。 我们可以添加一个新文件/src/pages/counter.js并链接到index页面\u003cLink to=\"/counter/\"\u003eGo to Counter\u003c/Link\u003e。 import React from \"react\" class Counter extends React.Component { constructor() { super() this.state = { count: 0 } } render() { return ( \u003cdiv\u003e \u003ch1\u003eCounter\u003c/h1\u003e \u003cp\u003ecurrent count: {this.state.count}\u003c/p\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count + 1 })}\u003e plus plus\u003c/button\u003e \u003cbutton onClick={() =\u003e this.setState({ count: this.state.count - 1 })}\u003e minus minus\u003c/button\u003e \u003c/div\u003e ) } } export default Counter ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:5:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":["语言与平台"],"content":"05 向你的站点导入组件(Importing Components to your Sites) 目前为止，我们将 pages 目录中的每个文件都用作单独的站点。但是 React.js 允许我们采用默认组件-在文件底部导出的默认组件-并将其导入另一个页面。 例如，我们可以将上面的\u003cCounter /\u003e组件添加到索引页面中（而不是仅链接到它）。 我们只需要在/src/pages/index.js开头添加import一行: import React from \"react\" import Link from \"gatsby-link\" import Counter from \"./counter\" 并在 index.js 的 的JSX 代码内引用 Counter，如下所示： const IndexPage = () =\u003e ( \u003cdiv\u003e \u003ch1\u003eHi people\u003c/h1\u003e \u003cp\u003eWelcome to your new Gatsby site.\u003c/p\u003e \u003cp\u003eNow go build something great.\u003c/p\u003e \u003cLink to=\"/page-2/\"\u003eGo to Page 2\u003c/Link\u003e \u003cbr /\u003e \u003cbr /\u003e \u003cCounter /\u003e \u003c/div\u003e ) ","date":"2020-03-01","objectID":"https://blog.gethin.online/gatsby-basic-knowledge-1/:6:0","tags":["前端"],"title":"Gatsby基础知识（上）","uri":"https://blog.gethin.online/gatsby-basic-knowledge-1/"},{"categories":null,"content":"自我评价 Hi，我叫GETHIN，是一名主修计算机，有8年工作经验的软件工程师，擅长全栈开发，主要工作语言是C#，曾就职于多家知名外企和互联网企业，如Honeywell，腾讯文学等，目前就职于GreenDot。 擅长技术体系架构设计与重构，软件项目研究，分析设计与风险识别，爱好云原生架构设计。 熟悉OOP，SOA，AOP，MVC，MVVM，EDA，BDD，DDD，微服务架构，云架构，SPA等架构与编程思想，注重基于SOLID编码规范。熟悉常见的架构风格。熟悉各种UML的使用。 精通C#/.NET开发，熟悉Python，精通传统.NET相关技术WCF，WEBAPI，MVC，WPF并熟练掌握现代.NET开发技术.NET Core, RabbitMQ, Azure, K8S, Docker 等。 认证Scrum Master，善于发现和解决敏捷开发中的各种技术和流程问题，熟知软件开发生命周期SDLC。 熟悉手机IOS端开发，Cordova，熟悉react，vue，javascript，jquary等。 了解SQL Server，Oracle，MySQL，存储过程，EF，Redis。 ","date":"0001-01-01","objectID":"https://blog.gethin.online/about/:0:1","tags":null,"title":"关于我","uri":"https://blog.gethin.online/about/"},{"categories":null,"content":"个人经历 GREEN DOT - Sr. Software Engineer 在 GreenDot 担任 高级软件工程师，主要负责开发维护银行后端系统。如银行转账，信用卡自动还款 等 主要的开发语言是 C#，主要技术有 .NET Core, RabbitMQ, WEBAPI，K8S，SQLServer 等 主要项目：Eureka 发卡，TMM，BAAS交易，信用卡自动还款 等 2019 function non0plural(number, name) { if (number == 0) { return \"\" } if (number == 1 || number == -1) { return number + \" \" +name } return number + \" \" + name + \"s\" } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2019-05-31\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 let years = 0 if (months Honeywell - Software Engineer 1 years 在 霍尼韦尔 担任 移动端软件工程师，主要负责开发项目手机端应用，如SRS IOS手机端， 工业报警混合应用端 等 主要开发语言是SWIFT，JS。主要技术有 Cordova，Vue，IOS，Hybird 等 主要项目: REF SAAS IOS端应用，工业报警手机混合端应用 2018 GREEN DOT - Software Engineer II 3 years 在 GreenDot 担任 软件工程师，主要负责开发维护银行风险控制项目 主要开发语言是 C#， 主要技术有 .NET，WCF，MVC，WEBAPI 等 主要项目：APPLY PAY CASH风控，MITIK \u0026 IDOLOGY 风控系统集成，银行常规风控项目 等 2015 腾讯文学 - Software Engineer 1 years 在 腾讯文学 担任 软件工程师，主要负责开发维护起点读书的各种功能 在 主要开发语言是 C#，JS， 主要技术有 .NET，MVC，aspx，memchached，Oracle 主要项目：Mobile 端春节打赏活动，端闪屏替换，文章末打赏互动 等 2014 易贸集团 - Software Engineer 1 years 4 months 在 易贸集团 担任 软件工程师，主要负责开发维护集团内部的各种系统 主要开发语言是 C#，JS， 主要技术有 .NET，MVC，WPF，MSMQ 主要项目：会展系统，客服系统 等 2012 南京航空航天大学 - 计算机专业 4 years 南京航空航天大学，计算机专业，优秀毕业论文 2009 ","date":"0001-01-01","objectID":"https://blog.gethin.online/about/:0:2","tags":null,"title":"关于我","uri":"https://blog.gethin.online/about/"},{"categories":null,"content":"友情链如下 ","date":"0001-01-01","objectID":"https://blog.gethin.online/links/:1:0","tags":null,"title":"友情链接","uri":"https://blog.gethin.online/links/"},{"categories":null,"content":"欢迎留言 ","date":"0001-01-01","objectID":"https://blog.gethin.online/message-board/:1:0","tags":null,"title":"留言板","uri":"https://blog.gethin.online/message-board/"},{"categories":null,"content":"此页面用于展示收藏的网站 ","date":"0001-01-01","objectID":"https://blog.gethin.online/websites/:1:0","tags":null,"title":"网站收藏","uri":"https://blog.gethin.online/websites/"},{"categories":null,"content":"网站里程碑 BLOG 3.0 ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:0","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"},{"categories":null,"content":"个人博客3.0 由 hugo \u0026 loveit \u0026 github page 驱动 https://blog.gethin.online 摘要 博客3.0 基于 hugo 建站，主题采用了loveit，github action 作为 CI/CD，托管于github page。 gatsby 始终还是太重了，而且升级难度太大，依赖的包太多。强大也是强大的，折腾也是真折腾。人生有限，所以还是调整了策略，把博客迁移到hugo上，还是站在巨人的肩膀上才能做更多的事情。 摘要 2021-6-3 | 添加赞赏、网站分析、版权等功能 2021-5-28 | 添加时间轴、脑图、文章加密等功能 2021-5-17 | 添加背景图片 2021-5-16 | 添加顶部菜单 2021-5-12 | 添加测试文章 2021-5-11 | 集成搜索自动化 2021-5-10 | 添加评论，搜索 2021-5-6 | 集成Github Action 2021-5-5 | 建站 2021 function non0plural(number, name) { if (number == 0) { return \"\" } if (number == 1 || number == -1) { return number + \" \" +name } return number + \" \" + name + \"s\" } el = document.querySelector(\"#moment\"); function refresh() { start = dayjs(\"2021-05-05\") now = dayjs() total_months = now.diff(start, \"M\", true) months = total_months % 12 let years = 0 if (months BLOG 2.0 1 years ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:1","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"},{"categories":null,"content":"个人博客2.0 由 gatsby \u0026 tinacms \u0026 netlify 驱动 https://gethin.online 摘要 博客2.0 基于 gatsby 建站，主题采用了tinacms，netlify 作为 CI/CD，托管于netlify。 之前的基于react gatsby 引擎，依托于aks，个人维护精力有限，实在踩不起 19年 azure k8s 的那些坑。所以决定对网站进行升级，并托管于netlify。目前网站仍然保留。 2020 BLOG 1.0 10 months ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:2","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"},{"categories":null,"content":"个人博客1.0 由 gatsby \u0026 AKS 驱动 https://gethin.online 摘要 博客1.0 基于 gatsby 建站，自建主题，Azure DEVOPS 作为 CI/CD，托管于自建AKS。 2019年底个人博客建站，托管于自建AKS，使用Azure DEVOPS 作为CI/CD。博客用于总结个人技术，专注云原生，kubernetes，python 等技术。 2019 ","date":"0001-01-01","objectID":"https://blog.gethin.online/milestone/:1:3","tags":null,"title":"里程碑","uri":"https://blog.gethin.online/milestone/"}]