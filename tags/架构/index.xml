<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>架构 - 标签 - Gethin</title><link>https://blog.gethin.online/tags/%E6%9E%B6%E6%9E%84/</link><description>架构 - 标签 - Gethin</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 16 Aug 2021 10:52:39 +0800</lastBuildDate><atom:link href="https://blog.gethin.online/tags/%E6%9E%B6%E6%9E%84/" rel="self" type="application/rss+xml"/><item><title>软件架构模式</title><link>https://blog.gethin.online/software-architecture-pattern/</link><pubDate>Mon, 16 Aug 2021 10:52:39 +0800</pubDate><author>xxxx</author><guid>https://blog.gethin.online/software-architecture-pattern/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/content.jpg" referrerpolicy="no-referrer">
            </div><h2 id="应用场景">应用场景</h2>
<h3 id="单体架构">单体架构</h3>
<ul>
<li>好处
<ul>
<li>容易理解、开发、测试</li>
<li>容易部署</li>
<li>合适小范围项目</li>
</ul>
</li>
<li>不足
<ul>
<li>紧密耦合</li>
<li>容易产生复杂代码</li>
<li>所有子域都一刀切</li>
</ul>
</li>
</ul>
<h3 id="n-tier">N-tier</h3>
<ul>
<li>Summary
<ul>
<li>多层次</li>
<li>层适合特殊的任务</li>
<li>层可以在物理上分离</li>
<li>技术层并不是逻辑上的层</li>
<li>技术边界分层</li>
</ul>
</li>
<li>Typical: 3层架构
<ul>
<li>显示层(UI &amp; 单纯的UI逻辑)</li>
<li>逻辑层(业务逻辑)</li>
<li>数据层</li>
</ul>
</li>
<li>Advantages
<ul>
<li>开发独立</li>
<li>易扩展</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>改动会影响各个层级</li>
</ul>
</li>
</ul>
<h3 id="service-oriented">Service-Oriented</h3>
<ul>
<li>Summary
<ul>
<li>多服务</li>
<li>每个服务都是一个业务活动</li>
<li>服务可以组合</li>
<li>协议统一标准</li>
<li>企业服务总线</li>
</ul>
</li>
<li>Advantages
<ul>
<li>服务是松散耦合的</li>
<li>可扩展性好</li>
<li>没有功能重复</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>降低敏捷性和团队自主性</li>
<li>费用比较高</li>
<li>会有许多不同的观点</li>
</ul>
</li>
</ul>
<h3 id="microservices">Microservices</h3>
<ul>
<li>Summary
<ul>
<li>多服务</li>
<li>每个服务都是一个业务活动</li>
<li>以团队形式提供服务</li>
<li>没有重逻辑的企业总线</li>
<li>自动化最大化</li>
</ul>
</li>
<li>Advantages
<ul>
<li>服务是松散耦合的，易于扩展</li>
<li>灵活性高</li>
<li>可靠性高</li>
<li>设计了故障处理机制</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>边界并不总是清晰的</li>
<li>交互可能会变得很复杂</li>
</ul>
</li>
</ul>
<h3 id="serverless">Serverless</h3>
<ul>
<li>Summary
<ul>
<li>Backend as a service</li>
<li>Function as a service</li>
</ul>
</li>
</ul>
<h3 id="peer-to-peer">peer-to-peer</h3>
<ul>
<li>Summary
<ul>
<li>去中心化</li>
<li>没有固定的连接</li>
<li>动态发现的</li>
</ul>
</li>
<li>Advantages
<ul>
<li>分享资源</li>
<li>节约成本</li>
<li>可缩放</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>可能存在安全问题</li>
<li>只适用于特殊场景</li>
<li>代码比较重</li>
</ul>
</li>
</ul>
<h2 id="应用程序架构模式">应用程序架构模式</h2>
<h3 id="分层">分层</h3>
<ul>
<li>Summary
<ul>
<li>显示层(UI)</li>
<li>应用层(Translation between UI &amp; busniess)</li>
<li>业务层(Business logic)</li>
<li>持久层(Code to interact with the database)</li>
<li>数据层(Data)</li>
</ul>
</li>
<li>Advantages
<ul>
<li>开发之间容易理解</li>
<li>容易组织代码</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>可能导致单体应用</li>
<li>需要撰写大量代码</li>
</ul>
</li>
</ul>
<h3 id="microkernel">Microkernel</h3>
<ul>
<li>Summary
<ul>
<li>执行任务</li>
<li>工作流</li>
<li>数据处理</li>
<li>浏览界面</li>
<li>图形设计</li>
</ul>
</li>
<li>Advantages
<ul>
<li>灵活</li>
<li>边界清晰</li>
<li>容易分组</li>
<li>运行过程中容易添加和删除功能</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>核心 API 不一定适应未来的插件</li>
<li>插件可以被信任吗</li>
<li>并不总是清楚什么是属于核心代码</li>
</ul>
</li>
</ul>
<h3 id="cqrs">CQRS</h3>
<ul>
<li>Summary
<ul>
<li>命令查询责任分离</li>
<li>2 模式: 读/查询 &amp; 写/命令</li>
<li>允许特定场景查询</li>
<li>有同步要求</li>
<li>与事件源模式不同</li>
</ul>
</li>
<li>Advantages
<ul>
<li>容易查询</li>
<li>更快、更可扩展的读取查询</li>
<li>更容易对接</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>添加数据比较复杂</li>
<li>有学习曲线</li>
<li>可能数据不一致</li>
<li>最终一致性</li>
</ul>
</li>
</ul>
<h3 id="event-sourcing">Event sourcing</h3>
<ul>
<li>Summary
<ul>
<li>存储事件而不是当前状态</li>
<li>Event = 发生在过去的事情</li>
<li>Rehydration or replay</li>
</ul>
</li>
<li>Advantages
<ul>
<li>跟踪事件</li>
<li>数据轨迹</li>
<li>业务语言</li>
<li>事件重演</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>重演事件 和 外部系统</li>
<li>事件结构的变化</li>
<li>快照</li>
</ul>
</li>
</ul>
<h3 id="cqrs-and-event-sourcing-combined">CQRS and Event sourcing combined</h3>
<ul>
<li>Summary
<ul>
<li>2个不同的概念</li>
<li>强强联合</li>
<li>它不适用于简单的域，您可以从事件溯源开始，然后再添加 CQRS。</li>
</ul>
</li>
<li>Advantages
<ul>
<li>简单快速查询</li>
<li>可扩展的</li>
<li>事件跟踪</li>
<li>数据轨迹</li>
<li>商业语言</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>增加复杂度</li>
<li>学习曲线</li>
<li>数据不一致</li>
<li>事件结构变化</li>
</ul>
</li>
</ul>
<h2 id="ui-patterns">UI Patterns</h2>
<h3 id="mvc">MVC</h3>
<ul>
<li>Summary
<ul>
<li>Controller</li>
<li>Model</li>
<li>View</li>
</ul>
</li>
<li>Advantages
<ul>
<li>关注点分离</li>
<li>并行开发</li>
<li>流行的框架</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>控制器可能会变得臃肿</li>
<li>不同的定义</li>
</ul>
</li>
</ul>
<h3 id="mvp">MVP</h3>
<ul>
<li>Summary
<ul>
<li>View</li>
<li>Presenter</li>
<li>Model</li>
</ul>
</li>
<li>Advantages
<ul>
<li>对桌面开发友好</li>
<li>关注点分离</li>
<li>测试性好</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>Presenter层变得臃肿</li>
<li>桌面开发不流行</li>
<li>MVVM Pattern</li>
</ul>
</li>
</ul>
<h3 id="mvvm">MVVM</h3>
<ul>
<li>Summary
<ul>
<li>View</li>
<li>ViewModel</li>
<li>Model</li>
</ul>
</li>
<li>Advantages
<ul>
<li>现代桌面和移动开发友好</li>
<li>关注点分离</li>
<li>测试性好</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>UI过度</li>
<li>难以调试</li>
<li>桌面开发不流行</li>
</ul>
</li>
</ul>]]></description></item><item><title>软件架构设计</title><link>https://blog.gethin.online/software-architecture-design/</link><pubDate>Sat, 29 May 2021 21:01:34 +0800</pubDate><author>xxxx</author><guid>https://blog.gethin.online/software-architecture-design/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/content.jpg" referrerpolicy="no-referrer">
            </div><h2 id="1-软件架构概述">1 软件架构概述</h2>
<h3 id="11-软件架构的定义">1.1 软件架构的定义</h3>
<p>架构是对系统的抽象，由多个架构组成，任何软件都存在架构，元素与其行为的集合构成架构内容，架构具有“基础性”，架构隐含有“决策”。</p>
<h3 id="12-软件架构重要性">1.2 软件架构重要性</h3>
<p>项目关系人之间交流平台；<br>
早期设计决策；<br>
在较高层面上实现软件复用；<br>
架构对开发的指导与规范意义不容忽略。</p>
<h3 id="13-架构的模型">1.3 架构的模型</h3>
<p>结构模型；框架模型；动态模型；过程模型；功能模型；<br>
逻辑视图，开发视图，进程视图，物理视图，场景。</p>
<h2 id="2-架构需求与软件质量属性">2 架构需求与软件质量属性</h2>
<h3 id="21-软件质量属性">2.1 软件质量属性</h3>
<p><strong>功能性；可靠性；易用性；效率；可维护性；可移植性；</strong></p>
<ul>
<li>
<p>1 运行期质量属性<br>
<strong>性能；安全性；易用性；可伸缩性；互操作性；可靠性；持续可用性；鲁棒性；</strong></p>
</li>
<li>
<p>2 开发期质量属性<br>
<strong>易理解性；可扩展性；可重用性；可测试性；可维护性；</strong></p>
</li>
</ul>
<h3 id="22-六个质量属性与实现">2.2 六个质量属性与实现</h3>
<p>质量属性：<strong>可用性；可修改性；性能；安全性；可测试性；易用性；</strong></p>
<p>质量属性场景组件：<strong>刺激源；刺激；环境；制品；响应；响应度量；</strong></p>
<ul>
<li>1 <strong>可用性与其实现战术</strong><br>
可用性描述<br>
可用性战术<br>
错误检测：命令/响应；心跳；异常；<br>
错误恢复<br>
表决；主动冗余；被动冗余；备件；状态再同步；检查点/回滚；<br>
错误预防<br>
从服务中删除；事务；进程监视器；</li>
<li>2 <strong>可修改性与其实现战术</strong><br>
可修改性描述<br>
可修改性战术<br>
局部化修改；(维持语义的一致性；预期期望的变更；泛化该模块；限制可能的选择)<br>
防止连锁反应；（信息隐藏；维持现有的接口；限制通信路径；仲裁者的使用）<br>
推迟绑定时间；（运行时注册；配置文件；多态；构件更换；）</li>
<li>3 <strong>性能与其实现技术</strong><br>
性能描述<br>
性能战术<br>
资源消耗：闭锁时间；<br>
资源需求：减少处理事件流所需的资源；减少所处理事件的数量；控制资源的使用；<br>
资源管理：引入并发；维持数据或计算的多个副本；增加可用资源；<br>
资源仲裁：先进先出；固定优先级调度；动态优先级调度；静态调度；</li>
<li>4 <strong>安全性与其实现技术</strong><br>
安全性描述<br>
安全性战术<br>
抵抗攻击：对用户进行身份验证；对用户进行授权；维护数据的机密性；维护完整性；限制暴露的信息；限制访问；<br>
检测攻击<br>
从攻击中恢复：恢复；识别攻击者；</li>
<li>5 <strong>可测试性与其实现战术</strong><br>
可测试性描述<br>
可测试性战术<br>
输入/输出：记录回放；将接口与现实分离；优化访问线路<br>
内部监控</li>
<li>6 <strong>易用性与实现战术</strong><br>
易用性描述<br>
易用性战术<br>
运行时战术：任务的模型；用户的模型；系统的模型；<br>
设计时战术<br>
支持用户主动操作</li>
</ul>
<p>常见的六个质量属性:<strong>可用性、可修改性、性能、安全性、可测试性、易用性。</strong></p>]]></description></item></channel></rss>