<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>数据 - 标签 - Gethin</title><link>https://blog.gethin.online/tags/%E6%95%B0%E6%8D%AE/</link><description>数据 - 标签 - Gethin</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 27 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.gethin.online/tags/%E6%95%B0%E6%8D%AE/" rel="self" type="application/rss+xml"/><item><title>海量数据优化笔记</title><link>https://blog.gethin.online/massive-data-optimization-notes/</link><pubDate>Mon, 27 Apr 2020 00:00:00 +0000</pubDate><author>xxxx</author><guid>https://blog.gethin.online/massive-data-optimization-notes/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/content.jpg" referrerpolicy="no-referrer">
            </div><h2 id="海量数据优化">海量数据优化</h2>
<h3 id="1-合理使用索引">1. 合理使用索引</h3>
<p>索引是数据库中重要的数据结构，它的根本目的就是为了提高查询效率。现在大多数的数据库产品都采用 IBM 最先提出的 ISAM 索引结构。索引的使用要恰到好处，其使用原则如下：</p>
<ul>
<li>在经常进行连接，但是没有指定为外键的列上建立索引，而不经常连接的字段则由优化器自动生成索引。</li>
<li>在频繁进行排序或分组（即进行 group by 或 order by 操作）的列上建立索引。</li>
<li>在条件表达式中经常用到的不同值较多的列上建立检索，在不同值少的列上不要建立索引。比如在雇员表的“性别”列上只有“男”与“女”两个不同值，因此就无必要建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。</li>
<li>如果待排序的列有多个，可以在这些列上建立复合索引（compound index）。</li>
<li>使用系统工具。如 Informix 数据库有一个 tbcheck 工具，可以在可疑的索引上进行检查。在一些数据库服务器上，索引可能失效或者因为频繁操作而使得读取效率降低，如果一个使用索引的查询不明不白地慢下来，可以试着用 tbcheck 工具检查索引的完整性，必要时进行修复。另外，当数据库表更新大量数据后，删除并重建索引可以提高查询速度。</li>
</ul>
<h3 id="2-避免或简化排序">2. 避免或简化排序</h3>
<p>应当简化或避免对大型表进行重复的排序。当能够利用索引自动以适当的次序产生输出时，优化器就避免了排序的步骤。以下是一些影响因素：</p>
<ul>
<li>索引中不包括一个或几个待排序的列；</li>
<li>group by 或 order by 子句中列的次序与索引的次序不一样；</li>
<li>排序的列来自不同的表。</li>
</ul>
<p>为了避免不必要的排序，就要正确地增建索引，合理地合并数据库表（尽管有时可能影响表的规范化，但相对于效率的提高是值得的）。如果排序不可避免，那么应当试图简化它，如缩小排序的列的范围等。</p>
<h3 id="3-消除对大型表行数据的顺序存取">3. 消除对大型表行数据的顺序存取</h3>
<p>在嵌套查询中，对表的顺序存取对查询效率可能产生致命的影响。比如采用顺序存取策略，一个嵌套 3 层的查询，如果每层都查询 1000 行，那么这个查询就要查询 10 亿行数据。避免这种情况的主要方法就是对连接的列进行索引。<br>
例如，两个表：学生表（学号、姓名、年龄……）和选课表（学号、课程号、成绩）。如果两个表要做连接，就要在“学号”这个连接字段上建立索引。<br>
还可以使用并集来避免顺序存取。尽管在所有的检查列上都有索引，但某些形式的 where 子句强迫优化器使用顺序存取。下面的查询将强迫对 orders 表执行顺序操作：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-sql">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="复制到剪贴板"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="p">(</span><span class="n">customer_num</span><span class="o">=</span><span class="mi">104</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">order_num</span><span class="o">&gt;</span><span class="mi">1001</span><span class="p">)</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">order_num</span><span class="o">=</span><span class="mi">1008</span></span></span></code></pre></div></div>
<p>虽然在 customer_num 和 order_num 上建有索引，但是在上面的语句中优化器还是使用顺序存取路径扫描整个表。因为这个语句要检索的是分离的行的集合，所以应该改为如下语句：</p>]]></description></item></channel></rss>