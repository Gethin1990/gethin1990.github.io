<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>设计模式 - 标签 - Gethin</title><link>https://blog.gethin.online/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>设计模式 - 标签 - Gethin</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 15 Aug 2021 15:10:00 +0800</lastBuildDate><atom:link href="https://blog.gethin.online/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="self" type="application/rss+xml"/><item><title>设计模式</title><link>https://blog.gethin.online/design-pattern/</link><pubDate>Sun, 15 Aug 2021 15:10:00 +0800</pubDate><author>作者</author><guid>https://blog.gethin.online/design-pattern/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/content.jpg" referrerpolicy="no-referrer">
            </div><h2 id="设计模式六大原则">设计模式六大原则</h2>
<ul>
<li>
<p><strong>单一职责原则</strong> Single Responsibility Principle</p>
<p>一个类只负责一个功能领域中的相应职责，或者就一个类而言，应该只有一个引起它变化的原因。</p>
</li>
<li>
<p><strong>开放封闭原则</strong> Open-Close Priciple</p>
<p>一个软件实体应当对扩展开放，对修改封闭。软件实体应该尽量在不修改原有代码的情况下进行扩展。</p>
</li>
<li>
<p><strong>里氏替换原则</strong> Liskove Substitution Principe</p>
<p>所有引用基类的地方必须能透明的使用其子类的对象。（在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物）</p>
</li>
<li>
<p><strong>依赖倒置原则</strong> Dependency Inversion Principle</p>
<p>抽象不应该依赖于细节，细节应该依赖于抽象，要针对接口编程，而不是针对实现编程。（依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象）</p>
</li>
<li>
<p><strong>接口隔离原则</strong> Interface Segregation Principle</p>
<p>使用多个专用接口，而不是使用单一的总接口，客户端不应该依赖于那些它不需要的接口。</p>
</li>
<li>
<p><strong>迪米特法则</strong> Law of Demeter</p>
<p>一个软件实体应当尽可能少的与其他实体发生互相作用（<em>高内聚，低耦合</em>）。</p>
</li>
</ul>
<h2 id="为什么要多用组合少用继承">为什么要多用组合，少用继承</h2>
<p>变化部分取出并封装起来，便于以后扩展，而不影响其他部分。要针对接口编程而不是针对实现编程。</p>
<h2 id="一句话常用设计模式">一句话常用设计模式</h2>
<ol>
<li>Iterator——迭代器</li>
<li>Adapter（适配器）————换个包装再度利用</li>
</ol>
<p>◎ 万事交给子类：</p>
<ol>
<li>Template Method（模板方法）————实际处理就交给子类</li>
<li>Factory Method（工厂方法）————建立对象实例交给子类</li>
</ol>
<p>◎建立对象实例</p>
<ol>
<li>Singleton（单件）————唯一的对象实例</li>
<li>Prototype（原型）————复制建立对象实例</li>
<li>Builder（生成器）————组合复杂的对象实例</li>
<li>Abstract Factory（抽象工厂）————把相关零件组合成产品</li>
</ol>
<p>◎切割性思考</p>
<ol>
<li>Bridge（桥接）————分成功能层次和实现层次</li>
<li>Strategy（策略）————把算法整个换掉</li>
</ol>
<p>◎一视同仁</p>
<ol>
<li>Composite（组成）————对容器和内容一视同仁</li>
<li>Decorator（装饰）————对装饰和内容一视同仁</li>
</ol>
<p>◎在结构中穿梭来去</p>
<ol>
<li>Visitor（访问者）————在结构中穿梭还同时做事</li>
<li>Chain of Responsibility（职责链）————责任转送</li>
</ol>
<p>◎简单最好</p>
<ol>
<li>Facade（外观）————单一窗口</li>
<li>Mediator（中介者）————只要面对一个顾问</li>
</ol>
<p>◎管理状态</p>
<ol>
<li>Observer（观察者）————通知状态变化</li>
<li>Memento（备忘录）————存储状态</li>
<li>State（状态）————以类表示状态</li>
</ol>
<p>◎精简不浪费</p>
<ol>
<li>Flyweight（享元）————有相同的部分就分享，采取精简政策</li>
<li>Proxy（代理）————要用在建立</li>
</ol>
<p>◎用类来表示</p>]]></description></item></channel></rss>