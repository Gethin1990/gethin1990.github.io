<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Dotnet - 标签 - Gethin</title><link>https://blog.gethin.online/tags/dotnet/</link><description>Dotnet - 标签 - Gethin</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 10 Aug 2021 16:09:23 +0800</lastBuildDate><atom:link href="https://blog.gethin.online/tags/dotnet/" rel="self" type="application/rss+xml"/><item><title>.NET CORE</title><link>https://blog.gethin.online/dotnet-core/</link><pubDate>Tue, 10 Aug 2021 16:09:23 +0800</pubDate><author>xxxx</author><guid>https://blog.gethin.online/dotnet-core/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/content.jpg" referrerpolicy="no-referrer">
            </div><h2 id="概述">概述</h2>
<h3 id="谈一谈对ddd的理解">谈一谈对DDD的理解</h3>
<p><strong>DDD，领域驱动设计</strong>。就是通过领域来指导软件设计，是一种十分抽象的软件设计思想，它主要分为战略设计和战术设计。</p>
<p><strong>战略方面</strong>，通过事件风暴进行领域模型的划分，划分出核心域，子域，支撑域，定义通用语言，划分出界限上下文。<br>
<strong>在战术设计方面</strong>，ddd将架构分层，“松耦合，高内聚”是架构设计的整体思想。按照DDD思想，可以分为领域层，基础设施层，应用层，接口层。</p>
<p><strong>接口层</strong>为前端用户提供api接口。基础设施层可以放一些第三方的服务，数据库连接等内容。<br>
<strong>应用层</strong>是对领域服务的编排，是很薄的一层（目前我自己的架构，应用的是cqrs，所有的相关逻辑都是放在了应用层，而领域层只是放了实体，因为暂时还不是特别理解领域层的服务和事件都应该写什么）。<br>
<strong>领域层</strong>包括实体，值对象，聚合根，领域服务，领域事件等内容。</p>
<h3 id="aspnet-core-比-aspnet-更具优势的地方是什么">ASP.NET Core 比 ASP.NET 更具优势的地方是什么</h3>
<ol>
<li>跨平台</li>
<li>对框架没有依赖</li>
<li>处理请求效率更高</li>
<li>可以自我寄宿</li>
<li>轻量高性能</li>
<li>可以使用vs；vs code进行开发</li>
</ol>
<h3 id="aspnet-core-主要的特性有哪些">ASP.NET Core 主要的特性有哪些</h3>
<ol>
<li>startup 类</li>
<li>依赖关系注入（服务）</li>
<li>中间件</li>
<li>主机</li>
<li>服务器</li>
<li>appsettings.json 配置</li>
<li>选项</li>
<li>环境（dev,stage,prod）</li>
<li>Logging</li>
<li>路由</li>
<li>处理错误</li>
<li>发送HTTP请求</li>
<li>静态文件</li>
</ol>
<h2 id="startup">Startup</h2>
<h3 id="什么是dot-net-core的startup-class">什么是dot net core的startup class</h3>
<p><strong>Startup class是dot net core应用的入口</strong>。<br>
所有的dot net core应用必须有这个class。这个类用来配置应用。<br>
这个类的调用是在program main函数里面进行配置的。类的名字可以自己定义。</p>
<h3 id="如何在controller中注入service">如何在controller中注入service</h3>
<p>ConfigureServices 添加 Service；</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cs">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="复制到剪贴板"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cs" data-lang="cs"><span class="line"><span class="cl"><span class="n">services</span><span class="p">.</span><span class="n">TryAddTransient</span><span class="p">&lt;</span><span class="n">IDataAccess</span><span class="p">,</span> <span class="n">DataAccess</span><span class="p">&gt;();</span></span></span></code></pre></div></div>
<p>在controller 添加注入</p>]]></description></item><item><title>.NET 本质论</title><link>https://blog.gethin.online/dotnet-essentialism/</link><pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate><author>xxxx</author><guid>https://blog.gethin.online/dotnet-essentialism/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/content.jpg" referrerpolicy="no-referrer">
            </div><blockquote>
<p>声明：本文仅用做复习整理知识，在下列文章中进行二次加工，大部分内容整理自：
<a href="https://www.cnblogs.com/edisonchou/p/4787775.html" target="_blank" rel="noopener noreffer ">https://www.cnblogs.com/edisonchou/p/4787775.html</a>
<a href="https://zhuanlan.zhihu.com/p/38799766" target="_blank" rel="noopener noreffer ">https://zhuanlan.zhihu.com/p/38799766</a></p></blockquote>


<div id="blueprint" class="mindmap mindmap-md">
    <ul>
<li><a href="#net-%e6%9c%ac%e8%b4%a8%e8%ae%ba" rel="">.NET 本质论</a>
<ul>
<li><a href="#net%e4%b8%ad%e6%89%80%e6%9c%89%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%9f%ba%e7%b1%bb%e6%98%af%e4%bb%80%e4%b9%88" rel="">.NET中所有类型的基类是什么</a></li>
<li><a href="#%e5%80%bc%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%8c%ba%e5%88%ab" rel="">值类型和引用类型的区别</a></li>
<li><a href="#%e8%a3%85%e7%ae%b1%e5%92%8c%e6%8b%86%e7%ae%b1%e7%9a%84%e5%8e%9f%e7%90%86" rel="">装箱和拆箱的原理</a></li>
<li><a href="#struct%e5%92%8cclass%e7%9a%84%e5%8c%ba%e5%88%abstruct%e9%80%82%e7%94%a8%e4%ba%8e%e5%93%aa%e4%ba%9b%e5%9c%ba%e5%90%88" rel="">struct和class的区别，struct适用于哪些场合</a></li>
<li><a href="#c%e4%b8%ad%e6%96%b9%e6%b3%95%e7%9a%84%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e6%96%b9%e5%bc%8f" rel="">C#中方法的参数传递有哪几种方式</a></li>
<li><a href="#%e6%b5%85%e5%a4%8d%e5%88%b6%e5%92%8c%e6%b7%b1%e5%a4%8d%e5%88%b6%e7%9a%84%e5%8c%ba%e5%88%ab" rel="">浅复制和深复制的区别</a></li>
<li><a href="#net%e4%b8%ad%e6%a0%88%e5%92%8c%e5%a0%86%e7%9a%84%e5%b7%ae%e5%bc%82" rel="">.NET中栈和堆的差异</a></li>
<li><a href="#%e6%89%a7%e8%a1%8cstring-abcaaabbbccc%e5%85%b1%e5%88%86%e9%85%8d%e4%ba%86%e5%a4%9a%e5%b0%91%e5%86%85%e5%ad%98" rel="">执行string abc=&ldquo;aaa&rdquo;+&ldquo;bbb&rdquo;+&ldquo;ccc&quot;共分配了多少内存</a></li>
<li><a href="#%e6%89%98%e7%ae%a1%e5%a0%86%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d" rel="">托管堆内存分配</a></li>
<li><a href="#%e7%ae%80%e8%a6%81%e8%af%b4%e8%af%b4net%e4%b8%adgc%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6" rel="">简要说说.NET中GC的运行机制</a></li>
<li><a href="#gc%e6%9c%ba%e5%88%b6%e4%b8%ad%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e4%b8%80%e4%b8%aa%e5%af%b9%e8%b1%a1%e4%bb%8d%e7%84%b6%e5%9c%a8%e8%a2%ab%e4%bd%bf%e7%94%a8%e5%a6%82%e4%bd%95%e6%a0%87%e8%ae%b0" rel="">GC机制中如何判断一个对象仍然在被使用（如何标记）</a></li>
<li><a href="#gc%e4%b8%ad%e4%bb%a3generation%e6%98%af%e4%bb%80%e4%b9%88%e5%88%86%e4%b8%ba%e5%87%a0%e4%bb%a3%e5%a6%82%e4%bd%95%e7%a7%bb%e5%8a%a8" rel="">GC中代（Generation）是什么，分为几代（如何移动）</a></li>
<li><a href="#gc%e6%9c%89%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98" rel="">GC有什么问题</a></li>
<li><a href="#%e6%89%98%e7%ae%a1%e4%b8%8e%e9%9d%9e%e6%89%98%e7%ae%a1%e8%b5%84%e6%ba%90%e6%98%af%e4%bb%80%e4%b9%88" rel="">托管与非托管资源是什么</a>
<ul>
<li><a href="#%e6%89%98%e7%ae%a1%e8%b5%84%e6%ba%90" rel="">托管资源</a></li>
<li><a href="#%e9%9d%9e%e6%89%98%e7%ae%a1%e8%b5%84%e6%ba%90" rel="">非托管资源</a></li>
</ul>
</li>
<li><a href="#dispose%e5%92%8cfinalize%e6%96%b9%e6%b3%95%e5%9c%a8%e4%bd%95%e6%97%b6%e8%a2%ab%e8%b0%83%e7%94%a8%e9%9d%9e%e6%89%98%e7%ae%a1%e8%b5%84%e6%ba%90%e5%9b%9e%e6%94%b6%e6%96%b9%e6%b3%95" rel="">Dispose和Finalize方法在何时被调用（非托管资源回收方法）</a></li>
<li><a href="#net%e4%b8%ad%e7%9a%84%e6%89%98%e7%ae%a1%e5%a0%86%e4%b8%ad%e6%98%af%e5%90%a6%e5%8f%af%e8%83%bd%e5%87%ba%e7%8e%b0%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2%e7%9a%84%e7%8e%b0%e8%b1%a1" rel="">.NET中的托管堆中是否可能出现内存泄露的现象</a>
<ul>
<li><a href="#%e5%a4%a7%e5%af%b9%e8%b1%a1%e7%9a%84%e5%88%86%e9%85%8d" rel="">大对象的分配</a></li>
<li><a href="#%e4%b8%8d%e6%81%b0%e5%bd%93%e5%9c%b0%e4%bf%9d%e5%ad%98%e6%a0%b9%e5%bc%95%e7%94%a8" rel="">不恰当地保存根引用</a></li>
<li><a href="#%e4%b8%8d%e6%ad%a3%e7%a1%ae%e7%9a%84finalize%e6%96%b9%e6%b3%95" rel="">不正确的Finalize方法</a></li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
<h1 id="net-本质论">.NET 本质论</h1>
<h2 id="net中所有类型的基类是什么">.NET中所有类型的基类是什么</h2>
<p>System.Object</p>
<h2 id="值类型和引用类型的区别">值类型和引用类型的区别</h2>
<p>所有继承自System.ValueType的类型是值类型，而其他类型都是引用类型。<br>
常用的值类型包括：结构、枚举、整数型、浮点型、布尔型等等。</p>
<ul>
<li>赋值时的区别
值类型的变量直接将获得一个真实的数据副本，而对引用类型的赋值仅仅是把对象的引用赋给变量，这样就可能导致多个变量引用到一个对象实例上。</li>
<li>内存分配的区别
引用类型的对象将会在堆上分配内存，而值类型的对象则会在堆栈上分配内存</li>
<li>继承结构的区别</li>
</ul>
<h2 id="装箱和拆箱的原理">装箱和拆箱的原理</h2>
<p>装箱：CLR需要做额外的工作把堆栈上的值类型移动到堆上，这个操作就被称为装箱。<br>
拆箱：装箱操作的反操作，把堆中的对象复制到堆栈中，并且返回其值。</p>
<h2 id="struct和class的区别struct适用于哪些场合">struct和class的区别，struct适用于哪些场合</h2>
<ul>
<li>struct（结构）是值类型，而class（类）是引用类型。</li>
<li>struct与class相比，不具备继承的特性</li>
<li>struct不能有无参数的构造方法（class默认就有），也不能为成员变量定义初始值。</li>
</ul>
<h2 id="c中方法的参数传递有哪几种方式">C#中方法的参数传递有哪几种方式</h2>
<ul>
<li>ref关键字：引用传递参数，需要在传递前初始化；（ref 要求参数在传入前被初始化）</li>
<li>out关键字：引用传递参数，需要在返回前初始化；（out 要求参数在方法返回前被初始化）</li>
<li>params关键字：允许方法在定义时不确定参数的数量。</li>
</ul>
<h2 id="浅复制和深复制的区别">浅复制和深复制的区别</h2>
<ul>
<li>浅复制：复制一个对象的时候，仅仅复制原始对象中所有的非静态类型成员和所有的引用类型成员的引用。（新对象和原对象将共享所有引用类型成员的实际对象）</li>
<li>深复制：复制一个对象的时候，不仅复制所有非静态类型成员，还要复制所有引用类型成员的实际对象。</li>
</ul>
<h2 id="net中栈和堆的差异">.NET中栈和堆的差异</h2>
<ul>
<li>.NET 中的栈
堆栈用来存储值类型的对象和引用类型对象的引用（地址），其分配的是一块连续的地址，堆栈上的地址从高位向低位分配内存。</li>
</ul>
<p></p>]]></description></item></channel></rss>