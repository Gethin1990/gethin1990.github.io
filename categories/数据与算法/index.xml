<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>数据与算法 - 分类 - Gethin</title><link>https://blog.gethin.online/categories/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%AE%97%E6%B3%95/</link><description>数据与算法 - 分类 - Gethin</description><generator>Hugo -- gohugo.io</generator><managingEditor>gexu1990@hotmail.com (Gethin)</managingEditor><webMaster>gexu1990@hotmail.com (Gethin)</webMaster><lastBuildDate>Sat, 05 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.gethin.online/categories/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml"/><item><title>[转载]C#重构经典全面汇总</title><link>https://blog.gethin.online/refactoring-reprinted/</link><pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://blog.gethin.online/refactoring-reprinted/</guid><description><![CDATA[<div class="featured-image">
                <img src="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/refactoring-reprinted-2021-06-05-19-34-07.jpg" referrerpolicy="no-referrer">
            </div>1. 封装集合  概念：本文所讲的封装集合就是把集合进行封装，只提供调用端需要的接口。
正文：在很多时候，我们都不希望把一些不必要的操作暴露给调用端，只需要给它所需要的操作或数据就行，那么做法就是封装。这个重构在微软的代码库也经常遇到。比如最经典的属性对字段的封装就是一个很好的例子，那么下面我们将看到对集合的封装，如下代码所示，调用端只需要一个集合的信息，而我们则提供了一个IList的集合，大家都知道IList具有对集合的所有操作，所以这会带来很多隐患，最好的做法就是对它进行重构。
那么重构之后，我们把IList换成了IEnumerable，大家都知道只包括一个返回值为IEnumerator的GetEnumerator()方法，所以这样只能遍历取出它的值，而不能对这个集合做出改变，这正是我们所需要的结果，具体代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  using System.Collections.Generic; namespace LosTechies.DaysOfRefactoring.EncapsulateCollection.Before { public class Order { private List&lt;OrderLine&gt; _orderLines; private double _orderTotal; public IList&lt;OrderLine&gt; OrderLines { get { return _orderLines; } } public void AddOrderLine(OrderLine orderLine) { _orderTotal += orderLine.]]></description></item><item><title>算法</title><link>https://blog.gethin.online/algorthm/</link><pubDate>Mon, 08 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>https://blog.gethin.online/algorthm/</guid><description>&lt;div class="featured-image">
&lt;img src="/images/content.jpg" referrerpolicy="no-referrer">
&lt;/div>这个篇文章主要是算法学习大纲。
主要参考 https://github.com/youngyangyang04/leetcode-master 的学习路线，标号||均为leetcode题号。
算法 数组 二分查找 搜索插入位置|35| 双指针 移除元素|27| 滑动窗口 长度最小的子数组|209| 链表 链表的理论 链表的种类 链表的存储方式 链表操作 数组和链表在不同场景下的性能分析 链表的经典题目 虚拟头节点(哨兵节点) 链表的基本操作 反转链表 环形链表 哈希表 哈希表介绍 哈希函数 哈希碰撞 常见的三种哈希结构 数组作为哈希表 set作为哈希表 map作为哈希表 字符串 什么是字符串 要不要使用库函数 双指针法、反转系列 KMP 栈和队列 栈与队列的理论基础 栈经典题目 栈在系统中的应用 括号匹配问题 字符串去重问题 逆波兰表达式问题 队列的经典题目 滑动窗口最大值问题 求前 K 个高频元素 二叉树 二叉树的遍历方式 前序遍历|144| 中序遍历|145| 后序遍历|94| 层级遍历|102| 二叉树的属性 对称二叉树|101| 二叉树最大深度|104| 二叉树最小深度|111| 完全二叉树的节点个数|222| 平衡二叉树|110| 二叉树的所有路径|157| 左叶子之和|404| 找树左下角的值|513| 路径总和|112| 二叉树的修改与构造 翻转二叉树|226| 从中序与后续遍历序列构造二叉树|106| 最大二叉树|654| 合并二叉树|617| 求二叉搜索树的属性 二叉搜索树中的搜索|700| 验证二叉搜索树|98| 二叉搜索树的最小绝对差|530| 二叉搜索树中的众数|501| 把二叉搜索树转换为累加树|538| 二叉树公共祖先问题 二叉树的最近公共祖先|236| 二叉搜索树的最近公共祖先|235| 二叉搜索树的修改和构造 二叉搜索树的插入操作|701| 删除二叉搜索树的节点|450| 修剪二叉搜索树|669| 将有序数组转换为二叉搜索树|108| 回溯算法 组合 组合|77| 电话号码的字母组合|17| 组合总和|39| 组合总和2|40| 组合总和3|216| 分割 分割回文串|131| 复原IP地址|93| 子集 子集|78| 子集2|90| 排列 全排列|46| 全排列2|47| 棋盘问题 N皇后|51| 解数独|37| 其他 递增子序列|491| 重新安排行程|332| 贪心算法 理论基础 简单题目 分发饼干|455| K次取反后最大化的数组和|1005| 柠檬水找零|860| 序列问题 摆动序列|376| 单调递增的数字|738| 股票问题 买卖股票的最佳时机|122| 买卖股票的最佳时机含手续费|714| 两个维度权衡问题 分发糖果|135| 根据身高重建队列|406| 区间问题 跳跃游戏|55| 跳跃游戏2|45| 用最少数量的箭引爆气球|452| 五重叠区间|435| 划分字母区间|763| 合并区间|56| 其他问题 最大子序和|53| 加油站|134| 监控二叉树|968| 动态规划 算法 数组 二分查找 搜索插入位置|35| 双指针 移除元素|27| 滑动窗口 长度最小的子数组|209| 链表 链表的理论 链表的种类 单链表、双链表、循环链表</description></item><item><title>海量数据优化笔记</title><link>https://blog.gethin.online/massive-data-optimization-notes/</link><pubDate>Mon, 27 Apr 2020 00:00:00 +0000</pubDate><author>作者</author><guid>https://blog.gethin.online/massive-data-optimization-notes/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/content.jpg" referrerpolicy="no-referrer">
            </div>海量数据优化 1. 合理使用索引 索引是数据库中重要的数据结构，它的根本目的就是为了提高查询效率。现在大多数的数据库产品都采用 IBM 最先提出的 ISAM 索引结构。索引的使用要恰到好处，其使用原则如下：
 在经常进行连接，但是没有指定为外键的列上建立索引，而不经常连接的字段则由优化器自动生成索引。 在频繁进行排序或分组（即进行 group by 或 order by 操作）的列上建立索引。 在条件表达式中经常用到的不同值较多的列上建立检索，在不同值少的列上不要建立索引。比如在雇员表的“性别”列上只有“男”与“女”两个不同值，因此就无必要建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。 如果待排序的列有多个，可以在这些列上建立复合索引（compound index）。 使用系统工具。如 Informix 数据库有一个 tbcheck 工具，可以在可疑的索引上进行检查。在一些数据库服务器上，索引可能失效或者因为频繁操作而使得读取效率降低，如果一个使用索引的查询不明不白地慢下来，可以试着用 tbcheck 工具检查索引的完整性，必要时进行修复。另外，当数据库表更新大量数据后，删除并重建索引可以提高查询速度。  2. 避免或简化排序 应当简化或避免对大型表进行重复的排序。当能够利用索引自动以适当的次序产生输出时，优化器就避免了排序的步骤。以下是一些影响因素：
 索引中不包括一个或几个待排序的列； group by 或 order by 子句中列的次序与索引的次序不一样； 排序的列来自不同的表。  为了避免不必要的排序，就要正确地增建索引，合理地合并数据库表（尽管有时可能影响表的规范化，但相对于效率的提高是值得的）。如果排序不可避免，那么应当试图简化它，如缩小排序的列的范围等。
3. 消除对大型表行数据的顺序存取 在嵌套查询中，对表的顺序存取对查询效率可能产生致命的影响。比如采用顺序存取策略，一个嵌套 3 层的查询，如果每层都查询 1000 行，那么这个查询就要查询 10 亿行数据。避免这种情况的主要方法就是对连接的列进行索引。
例如，两个表：学生表（学号、姓名、年龄……）和选课表（学号、课程号、成绩）。如果两个表要做连接，就要在“学号”这个连接字段上建立索引。
还可以使用并集来避免顺序存取。尽管在所有的检查列上都有索引，但某些形式的 where 子句强迫优化器使用顺序存取。下面的查询将强迫对 orders 表执行顺序操作：
1  SELECT * FROM orders WHERE (customer_num=104 AND order_num&gt;1001) OR order_num=1008   虽然在 customer_num 和 order_num 上建有索引，但是在上面的语句中优化器还是使用顺序存取路径扫描整个表。因为这个语句要检索的是分离的行的集合，所以应该改为如下语句：]]></description></item></channel></rss>