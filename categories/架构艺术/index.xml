<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>架构艺术 - 分类 - Gethin</title><link>https://blog.gethin.online/categories/%E6%9E%B6%E6%9E%84%E8%89%BA%E6%9C%AF/</link><description>架构艺术 - 分类 - Gethin</description><generator>Hugo -- gohugo.io</generator><managingEditor>gexu1990@hotmail.com (Gethin)</managingEditor><webMaster>gexu1990@hotmail.com (Gethin)</webMaster><lastBuildDate>Wed, 23 Jun 2021 20:18:17 +0800</lastBuildDate><atom:link href="https://blog.gethin.online/categories/%E6%9E%B6%E6%9E%84%E8%89%BA%E6%9C%AF/" rel="self" type="application/rss+xml"/><item><title>UML设计与基本概念</title><link>https://blog.gethin.online/uml-design/</link><pubDate>Wed, 23 Jun 2021 20:18:17 +0800</pubDate><author>作者</author><guid>https://blog.gethin.online/uml-design/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/content.jpg" referrerpolicy="no-referrer">
            </div>UML 的各种图 UML 又称为统一建模语言，是为面向对象开发系统进行说明、可视化的一种标准语言。
UML 的分类如下：
 UML  用例视图  用例图   设计视图  类图 对象图   进程视图  时序图 协作图 状态图 活动图   实现视图  构件图   拓扑视图  部署图       用例图 类图 类图是描述类与类之间的关系，在类图里有常见的六种关系。分别是泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)
各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖
 泛化（一种继承关系）
例如：动物 -&gt; 老虎
 实现（类与接口的关系，表示接口的实现）
例如：鸟 -&gt; 燕子
 聚合（部分和整体的关系，但部分可以脱离整体单独存在）]]></description></item><item><title>[转载]Redis面试题</title><link>https://blog.gethin.online/redis-reprinted/</link><pubDate>Fri, 04 Jun 2021 21:06:39 +0800</pubDate><author>作者</author><guid>https://blog.gethin.online/redis-reprinted/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/redis-2021-06-04-21-41-23.jpg" referrerpolicy="no-referrer">
&lt;/div>概述 什么是Redis Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。
Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。
与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。
Redis有哪些优缺点 优点
读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。 支持数据持久化，支持AOF和RDB两种持久化方式。 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。 数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。 缺点
数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。 Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。 为什么要用 Redis /为什么要用缓存 主要从“高性能”和“高并发”这两点来看待这个问题。
高性能：
假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
高并发：
直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。
为什么要用 Redis 而不用 map/guava 做缓存? 缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。</description></item><item><title>[转载]消息中间件MQ与RabbitMQ面试题</title><link>https://blog.gethin.online/rabbitmq-reprinted/</link><pubDate>Fri, 04 Jun 2021 10:58:43 +0800</pubDate><author>作者</author><guid>https://blog.gethin.online/rabbitmq-reprinted/</guid><description>&lt;div class="featured-image">
&lt;img src="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/RabbitMQ-2021-06-04-13-49-43.jpg" referrerpolicy="no-referrer">
&lt;/div>为什么使用MQ？MQ的优点 简答
异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。 流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。 日志处理 - 解决大量日志传输。 消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。 详答
主要是：解耦、异步、削峰。
解耦：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。
就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。
异步：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。</description></item><item><title>软件架构设计</title><link>https://blog.gethin.online/software-architecture-design/</link><pubDate>Sat, 29 May 2021 21:01:34 +0800</pubDate><author>作者</author><guid>https://blog.gethin.online/software-architecture-design/</guid><description>&lt;div class="featured-image">
&lt;img src="/images/content.jpg" referrerpolicy="no-referrer">
&lt;/div>1 软件架构概述 1.1 软件架构的定义 架构是对系统的抽象，由多个架构组成，任何软件都存在架构，元素与其行为的集合构成架构内容，架构具有“基础性”，架构隐含有“决策”。
1.2 软件架构重要性 项目关系人之间交流平台；
早期设计决策；
在较高层面上实现软件复用；
架构对开发的指导与规范意义不容忽略。
1.3 架构的模型 结构模型；框架模型；动态模型；过程模型；功能模型；
逻辑视图，开发视图，进程视图，物理视图，场景。
2 架构需求与软件质量属性 2.1 软件质量属性 功能性；可靠性；易用性；效率；可维护性；可移植性；
1 运行期质量属性
性能；安全性；易用性；可伸缩性；互操作性；可靠性；持续可用性；鲁棒性；
2 开发期质量属性
易理解性；可扩展性；可重用性；可测试性；可维护性；
2.2 六个质量属性与实现 质量属性：可用性；可修改性；性能；安全性；可测试性；易用性；
质量属性场景组件：刺激源；刺激；环境；制品；响应；响应度量；
1 可用性与其实现战术
可用性描述
可用性战术
错误检测：命令/响应；心跳；异常；
错误恢复
表决；主动冗余；被动冗余；备件；状态再同步；检查点/回滚；
错误预防
从服务中删除；事务；进程监视器； 2 可修改性与其实现战术
可修改性描述
可修改性战术
局部化修改；(维持语义的一致性；预期期望的变更；泛化该模块；限制可能的选择)
防止连锁反应；（信息隐藏；维持现有的接口；限制通信路径；仲裁者的使用）
推迟绑定时间；（运行时注册；配置文件；多态；构件更换；） 3 性能与其实现技术
性能描述
性能战术
资源消耗：闭锁时间；
资源需求：减少处理事件流所需的资源；减少所处理事件的数量；控制资源的使用；
资源管理：引入并发；维持数据或计算的多个副本；增加可用资源；
资源仲裁：先进先出；固定优先级调度；动态优先级调度；静态调度； 4 安全性与其实现技术
安全性描述
安全性战术
抵抗攻击：对用户进行身份验证；对用户进行授权；维护数据的机密性；维护完整性；限制暴露的信息；限制访问；
检测攻击
从攻击中恢复：恢复；识别攻击者； 5 可测试性与其实现战术</description></item></channel></rss>