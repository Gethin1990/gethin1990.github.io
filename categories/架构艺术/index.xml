<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>架构艺术 - 分类 - Gethin</title><link>https://blog.gethin.online/categories/%E6%9E%B6%E6%9E%84%E8%89%BA%E6%9C%AF/</link><description>架构艺术 - 分类 - Gethin</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 16 Aug 2021 10:52:39 +0800</lastBuildDate><atom:link href="https://blog.gethin.online/categories/%E6%9E%B6%E6%9E%84%E8%89%BA%E6%9C%AF/" rel="self" type="application/rss+xml"/><item><title>软件架构模式</title><link>https://blog.gethin.online/software-architecture-pattern/</link><pubDate>Mon, 16 Aug 2021 10:52:39 +0800</pubDate><author>xxxx</author><guid>https://blog.gethin.online/software-architecture-pattern/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/content.jpg" referrerpolicy="no-referrer">
            </div><h2 id="应用场景">应用场景</h2>
<h3 id="单体架构">单体架构</h3>
<ul>
<li>好处
<ul>
<li>容易理解、开发、测试</li>
<li>容易部署</li>
<li>合适小范围项目</li>
</ul>
</li>
<li>不足
<ul>
<li>紧密耦合</li>
<li>容易产生复杂代码</li>
<li>所有子域都一刀切</li>
</ul>
</li>
</ul>
<h3 id="n-tier">N-tier</h3>
<ul>
<li>Summary
<ul>
<li>多层次</li>
<li>层适合特殊的任务</li>
<li>层可以在物理上分离</li>
<li>技术层并不是逻辑上的层</li>
<li>技术边界分层</li>
</ul>
</li>
<li>Typical: 3层架构
<ul>
<li>显示层(UI &amp; 单纯的UI逻辑)</li>
<li>逻辑层(业务逻辑)</li>
<li>数据层</li>
</ul>
</li>
<li>Advantages
<ul>
<li>开发独立</li>
<li>易扩展</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>改动会影响各个层级</li>
</ul>
</li>
</ul>
<h3 id="service-oriented">Service-Oriented</h3>
<ul>
<li>Summary
<ul>
<li>多服务</li>
<li>每个服务都是一个业务活动</li>
<li>服务可以组合</li>
<li>协议统一标准</li>
<li>企业服务总线</li>
</ul>
</li>
<li>Advantages
<ul>
<li>服务是松散耦合的</li>
<li>可扩展性好</li>
<li>没有功能重复</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>降低敏捷性和团队自主性</li>
<li>费用比较高</li>
<li>会有许多不同的观点</li>
</ul>
</li>
</ul>
<h3 id="microservices">Microservices</h3>
<ul>
<li>Summary
<ul>
<li>多服务</li>
<li>每个服务都是一个业务活动</li>
<li>以团队形式提供服务</li>
<li>没有重逻辑的企业总线</li>
<li>自动化最大化</li>
</ul>
</li>
<li>Advantages
<ul>
<li>服务是松散耦合的，易于扩展</li>
<li>灵活性高</li>
<li>可靠性高</li>
<li>设计了故障处理机制</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>边界并不总是清晰的</li>
<li>交互可能会变得很复杂</li>
</ul>
</li>
</ul>
<h3 id="serverless">Serverless</h3>
<ul>
<li>Summary
<ul>
<li>Backend as a service</li>
<li>Function as a service</li>
</ul>
</li>
</ul>
<h3 id="peer-to-peer">peer-to-peer</h3>
<ul>
<li>Summary
<ul>
<li>去中心化</li>
<li>没有固定的连接</li>
<li>动态发现的</li>
</ul>
</li>
<li>Advantages
<ul>
<li>分享资源</li>
<li>节约成本</li>
<li>可缩放</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>可能存在安全问题</li>
<li>只适用于特殊场景</li>
<li>代码比较重</li>
</ul>
</li>
</ul>
<h2 id="应用程序架构模式">应用程序架构模式</h2>
<h3 id="分层">分层</h3>
<ul>
<li>Summary
<ul>
<li>显示层(UI)</li>
<li>应用层(Translation between UI &amp; busniess)</li>
<li>业务层(Business logic)</li>
<li>持久层(Code to interact with the database)</li>
<li>数据层(Data)</li>
</ul>
</li>
<li>Advantages
<ul>
<li>开发之间容易理解</li>
<li>容易组织代码</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>可能导致单体应用</li>
<li>需要撰写大量代码</li>
</ul>
</li>
</ul>
<h3 id="microkernel">Microkernel</h3>
<ul>
<li>Summary
<ul>
<li>执行任务</li>
<li>工作流</li>
<li>数据处理</li>
<li>浏览界面</li>
<li>图形设计</li>
</ul>
</li>
<li>Advantages
<ul>
<li>灵活</li>
<li>边界清晰</li>
<li>容易分组</li>
<li>运行过程中容易添加和删除功能</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>核心 API 不一定适应未来的插件</li>
<li>插件可以被信任吗</li>
<li>并不总是清楚什么是属于核心代码</li>
</ul>
</li>
</ul>
<h3 id="cqrs">CQRS</h3>
<ul>
<li>Summary
<ul>
<li>命令查询责任分离</li>
<li>2 模式: 读/查询 &amp; 写/命令</li>
<li>允许特定场景查询</li>
<li>有同步要求</li>
<li>与事件源模式不同</li>
</ul>
</li>
<li>Advantages
<ul>
<li>容易查询</li>
<li>更快、更可扩展的读取查询</li>
<li>更容易对接</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>添加数据比较复杂</li>
<li>有学习曲线</li>
<li>可能数据不一致</li>
<li>最终一致性</li>
</ul>
</li>
</ul>
<h3 id="event-sourcing">Event sourcing</h3>
<ul>
<li>Summary
<ul>
<li>存储事件而不是当前状态</li>
<li>Event = 发生在过去的事情</li>
<li>Rehydration or replay</li>
</ul>
</li>
<li>Advantages
<ul>
<li>跟踪事件</li>
<li>数据轨迹</li>
<li>业务语言</li>
<li>事件重演</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>重演事件 和 外部系统</li>
<li>事件结构的变化</li>
<li>快照</li>
</ul>
</li>
</ul>
<h3 id="cqrs-and-event-sourcing-combined">CQRS and Event sourcing combined</h3>
<ul>
<li>Summary
<ul>
<li>2个不同的概念</li>
<li>强强联合</li>
<li>它不适用于简单的域，您可以从事件溯源开始，然后再添加 CQRS。</li>
</ul>
</li>
<li>Advantages
<ul>
<li>简单快速查询</li>
<li>可扩展的</li>
<li>事件跟踪</li>
<li>数据轨迹</li>
<li>商业语言</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>增加复杂度</li>
<li>学习曲线</li>
<li>数据不一致</li>
<li>事件结构变化</li>
</ul>
</li>
</ul>
<h2 id="ui-patterns">UI Patterns</h2>
<h3 id="mvc">MVC</h3>
<ul>
<li>Summary
<ul>
<li>Controller</li>
<li>Model</li>
<li>View</li>
</ul>
</li>
<li>Advantages
<ul>
<li>关注点分离</li>
<li>并行开发</li>
<li>流行的框架</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>控制器可能会变得臃肿</li>
<li>不同的定义</li>
</ul>
</li>
</ul>
<h3 id="mvp">MVP</h3>
<ul>
<li>Summary
<ul>
<li>View</li>
<li>Presenter</li>
<li>Model</li>
</ul>
</li>
<li>Advantages
<ul>
<li>对桌面开发友好</li>
<li>关注点分离</li>
<li>测试性好</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>Presenter层变得臃肿</li>
<li>桌面开发不流行</li>
<li>MVVM Pattern</li>
</ul>
</li>
</ul>
<h3 id="mvvm">MVVM</h3>
<ul>
<li>Summary
<ul>
<li>View</li>
<li>ViewModel</li>
<li>Model</li>
</ul>
</li>
<li>Advantages
<ul>
<li>现代桌面和移动开发友好</li>
<li>关注点分离</li>
<li>测试性好</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>UI过度</li>
<li>难以调试</li>
<li>桌面开发不流行</li>
</ul>
</li>
</ul>]]></description></item><item><title>设计模式</title><link>https://blog.gethin.online/design-pattern/</link><pubDate>Sun, 15 Aug 2021 15:10:00 +0800</pubDate><author>xxxx</author><guid>https://blog.gethin.online/design-pattern/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/content.jpg" referrerpolicy="no-referrer">
            </div><h2 id="设计模式六大原则">设计模式六大原则</h2>
<ul>
<li>
<p><strong>单一职责原则</strong> Single Responsibility Principle</p>
<p>一个类只负责一个功能领域中的相应职责，或者就一个类而言，应该只有一个引起它变化的原因。</p>
</li>
<li>
<p><strong>开放封闭原则</strong> Open-Close Priciple</p>
<p>一个软件实体应当对扩展开放，对修改封闭。软件实体应该尽量在不修改原有代码的情况下进行扩展。</p>
</li>
<li>
<p><strong>里氏替换原则</strong> Liskove Substitution Principe</p>
<p>所有引用基类的地方必须能透明的使用其子类的对象。（在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物）</p>
</li>
<li>
<p><strong>依赖倒置原则</strong> Dependency Inversion Principle</p>
<p>抽象不应该依赖于细节，细节应该依赖于抽象，要针对接口编程，而不是针对实现编程。（依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象）</p>
</li>
<li>
<p><strong>接口隔离原则</strong> Interface Segregation Principle</p>
<p>使用多个专用接口，而不是使用单一的总接口，客户端不应该依赖于那些它不需要的接口。</p>
</li>
<li>
<p><strong>迪米特法则</strong> Law of Demeter</p>
<p>一个软件实体应当尽可能少的与其他实体发生互相作用（<em>高内聚，低耦合</em>）。</p>
</li>
</ul>
<h2 id="为什么要多用组合少用继承">为什么要多用组合，少用继承</h2>
<p>变化部分取出并封装起来，便于以后扩展，而不影响其他部分。要针对接口编程而不是针对实现编程。</p>
<h2 id="一句话常用设计模式">一句话常用设计模式</h2>
<ol>
<li>Iterator——迭代器</li>
<li>Adapter（适配器）————换个包装再度利用</li>
</ol>
<p>◎ 万事交给子类：</p>
<ol>
<li>Template Method（模板方法）————实际处理就交给子类</li>
<li>Factory Method（工厂方法）————建立对象实例交给子类</li>
</ol>
<p>◎建立对象实例</p>
<ol>
<li>Singleton（单件）————唯一的对象实例</li>
<li>Prototype（原型）————复制建立对象实例</li>
<li>Builder（生成器）————组合复杂的对象实例</li>
<li>Abstract Factory（抽象工厂）————把相关零件组合成产品</li>
</ol>
<p>◎切割性思考</p>
<ol>
<li>Bridge（桥接）————分成功能层次和实现层次</li>
<li>Strategy（策略）————把算法整个换掉</li>
</ol>
<p>◎一视同仁</p>
<ol>
<li>Composite（组成）————对容器和内容一视同仁</li>
<li>Decorator（装饰）————对装饰和内容一视同仁</li>
</ol>
<p>◎在结构中穿梭来去</p>
<ol>
<li>Visitor（访问者）————在结构中穿梭还同时做事</li>
<li>Chain of Responsibility（职责链）————责任转送</li>
</ol>
<p>◎简单最好</p>
<ol>
<li>Facade（外观）————单一窗口</li>
<li>Mediator（中介者）————只要面对一个顾问</li>
</ol>
<p>◎管理状态</p>
<ol>
<li>Observer（观察者）————通知状态变化</li>
<li>Memento（备忘录）————存储状态</li>
<li>State（状态）————以类表示状态</li>
</ol>
<p>◎精简不浪费</p>
<ol>
<li>Flyweight（享元）————有相同的部分就分享，采取精简政策</li>
<li>Proxy（代理）————要用在建立</li>
</ol>
<p>◎用类来表示</p>]]></description></item><item><title>UML设计与基本概念</title><link>https://blog.gethin.online/uml-design/</link><pubDate>Wed, 23 Jun 2021 20:18:17 +0800</pubDate><author>xxxx</author><guid>https://blog.gethin.online/uml-design/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/content.jpg" referrerpolicy="no-referrer">
            </div><h2 id="uml-的各种图">UML 的各种图</h2>
<p>UML 又称为统一建模语言，是为面向对象开发系统进行说明、可视化的一种标准语言。<br>
UML 的分类如下：</p>


<div id="blueprint" class="mindmap mindmap-md">
    <ul>
<li>UML
<ul>
<li>用例视图
<ul>
<li>用例图</li>
</ul>
</li>
<li>设计视图
<ul>
<li>类图</li>
<li>对象图</li>
</ul>
</li>
<li>进程视图
<ul>
<li>时序图</li>
<li>协作图</li>
<li>状态图</li>
<li>活动图</li>
</ul>
</li>
<li>实现视图
<ul>
<li>构件图</li>
</ul>
</li>
<li>拓扑视图
<ul>
<li>部署图</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
<h2 id="用例图">用例图</h2>
<p></p>
<h2 id="类图">类图</h2>
<p>类图是描述类与类之间的关系，在类图里有常见的六种关系。分别是<strong>泛化</strong>（Generalization）,  <strong>实现</strong>（Realization），<strong>关联</strong>（Association)，<strong>聚合</strong>（Aggregation），<strong>组合</strong>(Composition)，<strong>依赖</strong>(Dependency)</p>
<p>各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p>
<ol>
<li>泛化（一种继承关系）<br>
例如：动物 -&gt; 老虎<br>
</li>
<li>实现（类与接口的关系，表示接口的实现）<br>
例如：鸟 -&gt; 燕子<br>
</li>
<li>聚合（部分和整体的关系，但部分可以脱离整体单独存在）<br>
【代码体现】：成员变量<br>
例如：汽车 -&gt; 轮子<br>
</li>
<li>组合（部分和整体的关系，但部分不能脱离整体单独存在，整体没了部分也无法独活）<br>
【代码体现】：成员变量<br>
例如：公司 -&gt; 部门<br>
</li>
<li>关联（类和类之间知道彼此的存在【属性、方法之类】，关联可以是单项的，也可以是双向的）<br>
【代码体现】：成员变量<br>
例如：夫妻、师生<br>
</li>
<li>依赖（使用的关系，类与类独立，仅存在协助关系，并且尽量不使用双向互相依赖）<br>
【代码表现】：局部变量、方法的参数或者对静态方法的调用<br>
例如：人 -&gt; 锤子<br>
</li>
<li>各种类图的关系
</li>
</ol>
<h2 id="对象图">对象图</h2>
<p>描述的是参与交互的各个对象在交互过程中某一时刻的状态。</p>]]></description></item><item><title>[转载]Redis面试题</title><link>https://blog.gethin.online/redis-reprinted/</link><pubDate>Fri, 04 Jun 2021 21:06:39 +0800</pubDate><author>xxxx</author><guid>https://blog.gethin.online/redis-reprinted/</guid><description><![CDATA[<div class="featured-image">
                <img src="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/redis-2021-06-04-21-41-23.jpg" referrerpolicy="no-referrer">
            </div><p></p>
<h2 id="概述">概述</h2>
<hr>
<h3 id="什么是redis">什么是Redis</h3>
<p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。</p>
<p>Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p>
<h3 id="redis有哪些优缺点">Redis有哪些优缺点</h3>
<p>优点</p>
<ul>
<li>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。</li>
<li>支持数据持久化，支持AOF和RDB两种持久化方式。</li>
<li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li>
<li>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<p>缺点</p>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h3 id="为什么要用-redis-为什么要用缓存">为什么要用 Redis /为什么要用缓存</h3>
<p>主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<p><strong>高性能：</strong></p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p></p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p></p>]]></description></item><item><title>[转载]消息中间件MQ与RabbitMQ面试题</title><link>https://blog.gethin.online/rabbitmq-reprinted/</link><pubDate>Fri, 04 Jun 2021 10:58:43 +0800</pubDate><author>xxxx</author><guid>https://blog.gethin.online/rabbitmq-reprinted/</guid><description><![CDATA[<div class="featured-image">
                <img src="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/RabbitMQ-2021-06-04-13-49-43.jpg" referrerpolicy="no-referrer">
            </div><h2 id="为什么使用mqmq的优点">为什么使用MQ？MQ的优点</h2>
<hr>
<p>简答</p>
<ul>
<li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。</li>
<li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li>
<li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li>
<li>日志处理 - 解决大量日志传输。</li>
<li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li>
</ul>
<p>详答</p>
<p>主要是：解耦、异步、削峰。</p>
<p><strong>解耦</strong>：A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃…A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p>
<p>就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。</p>
<p><strong>异步</strong>：A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。</p>]]></description></item><item><title>软件架构设计</title><link>https://blog.gethin.online/software-architecture-design/</link><pubDate>Sat, 29 May 2021 21:01:34 +0800</pubDate><author>xxxx</author><guid>https://blog.gethin.online/software-architecture-design/</guid><description><![CDATA[<div class="featured-image">
                <img src="/images/content.jpg" referrerpolicy="no-referrer">
            </div><h2 id="1-软件架构概述">1 软件架构概述</h2>
<h3 id="11-软件架构的定义">1.1 软件架构的定义</h3>
<p>架构是对系统的抽象，由多个架构组成，任何软件都存在架构，元素与其行为的集合构成架构内容，架构具有“基础性”，架构隐含有“决策”。</p>
<h3 id="12-软件架构重要性">1.2 软件架构重要性</h3>
<p>项目关系人之间交流平台；<br>
早期设计决策；<br>
在较高层面上实现软件复用；<br>
架构对开发的指导与规范意义不容忽略。</p>
<h3 id="13-架构的模型">1.3 架构的模型</h3>
<p>结构模型；框架模型；动态模型；过程模型；功能模型；<br>
逻辑视图，开发视图，进程视图，物理视图，场景。</p>
<h2 id="2-架构需求与软件质量属性">2 架构需求与软件质量属性</h2>
<h3 id="21-软件质量属性">2.1 软件质量属性</h3>
<p><strong>功能性；可靠性；易用性；效率；可维护性；可移植性；</strong></p>
<ul>
<li>
<p>1 运行期质量属性<br>
<strong>性能；安全性；易用性；可伸缩性；互操作性；可靠性；持续可用性；鲁棒性；</strong></p>
</li>
<li>
<p>2 开发期质量属性<br>
<strong>易理解性；可扩展性；可重用性；可测试性；可维护性；</strong></p>
</li>
</ul>
<h3 id="22-六个质量属性与实现">2.2 六个质量属性与实现</h3>
<p>质量属性：<strong>可用性；可修改性；性能；安全性；可测试性；易用性；</strong></p>
<p>质量属性场景组件：<strong>刺激源；刺激；环境；制品；响应；响应度量；</strong></p>
<ul>
<li>1 <strong>可用性与其实现战术</strong><br>
可用性描述<br>
可用性战术<br>
错误检测：命令/响应；心跳；异常；<br>
错误恢复<br>
表决；主动冗余；被动冗余；备件；状态再同步；检查点/回滚；<br>
错误预防<br>
从服务中删除；事务；进程监视器；</li>
<li>2 <strong>可修改性与其实现战术</strong><br>
可修改性描述<br>
可修改性战术<br>
局部化修改；(维持语义的一致性；预期期望的变更；泛化该模块；限制可能的选择)<br>
防止连锁反应；（信息隐藏；维持现有的接口；限制通信路径；仲裁者的使用）<br>
推迟绑定时间；（运行时注册；配置文件；多态；构件更换；）</li>
<li>3 <strong>性能与其实现技术</strong><br>
性能描述<br>
性能战术<br>
资源消耗：闭锁时间；<br>
资源需求：减少处理事件流所需的资源；减少所处理事件的数量；控制资源的使用；<br>
资源管理：引入并发；维持数据或计算的多个副本；增加可用资源；<br>
资源仲裁：先进先出；固定优先级调度；动态优先级调度；静态调度；</li>
<li>4 <strong>安全性与其实现技术</strong><br>
安全性描述<br>
安全性战术<br>
抵抗攻击：对用户进行身份验证；对用户进行授权；维护数据的机密性；维护完整性；限制暴露的信息；限制访问；<br>
检测攻击<br>
从攻击中恢复：恢复；识别攻击者；</li>
<li>5 <strong>可测试性与其实现战术</strong><br>
可测试性描述<br>
可测试性战术<br>
输入/输出：记录回放；将接口与现实分离；优化访问线路<br>
内部监控</li>
<li>6 <strong>易用性与实现战术</strong><br>
易用性描述<br>
易用性战术<br>
运行时战术：任务的模型；用户的模型；系统的模型；<br>
设计时战术<br>
支持用户主动操作</li>
</ul>
<p>常见的六个质量属性:<strong>可用性、可修改性、性能、安全性、可测试性、易用性。</strong></p>]]></description></item></channel></rss>