<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>设计模式 - Gethin</title><meta name=Description content="This is my cool site"><meta property="og:url" content="https://blog.gethin.online/design-pattern/"><meta property="og:site_name" content="Gethin"><meta property="og:title" content="设计模式"><meta property="og:description" content="设计模式六大原则 单一职责原则 Single Responsibility Principle
一个类只负责一个功能领域中的相应职责，或者就一个类而言，应该只有一个引起它变化的原因。
开放封闭原则 Open-Close Priciple
一个软件实体应当对扩展开放，对修改封闭。软件实体应该尽量在不修改原有代码的情况下进行扩展。
里氏替换原则 Liskove Substitution Principe
所有引用基类的地方必须能透明的使用其子类的对象。（在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物）
依赖倒置原则 Dependency Inversion Principle
抽象不应该依赖于细节，细节应该依赖于抽象，要针对接口编程，而不是针对实现编程。（依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象）
接口隔离原则 Interface Segregation Principle
使用多个专用接口，而不是使用单一的总接口，客户端不应该依赖于那些它不需要的接口。
迪米特法则 Law of Demeter
一个软件实体应当尽可能少的与其他实体发生互相作用（高内聚，低耦合）。
为什么要多用组合，少用继承 变化部分取出并封装起来，便于以后扩展，而不影响其他部分。要针对接口编程而不是针对实现编程。
一句话常用设计模式 Iterator——迭代器 Adapter（适配器）————换个包装再度利用 ◎ 万事交给子类：
Template Method（模板方法）————实际处理就交给子类 Factory Method（工厂方法）————建立对象实例交给子类 ◎建立对象实例
Singleton（单件）————唯一的对象实例 Prototype（原型）————复制建立对象实例 Builder（生成器）————组合复杂的对象实例 Abstract Factory（抽象工厂）————把相关零件组合成产品 ◎切割性思考
Bridge（桥接）————分成功能层次和实现层次 Strategy（策略）————把算法整个换掉 ◎一视同仁
Composite（组成）————对容器和内容一视同仁 Decorator（装饰）————对装饰和内容一视同仁 ◎在结构中穿梭来去
Visitor（访问者）————在结构中穿梭还同时做事 Chain of Responsibility（职责链）————责任转送 ◎简单最好
Facade（外观）————单一窗口 Mediator（中介者）————只要面对一个顾问 ◎管理状态
Observer（观察者）————通知状态变化 Memento（备忘录）————存储状态 State（状态）————以类表示状态 ◎精简不浪费
Flyweight（享元）————有相同的部分就分享，采取精简政策 Proxy（代理）————要用在建立 ◎用类来表示"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-15T15:10:00+08:00"><meta property="article:modified_time" content="2025-08-14T16:26:14+08:00"><meta property="article:tag" content="设计模式"><meta property="article:tag" content="系统架构师"><meta property="og:image" content="https://blog.gethin.online/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.gethin.online/logo.png"><meta name=twitter:title content="设计模式"><meta name=twitter:description content="设计模式六大原则 单一职责原则 Single Responsibility Principle
一个类只负责一个功能领域中的相应职责，或者就一个类而言，应该只有一个引起它变化的原因。
开放封闭原则 Open-Close Priciple
一个软件实体应当对扩展开放，对修改封闭。软件实体应该尽量在不修改原有代码的情况下进行扩展。
里氏替换原则 Liskove Substitution Principe
所有引用基类的地方必须能透明的使用其子类的对象。（在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物）
依赖倒置原则 Dependency Inversion Principle
抽象不应该依赖于细节，细节应该依赖于抽象，要针对接口编程，而不是针对实现编程。（依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象）
接口隔离原则 Interface Segregation Principle
使用多个专用接口，而不是使用单一的总接口，客户端不应该依赖于那些它不需要的接口。
迪米特法则 Law of Demeter
一个软件实体应当尽可能少的与其他实体发生互相作用（高内聚，低耦合）。
为什么要多用组合，少用继承 变化部分取出并封装起来，便于以后扩展，而不影响其他部分。要针对接口编程而不是针对实现编程。
一句话常用设计模式 Iterator——迭代器 Adapter（适配器）————换个包装再度利用 ◎ 万事交给子类：
Template Method（模板方法）————实际处理就交给子类 Factory Method（工厂方法）————建立对象实例交给子类 ◎建立对象实例
Singleton（单件）————唯一的对象实例 Prototype（原型）————复制建立对象实例 Builder（生成器）————组合复杂的对象实例 Abstract Factory（抽象工厂）————把相关零件组合成产品 ◎切割性思考
Bridge（桥接）————分成功能层次和实现层次 Strategy（策略）————把算法整个换掉 ◎一视同仁
Composite（组成）————对容器和内容一视同仁 Decorator（装饰）————对装饰和内容一视同仁 ◎在结构中穿梭来去
Visitor（访问者）————在结构中穿梭还同时做事 Chain of Responsibility（职责链）————责任转送 ◎简单最好
Facade（外观）————单一窗口 Mediator（中介者）————只要面对一个顾问 ◎管理状态
Observer（观察者）————通知状态变化 Memento（备忘录）————存储状态 State（状态）————以类表示状态 ◎精简不浪费
Flyweight（享元）————有相同的部分就分享，采取精简政策 Proxy（代理）————要用在建立 ◎用类来表示"><meta name=application-name content="Gethin"><meta name=apple-mobile-web-app-title content="Gethin"><meta name=referrer content="no-referrer"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.gethin.online/design-pattern/><link rel=prev href=https://blog.gethin.online/system-analysis-and-design/><link rel=next href=https://blog.gethin.online/software-architecture-pattern/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"设计模式","inLanguage":"zh-cn","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.gethin.online\/design-pattern\/"},"image":["https:\/\/blog.gethin.online\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"设计模式, 系统架构师","wordcount":739,"url":"https:\/\/blog.gethin.online\/design-pattern\/","datePublished":"2021-08-15T15:10:00+08:00","dateModified":"2025-08-14T16:26:14+08:00","publisher":{"@type":"Organization","name":"gethin","logo":"https:\/\/cdn.jsdelivr.net\/gh\/Gethin1990\/PicBed\/BlogImg\/g.PNG"},"author":{"@type":"Person","name":"xxxx"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=Gethin><span class=header-title-pre><i class='fas fa-cloud-sun'></i></span><span class=header-title-post>Cloud & Sun</span></a></div><div class=menu style=overflow:visible><div class=menu-inner><a class=menu-item href=/ title=首页><i class='fas fa-home fa-fw'></i>首页</a>
<a class=menu-item href=/categories/><i class='fas fa-th-list fa-fw'></i>分类</a>
<a class=menu-item href=/tags/><i class='fas fa-tags fa-fw'></i> 标签</a>
<a class=menu-item href=/posts/ title=所有文章><i class='fas fa-archive fa-fw'></i>归档</a><div class="dropdown menu-item" style=display:inline><a class=btn href=javascript:void(0); role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false><i class='fas fa-fan fa-fw'></i>分享</a><div class=dropdown-menu style=display:none><a class=dropdown-item href=/memories/><i class='fas fa-database fa-fw'></i> 记忆 </a><a class=dropdown-item href=/reveal/><i class='fas fa-arrow-alt-circle-right fa-fw'></i> 展示 </a><a class=dropdown-item href=/websites/><i class='fas fa-globe fa-fw'></i> 网站</a></div></div><div class="dropdown menu-item" style=display:inline><a class=btn href=javascript:void(0); role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false><i class='fas fa-door-closed fa-fw'></i>传送门</a><div class=dropdown-menu style=display:none><a class=dropdown-item href=/message-board/><i class='fas fa-comments fa-fw'></i> 留言板 </a><a class=dropdown-item href=/milestone/><i class='fas fa-monument fa-fw'></i> 里程碑 </a><a class=dropdown-item href=/links/><i class='fas fa-user-friends fa-fw'></i> 友情链</a></div></div><div class="dropdown menu-item" style=display:inline><a class=btn href=javascript:void(0); role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false><i class='fas fa-user-secret fa-fw'></i>关于</a><div class=dropdown-menu style=display:none><a class=dropdown-item href=/about/><i class='fas fa-address-card fa-fw'></i> 关于本人 </a><a class=dropdown-item href=/keypoint/><i class='fas fa-star fa-fw'></i> 关键信息</a></div></div><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="menu-item language" title=选择语言><i class="fa fa-globe fa-fw" aria-hidden=true></i>
<select class=language-select id=language-select-desktop onchange="location=this.value"><option value=/design-pattern/ selected></option></select></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=Gethin><span class=header-title-pre><i class='fas fa-cloud-sun'></i></span><span class=header-title-post>Cloud & Sun</span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/ title=首页><i class='fas fa-home fa-fw'></i>首页</a>
<a class=menu-item href=/categories/ title><i class='fas fa-th-list fa-fw'></i>分类</a>
<a class=menu-item href=/tags/ title><i class='fas fa-tags fa-fw'></i> 标签</a>
<a class=menu-item href=/posts/ title=所有文章><i class='fas fa-archive fa-fw'></i>归档</a><div class="dropdown menu-item"><a class=btn href=javascript:void(0); role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false><i class='fas fa-fan fa-fw'></i>分享</a><div class="dropdown-menu dropdown-menu-mobile" style=display:none><a class=dropdown-item href=/memories/><i class='fas fa-database fa-fw'></i> 记忆 </a><a class=dropdown-item href=/reveal/><i class='fas fa-arrow-alt-circle-right fa-fw'></i> 展示 </a><a class=dropdown-item href=/websites/><i class='fas fa-globe fa-fw'></i> 网站</a></div></div><div class="dropdown menu-item"><a class=btn href=javascript:void(0); role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false><i class='fas fa-door-closed fa-fw'></i>传送门</a><div class="dropdown-menu dropdown-menu-mobile" style=display:none><a class=dropdown-item href=/message-board/><i class='fas fa-comments fa-fw'></i> 留言板 </a><a class=dropdown-item href=/milestone/><i class='fas fa-monument fa-fw'></i> 里程碑 </a><a class=dropdown-item href=/links/><i class='fas fa-user-friends fa-fw'></i> 友情链</a></div></div><div class="dropdown menu-item"><a class=btn href=javascript:void(0); role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false><i class='fas fa-user-secret fa-fw'></i>关于</a><div class="dropdown-menu dropdown-menu-mobile" style=display:none><a class=dropdown-item href=/about/><i class='fas fa-address-card fa-fw'></i> 关于本人 </a><a class=dropdown-item href=/keypoint/><i class='fas fa-star fa-fw'></i> 关键信息</a></div></div><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class=menu-item title=选择语言><i class="fa fa-globe fa-fw" aria-hidden=true></i>
<select class=language-select onchange="location=this.value"><option value=/design-pattern/ selected></option></select>
</a>--></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">设计模式</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>xxxx</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E6%9E%B6%E6%9E%84%E8%89%BA%E6%9C%AF/><i class="far fa-folder fa-fw" aria-hidden=true></i>架构艺术</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2021-08-15>2021-08-15</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 739 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 4 分钟&nbsp;</div></div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=/images/content.jpg data-srcset="/images/content.jpg, /images/content.jpg 1.5x, /images/content.jpg 2x" data-sizes=auto alt=/images/content.jpg title=/images/content.jpg width=2363 height=1269></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#设计模式六大原则>设计模式六大原则</a></li><li><a href=#为什么要多用组合少用继承>为什么要多用组合，少用继承</a></li><li><a href=#一句话常用设计模式>一句话常用设计模式</a></li><li><a href=#设计模式口诀>设计模式口诀</a></li><li><a href=#设计模式代码>设计模式代码</a></li><li><a href=#c-中常用的设计模式>C# 中常用的设计模式</a></li><li><a href=#设计模式介绍>设计模式介绍</a><ul><li><a href=#抽象工厂模式>抽象工厂模式</a></li><li><a href=#工厂模式>工厂模式</a></li><li><a href=#建造者模式>建造者模式</a></li><li><a href=#单例模式>单例模式</a></li><li><a href=#原型模式>原型模式</a></li><li><a href=#适配器模式>适配器模式</a></li><li><a href=#代理模式>代理模式</a></li><li><a href=#桥接模式>桥接模式</a></li><li><a href=#组合模式>组合模式</a></li><li><a href=#装饰器模式>装饰器模式</a></li><li><a href=#外观模式>外观模式</a></li><li><a href=#享元模式>享元模式</a></li><li><a href=#责任链模式>责任链模式</a></li><li><a href=#命令模式>命令模式</a></li><li><a href=#中介者模式>中介者模式</a></li><li><a href=#观察者模式>观察者模式</a></li><li><a href=#迭代器模式>迭代器模式</a></li><li><a href=#备忘录模式>备忘录模式</a></li><li><a href=#解释器模式>解释器模式</a></li><li><a href=#策略模式>策略模式</a></li><li><a href=#访问者模式>访问者模式</a></li><li><a href=#状态模式>状态模式</a></li><li><a href=#模板模式>模板模式</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=设计模式六大原则>设计模式六大原则</h2><ul><li><p><strong>单一职责原则</strong> Single Responsibility Principle</p><p>一个类只负责一个功能领域中的相应职责，或者就一个类而言，应该只有一个引起它变化的原因。</p></li><li><p><strong>开放封闭原则</strong> Open-Close Priciple</p><p>一个软件实体应当对扩展开放，对修改封闭。软件实体应该尽量在不修改原有代码的情况下进行扩展。</p></li><li><p><strong>里氏替换原则</strong> Liskove Substitution Principe</p><p>所有引用基类的地方必须能透明的使用其子类的对象。（在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物）</p></li><li><p><strong>依赖倒置原则</strong> Dependency Inversion Principle</p><p>抽象不应该依赖于细节，细节应该依赖于抽象，要针对接口编程，而不是针对实现编程。（依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象）</p></li><li><p><strong>接口隔离原则</strong> Interface Segregation Principle</p><p>使用多个专用接口，而不是使用单一的总接口，客户端不应该依赖于那些它不需要的接口。</p></li><li><p><strong>迪米特法则</strong> Law of Demeter</p><p>一个软件实体应当尽可能少的与其他实体发生互相作用（<em>高内聚，低耦合</em>）。</p></li></ul><h2 id=为什么要多用组合少用继承>为什么要多用组合，少用继承</h2><p>变化部分取出并封装起来，便于以后扩展，而不影响其他部分。要针对接口编程而不是针对实现编程。</p><h2 id=一句话常用设计模式>一句话常用设计模式</h2><ol><li>Iterator——迭代器</li><li>Adapter（适配器）————换个包装再度利用</li></ol><p>◎ 万事交给子类：</p><ol><li>Template Method（模板方法）————实际处理就交给子类</li><li>Factory Method（工厂方法）————建立对象实例交给子类</li></ol><p>◎建立对象实例</p><ol><li>Singleton（单件）————唯一的对象实例</li><li>Prototype（原型）————复制建立对象实例</li><li>Builder（生成器）————组合复杂的对象实例</li><li>Abstract Factory（抽象工厂）————把相关零件组合成产品</li></ol><p>◎切割性思考</p><ol><li>Bridge（桥接）————分成功能层次和实现层次</li><li>Strategy（策略）————把算法整个换掉</li></ol><p>◎一视同仁</p><ol><li>Composite（组成）————对容器和内容一视同仁</li><li>Decorator（装饰）————对装饰和内容一视同仁</li></ol><p>◎在结构中穿梭来去</p><ol><li>Visitor（访问者）————在结构中穿梭还同时做事</li><li>Chain of Responsibility（职责链）————责任转送</li></ol><p>◎简单最好</p><ol><li>Facade（外观）————单一窗口</li><li>Mediator（中介者）————只要面对一个顾问</li></ol><p>◎管理状态</p><ol><li>Observer（观察者）————通知状态变化</li><li>Memento（备忘录）————存储状态</li><li>State（状态）————以类表示状态</li></ol><p>◎精简不浪费</p><ol><li>Flyweight（享元）————有相同的部分就分享，采取精简政策</li><li>Proxy（代理）————要用在建立</li></ol><p>◎用类来表示</p><ol><li>Command（命令）————将命令写成类</li><li>Interpreter（解释器）————以类来表达语法规则</li></ol><h2 id=设计模式口诀>设计模式口诀</h2><p>创建5：工厂，抽象工厂，单例，原型，建造者， 【抽工建单元】</p><p>结构7：适配器，代理，桥接，组合，装饰，外观，享元，【时代接合装外向】</p><p>行为11：解释器，模版，责任链，命令，中介，观察者，迭代器，备忘录，访问者，状态，策略 【责令中介观迭被，解释策略防撞模】</p><h2 id=设计模式代码>设计模式代码</h2><p>自己整理的设计模式UML图与代码如下，UML 使用VS2015建模项目。</p><p><a href=https://github.com/Gethin1990/design_pattern target=_blank rel="noopener noreffer">https://github.com/Gethin1990/design_pattern</a></p><h2 id=c-中常用的设计模式>C# 中常用的设计模式</h2><p>单例（全局唯一）、工厂（反射）、迭代器（foreach）、观察者（消息队列）、责任链（pipeline）、外观（Gateway）、代理（网络相关）、解释器（表达式树）、策略（打折业务）等</p><h2 id=设计模式介绍>设计模式介绍</h2><h3 id=抽象工厂模式>抽象工厂模式</h3><p><strong>意图</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><strong>主要解决</strong>：接口选择的问题。</p><p><strong>何时使用</strong>：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p><strong>如何解决</strong>：在一个产品族里面，定义多个产品。</p><p><strong>关键代码</strong>：在一个工厂里聚合多个同类产品。</p><p><strong>应用实例</strong>：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p><p><strong>优点</strong>：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点</strong>：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景</strong>： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p><p><strong>注意事项</strong>：产品族难扩展，产品等级易扩展。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815152523-2021-08-15-15-25-23.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815152523-2021-08-15-15-25-23.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815152523-2021-08-15-15-25-23.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815152523-2021-08-15-15-25-23.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815152523-2021-08-15-15-25-23.png title=抽象工厂></p><h3 id=工厂模式>工厂模式</h3><p><strong>意图</strong>：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p><strong>主要解决</strong>：接口选择的问题。</p><p><strong>何时使用</strong>：我们明确地计划不同条件下创建不同实例时。</p><p><strong>如何解决</strong>：让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p><strong>关键代码</strong>：创建过程在其子类执行。</p><p><strong>应用实例</strong>： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p><p><strong>优点</strong>： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p><strong>缺点</strong>：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p><strong>使用场景</strong>： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，&ldquo;POP3&rdquo;、&ldquo;IMAP&rdquo;、&ldquo;HTTP&rdquo;，可以把这三个作为产品类，共同实现一个接口。</p><p><strong>注意事项</strong>：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815152140-2021-08-15-15-21-41.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815152140-2021-08-15-15-21-41.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815152140-2021-08-15-15-21-41.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815152140-2021-08-15-15-21-41.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815152140-2021-08-15-15-21-41.png title=工厂></p><h3 id=建造者模式>建造者模式</h3><p><strong>意图</strong>：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>主要解决</strong>：在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p><strong>何时使用</strong>：一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>如何解决</strong>：将变与不变分离开。</p><p><strong>关键代码</strong>：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p><strong>应用实例</strong>： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。</p><p><strong>优点</strong>： 1、建造者独立，易扩展。 2、便于控制细节风险。</p><p><strong>缺点</strong>： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p><p><strong>使用场景</strong>： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p><p><strong>注意事项</strong>：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163536-2021-08-15-16-35-36.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163536-2021-08-15-16-35-36.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163536-2021-08-15-16-35-36.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163536-2021-08-15-16-35-36.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163536-2021-08-15-16-35-36.png title=建造者模式></p><h3 id=单例模式>单例模式</h3><p><strong>意图</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决</strong>：一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用</strong>：当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决</strong>：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码</strong>：构造函数是私有的。</p><p><strong>应用实例</strong>：</p><p>1、一个班级只有一个班主任。
2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。
<strong>优点</strong>：</p><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
2、避免对资源的多重占用（比如写文件操作）。
<strong>缺点</strong>：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><strong>使用场景</strong>：</p><p>1、要求生产唯一序列号。
2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。
<strong>注意事项</strong>：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163458-2021-08-15-16-34-59.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163458-2021-08-15-16-34-59.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163458-2021-08-15-16-34-59.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163458-2021-08-15-16-34-59.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163458-2021-08-15-16-34-59.png title=单例模式></p><h3 id=原型模式>原型模式</h3><p><strong>意图</strong>：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p><strong>主要解决</strong>：在运行期建立和删除原型。</p><p><strong>何时使用</strong>： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p><p><strong>如何解决</strong>：利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p><p><strong>关键代码</strong>： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。</p><p><strong>应用实例</strong>： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。</p><p><strong>优点</strong>： 1、性能提高。 2、逃避构造函数的约束。</p><p><strong>缺点</strong>： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</p><p><strong>使用场景</strong>： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p><p><strong>注意事项</strong>：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163607-2021-08-15-16-36-07.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163607-2021-08-15-16-36-07.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163607-2021-08-15-16-36-07.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163607-2021-08-15-16-36-07.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163607-2021-08-15-16-36-07.png title=原型模式></p><h3 id=适配器模式>适配器模式</h3><p><strong>意图</strong>：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>主要解决</strong>：在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><p><strong>何时使用</strong>： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p><p><strong>如何解决</strong>：继承或依赖（推荐）。</p><p><strong>关键代码</strong>：适配器继承或依赖已有的对象，实现想要的目标接口。</p><p><strong>应用实例</strong>： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</p><p><strong>优点</strong>： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p><p><strong>缺点</strong>： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p><p><strong>使用场景</strong>：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p><strong>注意事项</strong>：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163650-2021-08-15-16-36-50.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163650-2021-08-15-16-36-50.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163650-2021-08-15-16-36-50.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163650-2021-08-15-16-36-50.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163650-2021-08-15-16-36-50.png title=适配器模式></p><h3 id=代理模式>代理模式</h3><p><strong>意图</strong>：为其他对象提供一种代理以控制对这个对象的访问。</p><p><strong>主要解决</strong>：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p><p><strong>何时使用</strong>：想在访问一个类时做一些控制。</p><p><strong>如何解决</strong>：增加中间层。</p><p><strong>关键代码</strong>：实现与被代理类组合。</p><p><strong>应用实例</strong>： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。</p><p><strong>优点</strong>： 1、职责清晰。 2、高扩展性。 3、智能化。</p><p><strong>缺点</strong>： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p><p><strong>使用场景</strong>：按职责来划分，通常有以下<strong>使用场景</strong>： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p><p><strong>注意事项</strong>： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163732-2021-08-15-16-37-33.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163732-2021-08-15-16-37-33.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163732-2021-08-15-16-37-33.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163732-2021-08-15-16-37-33.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163732-2021-08-15-16-37-33.png title=代理模式></p><h3 id=桥接模式>桥接模式</h3><p><strong>意图</strong>：将抽象部分与实现部分分离，使它们都可以独立的变化。</p><p><strong>主要解决</strong>：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p><p><strong>何时使用</strong>：实现系统可能有多个角度分类，每一种角度都可能变化。</p><p><strong>如何解决</strong>：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p><p><strong>关键代码</strong>：抽象类依赖实现类。</p><p><strong>应用实例</strong>： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</p><p><strong>优点</strong>： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。</p><p><strong>缺点</strong>：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p><p><strong>使用场景</strong>： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p><p><strong>注意事项</strong>：对于两个独立变化的维度，使用桥接模式再适合不过了。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163752-2021-08-15-16-37-52.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163752-2021-08-15-16-37-52.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163752-2021-08-15-16-37-52.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163752-2021-08-15-16-37-52.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163752-2021-08-15-16-37-52.png title=桥接模式></p><h3 id=组合模式>组合模式</h3><p><strong>意图</strong>：将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p><strong>主要解决</strong>：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><p><strong>何时使用</strong>： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p><strong>如何解决</strong>：树枝和叶子实现统一接口，树枝内部组合该接口。</p><p><strong>关键代码</strong>：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p><p><strong>应用实例</strong>： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p><p><strong>优点</strong>： 1、高层模块调用简单。 2、节点自由增加。</p><p><strong>缺点</strong>：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p><p><strong>使用场景</strong>：部分、整体场景，如树形菜单，文件、文件夹的管理。</p><p><strong>注意事项</strong>：定义时为具体类。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163810-2021-08-15-16-38-10.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163810-2021-08-15-16-38-10.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163810-2021-08-15-16-38-10.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163810-2021-08-15-16-38-10.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163810-2021-08-15-16-38-10.png title=组合模式></p><h3 id=装饰器模式>装饰器模式</h3><p><strong>意图</strong>：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p><strong>主要解决</strong>：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><p><strong>何时使用</strong>：在不想增加很多子类的情况下扩展类。</p><p><strong>如何解决</strong>：将具体功能职责划分，同时继承装饰者模式。</p><p><strong>关键代码</strong>： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p><p><strong>应用实例</strong>： 1、孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p><p><strong>优点</strong>：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p><strong>缺点</strong>：多层装饰比较复杂。</p><p><strong>使用场景</strong>： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p><p><strong>注意事项</strong>：可代替继承。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163834-2021-08-15-16-38-34.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163834-2021-08-15-16-38-34.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163834-2021-08-15-16-38-34.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163834-2021-08-15-16-38-34.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163834-2021-08-15-16-38-34.png title=装饰器模式></p><h3 id=外观模式>外观模式</h3><p><strong>意图</strong>：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p><strong>主要解决</strong>：降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。</p><p><strong>何时使用</strong>： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。</p><p><strong>如何解决</strong>：客户端不与系统耦合，外观类与系统耦合。</p><p><strong>关键代码</strong>：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p><p><strong>应用实例</strong>： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。</p><p><strong>优点</strong>： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。</p><p><strong>缺点</strong>：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p><p><strong>使用场景</strong>： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。</p><p><strong>注意事项</strong>：在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163851-2021-08-15-16-38-51.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163851-2021-08-15-16-38-51.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163851-2021-08-15-16-38-51.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163851-2021-08-15-16-38-51.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163851-2021-08-15-16-38-51.png title=外观模式></p><h3 id=享元模式>享元模式</h3><p><strong>意图</strong>：运用共享技术有效地支持大量细粒度的对象。</p><p><strong>主要解决</strong>：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p><p><strong>何时使用</strong>： 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p><p><strong>如何解决</strong>：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p><p><strong>关键代码</strong>：用 HashMap 存储这些对象。</p><p><strong>应用实例</strong>： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。</p><p><strong>优点</strong>：大大减少对象的创建，降低系统的内存，使效率提高。</p><p><strong>缺点</strong>：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p><p><strong>使用场景</strong>： 1、系统有大量相似对象。 2、需要缓冲池的场景。</p><p><strong>注意事项</strong>： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163917-2021-08-15-16-39-18.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163917-2021-08-15-16-39-18.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163917-2021-08-15-16-39-18.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163917-2021-08-15-16-39-18.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163917-2021-08-15-16-39-18.png title=享元模式></p><h3 id=责任链模式>责任链模式</h3><p><strong>意图</strong>：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p><strong>主要解决</strong>：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p><strong>何时使用</strong>：在处理消息的时候以过滤很多道。</p><p><strong>如何解决</strong>：拦截的类都实现统一接口。</p><p><strong>关键代码</strong>：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p><p><strong>应用实例</strong>： 1、红楼梦中的"击鼓传花"。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</p><p><strong>优点</strong>： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p><p><strong>缺点</strong>： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p><p><strong>使用场景</strong>： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p><p><strong>注意事项</strong>：在 JAVA WEB 中遇到很多应用。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163946-2021-08-15-16-39-46.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163946-2021-08-15-16-39-46.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163946-2021-08-15-16-39-46.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163946-2021-08-15-16-39-46.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815163946-2021-08-15-16-39-46.png title=责任链模式></p><h3 id=命令模式>命令模式</h3><p><strong>意图</strong>：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p><p><strong>主要解决</strong>：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p><p><strong>何时使用</strong>：在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p><p><strong>如何解决</strong>：通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。</p><p><strong>关键代码</strong>：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口</p><p><strong>应用实例</strong>：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p><p><strong>优点</strong>： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。</p><p><strong>缺点</strong>：使用命令模式可能会导致某些系统有过多的具体命令类。</p><p><strong>使用场景</strong>：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</p><p><strong>注意事项</strong>：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164017-2021-08-15-16-40-18.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164017-2021-08-15-16-40-18.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164017-2021-08-15-16-40-18.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164017-2021-08-15-16-40-18.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164017-2021-08-15-16-40-18.png title=命令模式></p><h3 id=中介者模式>中介者模式</h3><p><strong>意图</strong>：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p><strong>主要解决</strong>：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p><p><strong>何时使用</strong>：多个类相互耦合，形成了网状结构。</p><p><strong>如何解决</strong>：将上述网状结构分离为星型结构。</p><p><strong>关键代码</strong>：对象 Colleague 之间的通信封装到一个类中单独处理。</p><p><strong>应用实例</strong>： 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</p><p><strong>优点</strong>： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。</p><p><strong>缺点</strong>：中介者会庞大，变得复杂难以维护。</p><p><strong>使用场景</strong>： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p><p><strong>注意事项</strong>：不应当在职责混乱的时候使用。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164055-2021-08-15-16-40-56.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164055-2021-08-15-16-40-56.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164055-2021-08-15-16-40-56.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164055-2021-08-15-16-40-56.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164055-2021-08-15-16-40-56.png title=中介者模式></p><h3 id=观察者模式>观察者模式</h3><p><strong>意图</strong>：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><strong>主要解决</strong>：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p><strong>何时使用</strong>：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p><p><strong>如何解决</strong>：使用面向对象技术，可以将这种依赖关系弱化。</p><p><strong>关键代码</strong>：在抽象类里有一个 ArrayList 存放观察者们。</p><p><strong>应用实例</strong>： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p><p><strong>优点</strong>： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p><p><strong>缺点</strong>： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164117-2021-08-15-16-41-17.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164117-2021-08-15-16-41-17.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164117-2021-08-15-16-41-17.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164117-2021-08-15-16-41-17.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164117-2021-08-15-16-41-17.png title=观察者模式></p><h3 id=迭代器模式>迭代器模式</h3><p><strong>意图</strong>：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p><p><strong>主要解决</strong>：不同的方式来遍历整个整合对象。</p><p><strong>何时使用</strong>：遍历一个聚合对象。</p><p><strong>如何解决</strong>：把在元素之间游走的责任交给迭代器，而不是聚合对象。</p><p><strong>关键代码</strong>：定义接口：hasNext, next。</p><p><strong>应用实例</strong>：JAVA 中的 iterator。</p><p><strong>优点</strong>： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p><p><strong>缺点</strong>：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p><p><strong>使用场景</strong>： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。</p><p><strong>注意事项</strong>：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164226-2021-08-15-16-42-27.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164226-2021-08-15-16-42-27.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164226-2021-08-15-16-42-27.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164226-2021-08-15-16-42-27.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164226-2021-08-15-16-42-27.png title=迭代器模式></p><h3 id=备忘录模式>备忘录模式</h3><p><strong>意图</strong>：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p><strong>主要解决</strong>：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p><p><strong>何时使用</strong>：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有"后悔药"可吃。</p><p><strong>如何解决</strong>：通过一个备忘录类专门存储对象状态。</p><p><strong>关键代码</strong>：客户不与备忘录类耦合，与备忘录管理类耦合。</p><p><strong>应用实例</strong>： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。</p><p><strong>优点</strong>： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p><p><strong>缺点</strong>：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p><p><strong>使用场景</strong>： 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。</p><p><strong>注意事项</strong>： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164308-2021-08-15-16-43-08.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164308-2021-08-15-16-43-08.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164308-2021-08-15-16-43-08.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164308-2021-08-15-16-43-08.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164308-2021-08-15-16-43-08.png title=备忘录模式></p><h3 id=解释器模式>解释器模式</h3><p><strong>意图</strong>：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><p><strong>主要解决</strong>：对于一些固定文法构建一个解释句子的解释器。</p><p><strong>何时使用</strong>：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p><p><strong>如何解决</strong>：构建语法树，定义终结符与非终结符。</p><p><strong>关键代码</strong>：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。</p><p><strong>应用实例</strong>：编译器、运算表达式计算。</p><p><strong>优点</strong>： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。</p><p><strong>缺点</strong>： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。</p><p><strong>使用场景</strong>： 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。</p><p><strong>注意事项</strong>：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164413-2021-08-15-16-44-13.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164413-2021-08-15-16-44-13.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164413-2021-08-15-16-44-13.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164413-2021-08-15-16-44-13.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164413-2021-08-15-16-44-13.png title=解释器模式></p><h3 id=策略模式>策略模式</h3><p><strong>意图</strong>：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p><strong>主要解决</strong>：在有多种算法相似的情况下，使用 if&mldr;else 所带来的复杂和难以维护。</p><p><strong>何时使用</strong>：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p><strong>如何解决</strong>：将这些算法封装成一个一个的类，任意地替换。</p><p><strong>关键代码</strong>：实现同一个接口。</p><p><strong>应用实例</strong>： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p><p><strong>优点</strong>： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p><strong>缺点</strong>： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><p><strong>使用场景</strong>： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p><p><strong>注意事项</strong>：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164428-2021-08-15-16-44-29.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164428-2021-08-15-16-44-29.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164428-2021-08-15-16-44-29.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164428-2021-08-15-16-44-29.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164428-2021-08-15-16-44-29.png title=策略模式></p><h3 id=访问者模式>访问者模式</h3><p><strong>意图</strong>：主要将数据结构与数据操作分离。</p><p><strong>主要解决</strong>：稳定的数据结构和易变的操作耦合问题。</p><p><strong>何时使用</strong>：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。</p><p><strong>如何解决</strong>：在被访问的类里面加一个对外提供接待访问者的接口。</p><p><strong>关键代码</strong>：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p><p><strong>应用实例</strong>：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p><p><strong>优点</strong>： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。</p><p><strong>缺点</strong>： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p><p><strong>使用场景</strong>： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类。</p><p><strong>注意事项</strong>：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815165155-2021-08-15-16-51-56.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815165155-2021-08-15-16-51-56.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815165155-2021-08-15-16-51-56.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815165155-2021-08-15-16-51-56.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815165155-2021-08-15-16-51-56.png title=访问者模式></p><h3 id=状态模式>状态模式</h3><p><strong>意图</strong>：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p><p><strong>主要解决</strong>：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p><p><strong>何时使用</strong>：代码中包含大量与对象状态有关的条件语句。</p><p><strong>如何解决</strong>：将各种具体的状态类抽象出来。</p><p><strong>关键代码</strong>：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if&mldr;else 等条件选择语句。</p><p><strong>应用实例</strong>： 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，&lsquo;钟是抽象接口&rsquo;,&lsquo;钟A&rsquo;等是具体状态，&lsquo;曾侯乙编钟&rsquo;是具体环境（Context）。</p><p><strong>优点</strong>： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p><p><strong>缺点</strong>： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p><p><strong>使用场景</strong>： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。</p><p><strong>注意事项</strong>：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164619-2021-08-15-16-46-19.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164619-2021-08-15-16-46-19.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164619-2021-08-15-16-46-19.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164619-2021-08-15-16-46-19.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815164619-2021-08-15-16-46-19.png title=状态模式></p><h3 id=模板模式>模板模式</h3><p><strong>意图</strong>：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决</strong>：一些方法通用，却在每一个子类都重新写了这一方法。</p><p><strong>何时使用</strong>：有一些通用的方法。</p><p><strong>如何解决</strong>：将这些通用算法抽象出来。</p><p><strong>关键代码</strong>：在抽象类实现，其他步骤在子类实现。</p><p><strong>应用实例</strong>： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p><p><strong>优点</strong>： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。</p><p><strong>缺点</strong>：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><p><strong>使用场景</strong>： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p><p><strong>注意事项</strong>：为防止恶意操作，一般模板方法都加上 final 关键词。</p><hr><p><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815165133-2021-08-15-16-51-33.png data-srcset="https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815165133-2021-08-15-16-51-33.png, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815165133-2021-08-15-16-51-33.png 1.5x, https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815165133-2021-08-15-16-51-33.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/Gethin1990/PicBed/BlogImg/20210815165133-2021-08-15-16-51-33.png title=模板模式></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2025-08-14</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=x data-url=https://blog.gethin.online/design-pattern/ data-title=设计模式 data-hashtags=设计模式,系统架构师><i class="fab fa-x-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Threads" data-sharer=threads data-url=https://blog.gethin.online/design-pattern/ data-title=设计模式><i class="fab fa-threads fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://blog.gethin.online/design-pattern/ data-hashtag=设计模式><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://blog.gethin.online/design-pattern/ data-title=设计模式><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://blog.gethin.online/design-pattern/ data-title=设计模式><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://blog.gethin.online/design-pattern/ data-title=设计模式><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Diaspora" data-sharer=diaspora data-url=https://blog.gethin.online/design-pattern/ data-title=设计模式 data-description><i class="fab fa-diaspora fa-fw" aria-hidden=true></i></a><a href="https://t.me/share/url?url=https%3a%2f%2fblog.gethin.online%2fdesign-pattern%2f&amp;text=%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f" target=_blank title="分享到 Telegram"><i class="fab fa-telegram fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a>,&nbsp;<a href=/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/>系统架构师</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/system-analysis-and-design/ class=prev rel=prev title=系统分析与设计><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>系统分析与设计</a>
<a href=/software-architecture-pattern/ class=next rel=next title=软件架构模式>软件架构模式<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=gitalk class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://github.com/gitalk/gitalk>Gitalk</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><span id=timeDate>运行 time 天&nbsp;|&nbsp;</span>
<script>var now=new Date;function createtime(){var e,t=new Date("05/05/2021 00:00:00");now.setTime(now.getTime()+250),days=(now-t)/1e3/60/60/24,dnum=Math.floor(days),e=document.getElementById("timeDate").innerHTML.replace(/time/,Math.floor(days)),document.getElementById("timeDate").innerHTML=e}createtime()</script>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.148.2">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.3.1-DEV"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021 - 2025</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>格心</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/>知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i></a></div><div id=fixed-buttons-hidden><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css><link rel=stylesheet href=/css/_custom.scss><script src=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js></script><script src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js></script><script src=https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js></script><script src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script src=https://cdn.jsdelivr.net/npm/twemoji@13.0.0/dist/twemoji.min.js></script><script src=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js></script><script src=https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js></script><script src=https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js></script><script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script src=https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><script src=/js/jquery.backstretch.min.js></script><script src=/js/dayjs.min.js></script><script src=/js/custom.js></script><script>window.config={comment:{gitalk:{admin:["Gethin1990"],clientID:"4743974d0c1165efbf05",clientSecret:"94543d55ec4241197bf2029c5167870e9185d619",id:"2021-08-15T15:10:00+08:00",owner:"Gethin1990",repo:"gsblogtalk",title:"设计模式"}},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"MFVMILWR8Y",algoliaIndex:"gethin_blog",algoliaSearchKey:"9116370b412bf8b2f2adaf656612f599",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},twemoji:!0}</script><script src=/js/theme.min.js></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-FFRV57P35K")}</script><script src="https://www.googletagmanager.com/gtag/js?id=G-FFRV57P35K" async></script></body></html>